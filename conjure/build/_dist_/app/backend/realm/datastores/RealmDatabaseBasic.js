import{MemoryDatastore as E}from"../../../../../web_modules/interface-datastore.js";import*as c from"../../../../../web_modules/@AssetSync/common/src/datastore-utils.js";import y from"../../../../../web_modules/uint8arrays/from-string.js";import a from"../../../../../web_modules/uint8arrays/to-string.js";import"../../../../../web_modules/@AssetSync/common.js";import k from"../../../../../web_modules/hyperdiff.js";import{NETWORKING_OPCODES as K}from"../../Constants.js";import{REALM_TYPES as g}from"../RealmData.js";const u={addEntry:"addEntry",removeEntry:"removeEntry",requestKeys:"requestKeys",receiveKeys:"receiveKeys",requestEntries:"requestEntries",receiveEntries:"receiveEntries"};export default async(o,f,l)=>new Promise(async m=>{let p=!1;const R=async e=>{f("Syncing from "+e+". Requesting keys..."),o.sendTo(e,u.requestKeys,"")},v=()=>{p||(f("Finished Sync!"),p=!0,m())};o.network.on("onPeerJoin",async e=>{(p||l&&!p)&&R(e)}),o.network.on("onPeerLeave",e=>{});let i;o.assetSync.transportPlugin._libp2p.repo&&o.realmData.type!==g.EPHEMERAL?i=await o.assetSync.transportPlugin._libp2p.repo.openDatastore(o.dhtProtocol+"/objects"):i=new E;let d;o.assetSync.transportPlugin._libp2p.repo&&o.realmData.type!==g.EPHEMERAL?d=await o.assetSync.transportPlugin._libp2p.repo.openDatastore(o.dhtProtocol+"/metadata"):d=new E;const T=async e=>{try{const t=y(e),r=await d.get(c.bufferToKey(t)),n=c.decodeRecord(r);return a(n.value)}catch(t){return}},S=async(e,t)=>{try{const r=y(e),n=y(t),s=await c.createPutRecord(r,n);return await d.put(c.bufferToKey(r),s),!0}catch(r){return!1}};o._stopDatastores=async()=>{await i.close(),await d.close()},o._get=async e=>{try{const t=y(e),r=await i.get(c.bufferToKey(t)),n=c.decodeRecord(r);return{key:a(n.key),value:a(n.value),timeReceived:n.timeReceived}}catch(t){return}},o._put=async(e,t,r)=>{try{const n=y(e),s=y(t),h=await c.createPutRecord(n,s,r);return await i.put(c.bufferToKey(n),h),!0}catch(n){return!1}},o._getAllLocal=async()=>{try{const e=[];for await(const t of i.query({})){if(!t.value||!t.value.length)continue;const r=c.decodeRecord(t.value);e.push({key:a(r.key),value:a(r.value),timeReceived:r.timeReceived})}return e}catch(e){return[]}},o._removeLocal=async e=>{try{const t=y(e);return await i.delete(c.bufferToKey(t)),await i.put(c.bufferToKey(t),y("")),!0}catch(t){throw!1}},o.on(u.requestKeys,async(e,t)=>{f("Received request for keys",e),o.sendTo(t,u.receiveKeys,await w())}),o.on(u.receiveKeys,async(e,t)=>{f("Requesting entries for",e),Object.keys(e).length?o.sendTo(t,u.requestEntries,await A(e)):l&&v()}),o.on(u.requestEntries,async(e,t)=>{f("Received request for entries",e),o.sendTo(t,u.receiveEntries,await _(e))}),o.on(u.receiveEntries,async(e,t)=>{f("Updating entries for",e);for(let r of e)r&&(await o._put(r.key,r.value,r.timeReceived),o.emit(K.OBJECT.RECEIVE,{uuid:r.key,data:r.value}));l&&v()});async function w(){const e={},t=await o._getAllLocal();return t.length&&t.forEach(({key:r,value:n,timeReceived:s})=>{e[r]=s}),e}async function _(e=[]){let t=[];for(let r of e)if(typeof r=="string"&&r!==""){const n=await o._get(r);n?t.push(n):console.log("empty entry",r,n)}return t}async function A(e){let t=[];const r=await w(),n=k(Object.keys(r).sort(),Object.keys(e).sort());return n.added.forEach(s=>{t.push(s)}),n.removed.forEach(async s=>{await o._put(s,"",e[s])}),n.common.forEach(async s=>{Date.parse(r[s])>Date.parse(e[s])&&t.push(s)}),t}l||v()});
