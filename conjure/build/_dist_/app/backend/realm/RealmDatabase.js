import c from"../../../../web_modules/events.js";import{NETWORKING_OPCODES as r}from"../Constants.js";import{REALM_WORLD_GENERATORS as u}from"./RealmData.js";import h from"./datastores/RealmDatabaseBasic.js";import"./datastores/RealmDatabaseProcedural.js";import"../../../../web_modules/@AssetSync/common.js";import p from"./RealmWorld.js";const m=1e3/60,O=m,b=5*1e3,v=5*60*1e3;export default class y extends c{constructor(e,t,a){super();this.eventHooks=new c,this.realmHandler=e,this.assetSync=e.assetSync,this.realmData=t,this.dhtProtocol=a+this.realmData.id,this.isInitialised=!1,this.objects={},this.updateQueue={},this.objectsToSave=[],this.updatePeers=this.updatePeers.bind(this),this.saveUpdates=this.saveUpdates.bind(this),this.saveAll=this.saveAll.bind(this),this._stopDatastores=async()=>{console.warn("ERROR! Database",t.id,"has no _stopDatastores implemented")},this._get=async s=>{console.warn("ERROR! Database",t.id,"has no _get implemented")},this._put=async(s,o)=>{console.warn("ERROR! Database",t.id,"has no _put implemented")},this._getAllLocal=async()=>{console.warn("ERROR! Database",t.id,"has no _getAllLocal implemented")},this._removeLocal=async s=>{console.warn("ERROR! Database",t.id,"has no _removeLocal implemented")},this.onObjectCreate=(s,o)=>{},this.onObjectUpdate=(s,o)=>{},this.onObjectGroup=(s,o)=>{},this.onObjectMove=(s,o)=>{},this.onObjectDestroy=(s,o)=>{}}async start(e=()=>{},t){const a=Date.now();e("Opening database for realm",this.realmData.id),this.network=await this.assetSync.networkPlugin.joinNetwork(this.realmData.id),this.world=new p(this),this.network.on("message",s=>{this.eventHooks.emit("message",s);try{const{opcode:o,content:i}=JSON.parse(s.data);this.emit(o,i,s.from)}catch(o){console.log("hmm bad message",o,s)}}),this.network.on("onPeerJoin",s=>{this.eventHooks.emit("onPeerJoin",s)}),this.network.on("onPeerLeave",s=>{this.eventHooks.emit("onPeerLeave",s)}),this.on(r.OBJECT.CREATE,async(s,o)=>{const{uuid:i,data:n}=s;await this._put(i,JSON.stringify(n));const l=this.realmHandler.objectLoader.parse(n);this.world.loadObject(l),this.onObjectCreate(l,o)}),this.on(r.OBJECT.UPDATE,async(s,o)=>{for(let{uuid:i,params:n}of s)for(let{param:l,value:d}of n)this.world.updateObject(i,l,d)}),this.on(r.OBJECT.DESTROY,async(s,o)=>{const{uuid:i,data:n}=s;await this._put(i,"");const l=this.world.getObject(i);this.world.removeObject(l),this.onObjectDestroy(l,o)}),this.on(r.OBJECT.MOVE,async(s,o)=>{const{uuid:i,data:n}=JSON.parse(s);await this._put(i,n)}),this.on(r.OBJECT.GROUP,async(s,o)=>{}),this.realmData.worldSettings.worldGeneratorType===u.NONE&&await h(this,e,t),await this.world.initialise(e,t),this.queueInterval=setInterval(this.updatePeers,O),this.saveInterval=setInterval(this.saveUpdates,b),this.saveAllInterval=setInterval(this.saveAll,v),this.isInitialised=!0,e("Finished syncing database for realm",this.realmData.id,"in",Date.now()-a,"ms")}async stop(){clearInterval(this.queueInterval),clearInterval(this.saveAllInterval),clearInterval(this.saveInterval),this.eventHooks.removeAllListeners(),await this.network.leave(),await this._stopDatastores()}sendToAll(e,t){this.network.broadcast(JSON.stringify({opcode:e,content:t}))}sendTo(e,t,a){this.network.sendTo(e,JSON.stringify({opcode:t,content:a}))}updatePeers(){const e=Object.keys(this.updateQueue);if(!e.length)return;const t=[];for(let a of e){const s=[],o=this.world.getObject(a);if(!o)continue;for(let i of this.updateQueue[a])o[i]&&s.push({param:i,value:o[i]});t.push({uuid:a,params:s})}this.updateQueue={},this.sendToAll(r.OBJECT.UPDATE,t)}async saveUpdates(){if(this.objectsToSave.length){for(let e of this.objectsToSave){delete e.userData.needsSaving;const t=e.toJSON();await this._put(e.uuid,JSON.stringify(t))}this.objectsToSave=[],console.log("Realm "+this.realmData.id+" updates successfully saved.")}}async saveAll(){for(let e of this.world.getAllObjects())if(e.body||e.userData.needsSaving){delete e.userData.needsSaving;const t=e.toJSON();await this._put(e.uuid,JSON.stringify(t))}console.log("Realm "+this.realmData.id+" successfully saved.")}async joinNetwork(){this.network.getPeers().length||await new Promise(e=>{this.network.on("onPeerJoin",()=>{e()})})}async createObject(e){try{const t=e.uuid,a=e.toJSON();return await this._put(t,JSON.stringify(a)),this.world.loadObject(e),this.sendToAll(r.OBJECT.CREATE,{uuid:t,data:a}),!0}catch(t){return console.log(t),!1}}async getObjects(){if(this.isInitialised)return this.world.getAllObjects();const e=[];return e.push(...await this._getAllLocal()),e.map(t=>{try{return t.value===""?void 0:this.realmHandler.objectLoader.parse(JSON.parse(t.value))}catch(a){console.log(a);return}}).filter(t=>t!==void 0)}async updateObject(e,t){t=Array.isArray(t)?t:[t];try{const a=typeof e=="object"?e.uuid:e;return this.updateQueue[a]||(this.updateQueue[a]=[]),this.updateQueue[a].push([...t]),this.objectsToSave.includes(e)||this.objectsToSave.push(e),!0}catch(a){return console.log(a),!1}}async removeObject(e){try{const t=typeof e=="object"?e.uuid:e;return await this._put(t,""),this.world.removeObject(e),this.sendToAll(r.OBJECT.DESTROY,{uuid:t}),!0}catch(t){return console.log(t),!1}}async transactObject({uuid:e,data:t}){}}
