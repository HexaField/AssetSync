import{MemoryDatastore as g}from"../../../../../web_modules/interface-datastore.js";import*as s from"./utils.js";import c from"../../../../../web_modules/uint8arrays/from-string.js";import u from"../../../../../web_modules/uint8arrays/to-string.js";import{isNode as m,number as A}from"../../../../../web_modules/@AssetSync/common.js";import S from"../../../../../web_modules/hyperdiff.js";import{NETWORKING_OPCODES as K}from"../../Constants.js";const i={addEntry:"addEntry",removeEntry:"removeEntry",requestKeys:"requestKeys",receiveKeys:"receiveKeys",requestEntries:"requestEntries",receiveEntries:"receiveEntries"};export default async o=>{let y;o.assetSync.transportPlugin._libp2p.repo?y=await o.assetSync.transportPlugin._libp2p.repo.openDatastore(o.dhtProtocol+"/objects"):y=new g;let d;o.assetSync.transportPlugin._libp2p.repo?d=await o.assetSync.transportPlugin._libp2p.repo.openDatastore(o.dhtProtocol+"/metadata"):d=new g;const v=async e=>{try{const t=c(e),r=await d.get(s.bufferToKey(t)),n=s.decodeRecord(r);return u(n.value)}catch(t){return}},l=async(e,t)=>{try{const r=c(e),n=c(t),f=await s.createPutRecord(r,n);return await d.put(s.bufferToKey(r),f),!0}catch(r){return!1}};o._get=async e=>{try{const t=c(e),r=await y.get(s.bufferToKey(t)),n=s.decodeRecord(r);return{key:u(n.key),value:u(n.value),timeReceived:n.timeReceived}}catch(t){console.log(t);return}},o._put=async(e,t,r)=>{try{const n=c(e),f=c(t),h=await s.createPutRecord(n,f,r);return await y.put(s.bufferToKey(n),h),!0}catch(n){return console.log(n),!1}},o._getAllLocal=async()=>{try{const e=[];for await(const t of y.query({})){const r=s.decodeRecord(t.value);e.push({key:u(r.key),value:u(r.value),timeReceived:r.timeReceived})}return e}catch(e){return console.log(e),[]}},o._removeLocal=async e=>{try{const t=c(e);return await y.delete(s.bufferToKey(t)),await y.put(s.bufferToKey(t),c("")),!0}catch(t){throw console.log(t),!1}};const a=async()=>A(await v("lastSynced")),E=async()=>{await l("lastSynced",String(Date.now()))},p=await a();p?console.log("Last synced at",new Date(p).toLocaleString()):await l("lastSynced",String(0)),o.network.on("onPeerJoin",async e=>{o.sendTo(e,i.requestKeys,await a())}),o.network.on("onPeerLeave",e=>{}),o.on(i.requestKeys,async(e,t)=>{m&&e<await a()&&o.sendTo(t,i.receiveKeys,await w())}),o.on(i.receiveKeys,async(e,t)=>{Array.isArray(e)&&e.length&&o.sendTo(t,i.requestEntries,await _(e))}),o.on(i.requestEntries,async(e,t)=>{Array.isArray(e)&&e.length&&o.sendTo(t,i.receiveEntries,await k(e))}),o.on(i.receiveEntries,async(e,t)=>{for(let r of e)await o._put(r.key,r.value,r.timeReceived),o.emit(K.OBJECT.RECEIVE,{uuid:r.key,data:r.value});await E()});async function w(){return(await o._getAllLocal()).sort().map(({key:e,value:t,timeReceived:r})=>({key:e,timeReceived:r}))}async function k(e){let t=[];for(let r of e)t.push(await o._get(r));return t}async function _(e){let t=[];const r=S(await w(),e);return r.added.forEach(n=>{t.push(n.key)}),r.removed.forEach(n=>{o._removeLocal(n.key)}),r.common.forEach(async n=>{n.timeReceived>(await o._get(key)).timeReceived&&t.push(n.key)}),t}};
