import{MemoryDatastore as R}from"../../../../../web_modules/interface-datastore.js";import*as s from"../../../../../web_modules/@AssetSync/common/src/datastore-utils.js";import c from"../../../../../web_modules/uint8arrays/from-string.js";import d from"../../../../../web_modules/uint8arrays/to-string.js";import{number as T}from"../../../../../web_modules/@AssetSync/common.js";import q from"../../../../../web_modules/hyperdiff.js";import{NETWORKING_OPCODES as L}from"../../Constants.js";import{REALM_TYPES as _}from"../RealmData.js";const y={addEntry:"addEntry",removeEntry:"removeEntry",requestKeys:"requestKeys",receiveKeys:"receiveKeys",requestEntries:"requestEntries",receiveEntries:"receiveEntries"};export default async(r,a,f)=>new Promise(async w=>{let i;r.assetSync.transportPlugin._libp2p.repo&&r.realmData.type!==_.EPHEMERAL?i=await r.assetSync.transportPlugin._libp2p.repo.openDatastore(r.dhtProtocol+"/objects"):i=new R;let u;r.assetSync.transportPlugin._libp2p.repo&&r.realmData.type!==_.EPHEMERAL?u=await r.assetSync.transportPlugin._libp2p.repo.openDatastore(r.dhtProtocol+"/metadata"):u=new R;const A=async e=>{try{const t=c(e),n=await u.get(s.bufferToKey(t)),o=s.decodeRecord(n);return d(o.value)}catch(t){return}},g=async(e,t)=>{try{const n=c(e),o=c(t),p=await s.createPutRecord(n,o);return await u.put(s.bufferToKey(n),p),!0}catch(n){return!1}};r._stopDatastores=async()=>{await i.close(),await u.close()},r._get=async e=>{try{const t=c(e),n=await i.get(s.bufferToKey(t)),o=s.decodeRecord(n);return{key:d(o.key),value:d(o.value),timeReceived:o.timeReceived}}catch(t){console.log(t);return}},r._put=async(e,t,n)=>{try{const o=c(e),p=c(t),K=await s.createPutRecord(o,p,n);return await i.put(s.bufferToKey(o),K),await l(),!0}catch(o){return console.log(o),!1}},r._getAllLocal=async()=>{try{const e=[];for await(const t of i.query({})){if(!t.value||!t.value.length)continue;const n=s.decodeRecord(t.value);e.push({key:d(n.key),value:d(n.value),timeReceived:n.timeReceived})}return e}catch(e){return console.log(e),[]}},r._removeLocal=async e=>{try{const t=c(e);return await i.delete(s.bufferToKey(t)),await i.put(s.bufferToKey(t),c("")),await l(),!0}catch(t){throw console.log(t),!1}};const v=async()=>T(await A("lastSynced")),l=async()=>{await g("lastSynced",String(Date.now()))},E=await v();E?console.log("Last synced at",new Date(E).toLocaleString()):await g("lastSynced",String(0));const k=async e=>{a("Syncing from "+e+". Requesting keys..."),r.sendTo(e,y.requestKeys,await v())};r.network.on("onPeerJoin",async e=>{f&&k(e)}),r.network.on("onPeerLeave",e=>{}),r.on(y.requestKeys,async(e,t)=>{a("Received request for keys",e),r.sendTo(t,y.receiveKeys,await m())}),r.on(y.receiveKeys,async(e,t)=>{Array.isArray(e)&&e.length?(a("Requesting entries for",...e),r.sendTo(t,y.requestEntries,await h(e))):(await l(),f&&w())}),r.on(y.requestEntries,async(e,t)=>{a("Received request for entries",...e),Array.isArray(e)&&e.length&&r.sendTo(t,y.receiveEntries,await S(e))}),r.on(y.receiveEntries,async(e,t)=>{a("Updating entries for",...e);for(let n of e)await r._put(n.key,n.value,n.timeReceived),r.emit(L.OBJECT.RECEIVE,{uuid:n.key,data:n.value});await l(),f&&w()});async function m(){return(await r._getAllLocal()).sort().map(({key:e,value:t,timeReceived:n})=>({key:e,timeReceived:n}))}async function S(e){let t=[];for(let n of e)t.push(await r._get(n));return t}async function h(e){let t=[];const n=q(await m(),e);return n.added.forEach(o=>{t.push(o.key)}),n.removed.forEach(async o=>{await r._removeLocal(o.key)}),n.common.forEach(async o=>{o.timeReceived>(await r._get(key)).timeReceived&&t.push(o.key)}),t}f||w()});
