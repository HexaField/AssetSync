import{MemoryDatastore as g}from"../../../../../web_modules/interface-datastore.js";import*as s from"../../../../../web_modules/@AssetSync/common/src/datastore-utils.js";import c from"../../../../../web_modules/uint8arrays/from-string.js";import u from"../../../../../web_modules/uint8arrays/to-string.js";import{isNode as R,number as S}from"../../../../../web_modules/@AssetSync/common.js";import h from"../../../../../web_modules/hyperdiff.js";import{NETWORKING_OPCODES as K}from"../../Constants.js";import{REALM_TYPES as v}from"../RealmData.js";const i={addEntry:"addEntry",removeEntry:"removeEntry",requestKeys:"requestKeys",receiveKeys:"receiveKeys",requestEntries:"requestEntries",receiveEntries:"receiveEntries"};export default async r=>{let y;r.assetSync.transportPlugin._libp2p.repo&&r.realmData.type!==v.EPHEMERAL?y=await r.assetSync.transportPlugin._libp2p.repo.openDatastore(r.dhtProtocol+"/objects"):y=new g;let a;r.assetSync.transportPlugin._libp2p.repo&&r.realmData.type!==v.EPHEMERAL?a=await r.assetSync.transportPlugin._libp2p.repo.openDatastore(r.dhtProtocol+"/metadata"):a=new g;const E=async e=>{try{const t=c(e),o=await a.get(s.bufferToKey(t)),n=s.decodeRecord(o);return u(n.value)}catch(t){return}},l=async(e,t)=>{try{const o=c(e),n=c(t),f=await s.createPutRecord(o,n);return await a.put(s.bufferToKey(o),f),!0}catch(o){return!1}};r._get=async e=>{try{const t=c(e),o=await y.get(s.bufferToKey(t)),n=s.decodeRecord(o);return{key:u(n.key),value:u(n.value),timeReceived:n.timeReceived}}catch(t){console.log(t);return}},r._put=async(e,t,o)=>{try{const n=c(e),f=c(t),k=await s.createPutRecord(n,f,o);return await y.put(s.bufferToKey(n),k),!0}catch(n){return console.log(n),!1}},r._getAllLocal=async()=>{try{const e=[];for await(const t of y.query({})){const o=s.decodeRecord(t.value);e.push({key:u(o.key),value:u(o.value),timeReceived:o.timeReceived})}return e}catch(e){return console.log(e),[]}},r._removeLocal=async e=>{try{const t=c(e);return await y.delete(s.bufferToKey(t)),await y.put(s.bufferToKey(t),c("")),!0}catch(t){throw console.log(t),!1}};const d=async()=>S(await E("lastSynced")),m=async()=>{await l("lastSynced",String(Date.now()))},p=await d();p?console.log("Last synced at",new Date(p).toLocaleString()):await l("lastSynced",String(0)),r.network.on("onPeerJoin",async e=>{r.sendTo(e,i.requestKeys,await d())}),r.network.on("onPeerLeave",e=>{}),r.on(i.requestKeys,async(e,t)=>{R&&e<await d()&&r.sendTo(t,i.receiveKeys,await w())}),r.on(i.receiveKeys,async(e,t)=>{Array.isArray(e)&&e.length&&r.sendTo(t,i.requestEntries,await _(e))}),r.on(i.requestEntries,async(e,t)=>{Array.isArray(e)&&e.length&&r.sendTo(t,i.receiveEntries,await A(e))}),r.on(i.receiveEntries,async(e,t)=>{for(let o of e)await r._put(o.key,o.value,o.timeReceived),r.emit(K.OBJECT.RECEIVE,{uuid:o.key,data:o.value});await m()});async function w(){return(await r._getAllLocal()).sort().map(({key:e,value:t,timeReceived:o})=>({key:e,timeReceived:o}))}async function A(e){let t=[];for(let o of e)t.push(await r._get(o));return t}async function _(e){let t=[];const o=h(await w(),e);return o.added.forEach(n=>{t.push(n.key)}),o.removed.forEach(n=>{r._removeLocal(n.key)}),o.common.forEach(async n=>{n.timeReceived>(await r._get(key)).timeReceived&&t.push(n.key)}),t}};
