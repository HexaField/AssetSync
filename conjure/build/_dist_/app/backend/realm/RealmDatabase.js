import c from"../../../../web_modules/events.js";import{NETWORKING_OPCODES as r}from"../Constants.js";import{REALM_WORLD_GENERATORS as l}from"./RealmData.js";import d from"./datastores/RealmDatabaseBasic.js";import"./datastores/RealmDatabaseProcedural.js";import"../../../../web_modules/@AssetSync/common.js";import h from"./RealmWorld.js";export default class u extends c{constructor(a,t,e){super();this.eventHooks=new c,this.realmHandler=a,this.assetSync=a.assetSync,this.realmData=t,this.dhtProtocol=e+this.realmData.id,this.objects={},this._stopDatastores=async()=>{console.warn("ERROR! Database",t.id,"has no _stopDatastores implemented")},this._get=async s=>{console.warn("ERROR! Database",t.id,"has no _get implemented")},this._put=async(s,o)=>{console.warn("ERROR! Database",t.id,"has no _put implemented")},this._getAllLocal=async()=>{console.warn("ERROR! Database",t.id,"has no _getAllLocal implemented")},this._removeLocal=async s=>{console.warn("ERROR! Database",t.id,"has no _removeLocal implemented")},this.onObjectCreate=(s,o)=>{},this.onObjectUpdate=(s,o)=>{},this.onObjectGroup=(s,o)=>{},this.onObjectMove=(s,o)=>{},this.onObjectDestroy=(s,o)=>{}}async start(a=()=>{},t){a("Opening database for realm",this.realmData.id),this.network=await this.assetSync.networkPlugin.joinNetwork(this.realmData.id),this.network.on("message",e=>{this.eventHooks.emit("message",e);try{const{opcode:s,content:o}=JSON.parse(e.data);this.emit(s,o,e.from)}catch(s){console.log("hmm bad message",s,e)}}),this.network.on("onPeerJoin",e=>{this.eventHooks.emit("onPeerJoin",e)}),this.network.on("onPeerLeave",e=>{this.eventHooks.emit("onPeerLeave",e)}),this.on(r.OBJECT.CREATE,async(e,s)=>{const{uuid:o,data:i}=e;await this._put(o,JSON.stringify(i));const n=this.realmHandler.objectLoader.parse(i);this.world.loadObject(n),this.onObjectCreate(n,s)}),this.on(r.OBJECT.UPDATE_PROPERTIES,async(e,s)=>{const{uuid:o,data:i}=e;await this._put(o,JSON.stringify(i))}),this.on(r.OBJECT.DESTROY,async(e,s)=>{const{uuid:o,data:i}=e;await this._put(o,""),this.onObjectDestroy(this.world.getObject(o),s)}),this.on(r.OBJECT.MOVE,async(e,s)=>{const{uuid:o,data:i}=JSON.parse(e);await this._put(o,i)}),this.on(r.OBJECT.GROUP,async(e,s)=>{}),this.realmData.worldSettings.worldGeneratorType===l.NONE&&await d(this,a,t),this.world=new h(this),await this.world.initialise(a)}async stop(){this.eventHooks.removeAllListeners(),await this.network.leave(),await this._stopDatastores()}sendToAll(a,t){this.network.broadcast(JSON.stringify({opcode:a,content:t}))}sendTo(a,t,e){this.network.sendTo(a,JSON.stringify({opcode:t,content:e}))}async joinNetwork(){this.network.getPeers().length||await new Promise(a=>{this.network.on("onPeerJoin",()=>{a()})})}async createObject(a){try{const t=a.uuid,e=a.toJSON();return await this._put(t,JSON.stringify(e)),this.world.loadObject(a),this.sendToAll(r.OBJECT.CREATE,{uuid:t,data:e}),!0}catch(t){return console.log(t),!1}}async getObjects(){const a=[];return a.push(...await this._getAllLocal()),a.map(t=>{try{return this.realmHandler.objectLoader.parse(JSON.parse(t.value))}catch(e){return}}).filter(t=>t!==void 0)}async updateObject(a){try{const t=a.uuid,e=a.toJSON();return await this._put(t,JSON.stringify(e)),this.world.updateObject(a),this.sendToAll(r.OBJECT.UPDATE_PROPERTIES,{uuid:t,data:e}),!0}catch(t){return console.log(t),!1}}async removeObject(a){try{const t=a.uuid,e=a.toJSON();return await this._put(t,""),this.world.removeObject(a),this.sendToAll(r.OBJECT.DESTROY,{uuid:t}),!0}catch(t){return console.log(t),!1}}async transactObject({uuid:a,data:t}){}}
