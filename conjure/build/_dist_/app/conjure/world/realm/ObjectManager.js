import*as n from"https://cdn.skypack.dev/pin/three@v0.117.1-NetLzdTnw9ga3y6o633U/min/three.js";import{number as c}from"../../util/number.js";import{NETWORKING_OPCODES as u}from"./NetworkingSchemas.js";export const PHYSICS_TYPES={NONE:"None",DYNAMIC:"Dynamic",STATIC:"Static",KINEMATIC:"Kinematic",GHOST:"Ghost"},PHYSICS_SHAPES={AUTO:"Automatic",CONVEX:"Convex Mesh",CONCAVE:"Concave Mesh",EXTRUDE:"Extrude Mesh",BOX:"Box",CONE:"Cone",CYLINDER:"Cylinder",PLANE:"Plane",SPHERE:"Sphere",TORUS:"Torus"};export default class a{constructor(t){this.realm=t,this.world=t.world,this.conjure=t.conjure,this.scene=this.conjure.scene,this.objects=[],this.vec3=new n.Vector3,this.quat=new n.Quaternion,this.physicsTypes=Object.values(PHYSICS_TYPES)}getPhysicsType(t){for(let e in this.physicsTypes)if(this.physicsTypes[e]===t)return e-1;return-1}getPhysicsShape(t){switch(t){case PHYSICS_SHAPES.AUTO:return"unknown";case PHYSICS_SHAPES.CONVEX:return"convexMesh";case PHYSICS_SHAPES.CONCAVE:return"concaveMesh";case PHYSICS_SHAPES.EXTRUDE:return"hacd";case PHYSICS_SHAPES.BOX:return"box";case PHYSICS_SHAPES.CONE:return"cone";case PHYSICS_SHAPES.CYLINDER:return"cylinder";case PHYSICS_SHAPES.PLANE:return"plane";case PHYSICS_SHAPES.SPHERE:return"sphere";case PHYSICS_SHAPES.TORUS:return"torus";default:return"unknown"}}async groupObjects(t,e,s){if(!t||!e||!t.parent||!e.parent)return;if(e.parent===t)return;if(this.getIsParentOfRecursive(e,t))return;let o=this.getTopGroupObject(e),i=this.getTopGroupObject(t);if(!o||!i)return;this.conjure.getControls().objectControls.detachAll(),e.parent.remove(e);let r=e.clone();i!==o&&(this.getObject(o)?await this.conjure.getWorld().destroyObject(o):await this.conjure.getWorld().updateObject(o)),t.add(r),r.userData.hash&&(r.userData.hash=null),await this.conjure.getWorld().updateObject(i),this.conjure.getScreens().screenObjectsHierarchy.updateObjects(),s||this.conjure.getWorld().sendData(u.OBJECT.UPDATE,{newParentUUID:t.UUID,newChildUUID:r.UUID})}getObject(t){for(let e of this.objects)if(e===t)return e}getObjectByHash(t){for(let e of this.objects)if(e.userData.hash===t)return e}getObjectByUUID(t){for(let e of this.objects)if(e.uuid===t)return e}addObject(t){this.objects.push(t),this.scene.add(t),this.conjure.getControls().addTransformObject(t),this.conjure.getScreens().screenObjectsHierarchy.updateObjects()}getTopGroupObject(t){for(let e of this.objects)if(this.getIsParentOfRecursive(e,t))return e;return}getIsParentOfRecursive(t,e){return t===e?!0:e.parent?this.getIsParentOfRecursive(t,e.parent):!1}getIsChildOfRecursive(t,e){if(this.getIsParentOfRecursive(t,e))return!1;if(t===e)return!0;for(let s of t.children)if(s===e)return!0;if(e.children)for(let s of e.children)return this.getIsChildOfRecursive(s,e);return!1}destroyAllObjects(){for(let t of this.objects)t.body&&this.conjure.physics.destroy(t.body),t.material&&t.material.dispose(),t.geometry&&t.geometry.dispose(),this.scene.remove(t);this.objects=[],this.conjure.renderer.renderLists.dispose()}destroyObjectByHash(t){for(let e of this.objects)e.userData.hash===t&&this.destroyObject(e)}destroyObject(t,e={}){if(t.body&&this.conjure.physics.destroy(t.body),!e.isChild)for(let s=0;s<this.objects.length;s++)this.objects[s]===t&&this.objects.splice(s,1);e.isChild?t.parent.remove(t):this.scene.remove(t),t.material&&t.material.dispose(),t.geometry&&t.geometry.dispose(),this.conjure.getScreens().screenObjectsHierarchy.updateObjects(),this.conjure.renderer.renderLists.dispose()}removeObject(t){for(let e=0;e<this.objects.length;e++)this.objects[e]===t&&this.objects.splice(e,1)}rgbToHex(t){var e=c(t).toString(16);return e.length<2&&(e="0"+e),e}update(t){for(let e of this.objects){let s=e.getWorldPosition(this.vec3);(s.y<-10||s.y>100||s.x>100||s.x<-100||s.z>100||s.z<-100)&&this.teleport(e,0,10,0)}if(this.conjure.getControls().activeControl===0&&!this.conjure.getScreens().mouseOver){let e=t.mouseRaycaster.intersectObjects(this.objects,!0);e.length>0?this.conjure.postProcessing.setHoverObject(e[0].object):this.conjure.postProcessing.setHoverObject()}else this.conjure.postProcessing.setHoverObject()}updateObjectFromClient(t,e){for(let s of this.objects)s.uuid===t&&(s.body?(s.body.setCollisionFlags(2),s.position.set(e.position.x,e.position.y,e.position.z),s.rotation.set(e.rotation.x,e.rotation.y,e.rotation.z),s.body.needUpdate=!0,s.body.once.update(()=>{s.body.setCollisionFlags(0),e.velocity&&s.body.setVelocity(e.velocity.x,e.velocity.y,e.velocity.z),e.angularVelocity&&s.body.setAngularVelocity(e.angularVelocity.x,e.angularVelocity.y,e.angularVelocity.z)})):(s.position.set(e.position.x,e.position.y,e.position.z),s.rotation.set(e.rotation.x,e.rotation.y,e.rotation.z)))}teleport(t,e,s,o){t.body.setCollisionFlags(2),t.position.set(e,s,o),t.body.needUpdate=!0,t.body.once.update(()=>{t.body.setCollisionFlags(0),t.body.setVelocity(0,0,0),t.body.setAngularVelocity(0,0,0)})}}
