import{Clock as N,Color as M,LinearEncoding as O,Matrix4 as L,Mesh as _,RepeatWrapping as C,ShaderMaterial as P,TextureLoader as z,UniformsLib as B,UniformsUtils as H,Vector2 as A,Vector4 as k}from"https://cdn.skypack.dev/pin/three@v0.117.1-NetLzdTnw9ga3y6o633U/min/three.js";import{Reflector as R}from"../../../../../web_modules/three/examples/jsm/objects/Reflector.js";import{Refractor as W}from"../../../../../web_modules/three/examples/jsm/objects/Refractor.js";var o=function(s,e){_.call(this,s),this.type="Water";var a=this;e=e||{};var b=e.color!==void 0?new M(e.color):new M(16777215),h=e.textureWidth||512,w=e.textureHeight||512,x=e.clipBias||0,j=e.flowDirection||new A(1,0),D=e.flowSpeed||.03,S=e.reflectivity||.02,T=e.scale||1,v=e.shader||o.WaterShader,g=e.encoding!==void 0?e.encoding:O,i=new z,y=e.flowMap||void 0,m=e.normalMap0||i.load("https://assets.conjure.world/assets/textures/water/Water_1_M_Normal.jpg")||i.load("assets/textures/water/Water_1_M_Normal.jpg"),d=e.normalMap1||i.load("https://assets.conjure.world/assets/textures/water/Water_2_M_Normal.jpg")||i.load("assets/textures/water/Water_2_M_Normal.jpg"),n=.15,f=n*.5,l=new L,U=new N;if(R===void 0){console.error("THREE.Water: Required component Reflector not found.");return}if(W===void 0){console.error("THREE.Water: Required component Refractor not found.");return}var c=new R(s,{textureWidth:h,textureHeight:w,clipBias:x,encoding:g}),u=new W(s,{textureWidth:h,textureHeight:w,clipBias:x,encoding:g});c.matrixAutoUpdate=!1,u.matrixAutoUpdate=!1,this.material=new P({uniforms:H.merge([B.fog,v.uniforms]),vertexShader:v.vertexShader,fragmentShader:v.fragmentShader,transparent:!0,fog:!0}),y!==void 0?(this.material.defines.USE_FLOWMAP="",this.material.uniforms.tFlowMap={type:"t",value:y}):this.material.uniforms.flowDirection={type:"v2",value:j},m.wrapS=m.wrapT=C,d.wrapS=d.wrapT=C,this.material.uniforms.tReflectionMap.value=c.getRenderTarget().texture,this.material.uniforms.tRefractionMap.value=u.getRenderTarget().texture,this.material.uniforms.tNormalMap0.value=m,this.material.uniforms.tNormalMap1.value=d,this.material.uniforms.color.value=b,this.material.uniforms.reflectivity.value=S,this.material.uniforms.textureMatrix.value=l,this.material.uniforms.config.value.x=0,this.material.uniforms.config.value.y=f,this.material.uniforms.config.value.z=f,this.material.uniforms.config.value.w=T;function E(t){l.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),l.multiply(t.projectionMatrix),l.multiply(t.matrixWorldInverse),l.multiply(a.matrixWorld)}function F(){var t=U.getDelta(),r=a.material.uniforms.config;r.value.x+=D*t,r.value.y=r.value.x+f,r.value.x>=n?(r.value.x=0,r.value.y=f):r.value.y>=n&&(r.value.y=r.value.y-n)}this.onBeforeRender=function(t,r,p){E(p),F(),a.visible=!1,c.matrixWorld.copy(a.matrixWorld),u.matrixWorld.copy(a.matrixWorld),c.onBeforeRender(t,r,p),u.onBeforeRender(t,r,p),a.visible=!0}};o.prototype=Object.create(_.prototype),o.prototype.constructor=o,o.WaterShader={uniforms:{color:{type:"c",value:null},reflectivity:{type:"f",value:0},tReflectionMap:{type:"t",value:null},tRefractionMap:{type:"t",value:null},tNormalMap0:{type:"t",value:null},tNormalMap1:{type:"t",value:null},textureMatrix:{type:"m4",value:null},config:{type:"v4",value:new k}},vertexShader:["#include <common>","#include <fog_pars_vertex>","#include <logdepthbuf_pars_vertex>","uniform mat4 textureMatrix;","varying vec4 vCoord;","varying vec2 vUv;","varying vec3 vToEye;","void main() {","	vUv = uv;","	vCoord = textureMatrix * vec4( position, 1.0 );","	vec4 worldPosition = modelMatrix * vec4( position, 1.0 );","	vToEye = cameraPosition - worldPosition.xyz;","	vec4 mvPosition =  viewMatrix * worldPosition;","	gl_Position = projectionMatrix * mvPosition;","	#include <logdepthbuf_vertex>","	#include <fog_vertex>","}"].join(`
`),fragmentShader:["#include <common>","#include <fog_pars_fragment>","#include <logdepthbuf_pars_fragment>","uniform sampler2D tReflectionMap;","uniform sampler2D tRefractionMap;","uniform sampler2D tNormalMap0;","uniform sampler2D tNormalMap1;","#ifdef USE_FLOWMAP","	uniform sampler2D tFlowMap;","#else","	uniform vec2 flowDirection;","#endif","uniform vec3 color;","uniform float reflectivity;","uniform vec4 config;","varying vec4 vCoord;","varying vec2 vUv;","varying vec3 vToEye;","void main() {","	#include <logdepthbuf_fragment>","	float flowMapOffset0 = config.x;","	float flowMapOffset1 = config.y;","	float halfCycle = config.z;","	float scale = config.w;","	vec3 toEye = normalize( vToEye );","	vec2 flow;","	#ifdef USE_FLOWMAP","		flow = texture2D( tFlowMap, vUv ).rg * 2.0 - 1.0;","	#else","		flow = flowDirection;","	#endif","	flow.x *= - 1.0;","	vec4 normalColor0 = texture2D( tNormalMap0, ( vUv * scale ) + flow * flowMapOffset0 );","	vec4 normalColor1 = texture2D( tNormalMap1, ( vUv * scale ) + flow * flowMapOffset1 );","	float flowLerp = abs( halfCycle - flowMapOffset0 ) / halfCycle;","	vec4 normalColor = mix( normalColor0, normalColor1, flowLerp );","	vec3 normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );","	float theta = max( dot( toEye, normal ), 0.0 );","	float reflectance = reflectivity + ( 1.0 - reflectivity ) * pow( ( 1.0 - theta ), 5.0 );","	vec3 coord = vCoord.xyz / vCoord.w;","	vec2 uv = coord.xy + coord.z * normal.xz * 0.05;","	vec4 reflectColor = texture2D( tReflectionMap, vec2( 1.0 - uv.x, uv.y ) );","	vec4 refractColor = texture2D( tRefractionMap, uv );","	gl_FragColor = vec4( color, 1.0 ) * mix( refractColor, reflectColor, reflectance );","	#include <tonemapping_fragment>","	#include <encodings_fragment>","	#include <fog_fragment>","}"].join(`
`)};export{o as Water};
