import{e as Ce}from"./events-18451fd5.js";import{s as pe,f as fe,p as _r,u as Pr,g as Ir,k as kr,r as Er,a as Y,b as me,i as xe}from"./index-3b7043f1.js";import{p as V}from"./process-e9e98960.js";import{b as F}from"./buffer-es6-e6024076.js";import{c as R,g as Tr,a as Me}from"./_commonjsHelpers-c99fd594.js";import{c as X,v as O,a as it,e as oe,k as se,l as ot,m as z,b as Ar}from"./datastore-utils-a4f1683f.js";import{t as M}from"./to-string-b6e14ed9.js";import{f as ae}from"./from-string-5d106fde.js";import{c as Ne,e as T,s as Be}from"./index-19b99eb6.js";import{r as st}from"./__node-resolve:empty-8495aa00.js";var Sr=(e,t=1,r)=>{if(r={indent:" ",includeEmptyLines:!1,...r},typeof e!="string")throw new TypeError(`Expected \`input\` to be a \`string\`, got \`${typeof e}\``);if(typeof t!="number")throw new TypeError(`Expected \`count\` to be a \`number\`, got \`${typeof t}\``);if(typeof r.indent!="string")throw new TypeError(`Expected \`options.indent\` to be a \`string\`, got \`${typeof r.indent}\``);if(t===0)return e;const n=r.includeEmptyLines?/^/gm:/^(?!\s*$)/gm;return e.replace(n,r.indent.repeat(t))};const at=/\s+at.*(?:\(|\s)(.*)\)?/,qr=/^(?:(?:(?:node|(?:internal\/[\w/]*|.*node_modules\/(?:babel-polyfill|pirates)\/.*)?\w+)\.js:\d+:\d+)|native)/,Rr=typeof st.homedir=="undefined"?"":st.homedir();var Or=(e,t)=>(t=Object.assign({pretty:!1},t),e.replace(/\\/g,"/").split(`
`).filter(r=>{const n=r.match(at);if(n===null||!n[1])return!0;const o=n[1];return o.includes(".app/Contents/Resources/electron.asar")||o.includes(".app/Contents/Resources/default_app.asar")?!1:!qr.test(o)}).filter(r=>r.trim()!=="").map(r=>t.pretty?r.replace(at,(n,o)=>n.replace(o,o.replace(Rr,"~"))):r).join(`
`));const Dr=e=>e.replace(/\s+at .*aggregate-error\/index.js:\d+:\d+\)?/g,"");class Cr extends Error{constructor(e){if(!Array.isArray(e))throw new TypeError(`Expected input to be an Array, got ${typeof e}`);e=[...e].map(r=>r instanceof Error?r:r!==null&&typeof r=="object"?Object.assign(new Error(r.message),r):new Error(r));let t=e.map(r=>typeof r.stack=="string"?Dr(Or(r.stack)):String(r)).join(`
`);t=`
`+Sr(t,4),super(t),this.name="AggregateError",Object.defineProperty(this,"_errors",{value:e})}*[Symbol.iterator](){for(const e of this._errors)yield e}}var Le=Cr;const ut="[a-fA-F\\d:]",H=e=>e&&e.includeBoundaries?`(?:(?<=\\s|^)(?=${ut})|(?<=${ut})(?=\\s|$))`:"",j="(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}",q="[a-fA-F\\d]{1,4}",ye=`
(
(?:${q}:){7}(?:${q}|:)|                                // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:${q}:){6}(?:${j}|:${q}|:)|                         // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:${q}:){5}(?::${j}|(:${q}){1,2}|:)|                 // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:${q}:){4}(?:(:${q}){0,1}:${j}|(:${q}){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:${q}:){3}(?:(:${q}){0,2}:${j}|(:${q}){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:${q}:){2}(?:(:${q}){0,3}:${j}|(:${q}){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:${q}:){1}(?:(:${q}){0,4}:${j}|(:${q}){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::((?::${q}){0,5}:${j}|(?::${q}){1,7}|:))           // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(%[0-9a-zA-Z]{1,})?                                           // %eth0            %1
`.replace(/\s*\/\/.*$/gm,"").replace(/\n/g,"").trim(),xr=new RegExp(`(?:^${j}$)|(?:^${ye}$)`),Mr=new RegExp(`^${j}$`),Nr=new RegExp(`^${ye}$`),je=e=>e&&e.exact?xr:new RegExp(`(?:${H(e)}${j}${H(e)})|(?:${H(e)}${ye}${H(e)})`,"g");je.v4=e=>e&&e.exact?Mr:new RegExp(`${H(e)}${j}${H(e)}`,"g"),je.v6=e=>e&&e.exact?Nr:new RegExp(`${H(e)}${ye}${H(e)}`,"g");var Ue=je;const ee=e=>Ue({exact:!0}).test(e);ee.v4=e=>Ue.v4({exact:!0}).test(e),ee.v6=e=>Ue.v6({exact:!0}).test(e),ee.version=e=>ee(e)?ee.v4(e)?4:6:void 0;var ge=ee;const Br=ge,$e=ge.v4,lt=ge.v6,ct=function(e,t,r){r=~~r;var n;if($e(e))n=t||new Uint8Array(r+4),e.split(/\./g).map(function(d){n[r++]=parseInt(d,10)&255});else if(lt(e)){var o=e.split(":",8),i;for(i=0;i<o.length;i++){var s=$e(o[i]),a;s&&(a=ct(o[i]),o[i]=M(a.slice(0,2),"base16")),a&&++i<8&&o.splice(i,0,M(a.slice(2,4),"base16"))}if(o[0]==="")for(;o.length<8;)o.unshift("0");else if(o[o.length-1]==="")for(;o.length<8;)o.push("0");else if(o.length<8){for(i=0;i<o.length&&o[i]!=="";i++);var l=[i,"1"];for(i=9-o.length;i>0;i--)l.push("0");o.splice.apply(o,l)}for(n=t||new Uint8Array(r+16),i=0;i<o.length;i++){var u=parseInt(o[i],16);n[r++]=u>>8&255,n[r++]=u&255}}if(!n)throw Error("Invalid ip address: "+e);return n},Lr=function(e,t,r){t=~~t,r=r||e.length-t;var n=[],o;const i=new DataView(e.buffer);if(r===4){for(let s=0;s<r;s++)n.push(e[t+s]);o=n.join(".")}else if(r===16){for(let s=0;s<r;s+=2)n.push(i.getUint16(t+s).toString(16));o=n.join(":"),o=o.replace(/(^|:)0(:0)*:0(:|$)/,"$1::$3"),o=o.replace(/:{3,4}/,"::")}return o};var ve={isIP:Br,isV4:$e,isV6:lt,toBytes:ct,toString:Lr};function N(e){if(typeof e=="number"){if(N.codes[e])return N.codes[e];throw new Error("no protocol with code: "+e)}else if(typeof e=="string"||e instanceof String){if(N.names[e])return N.names[e];throw new Error("no protocol with name: "+e)}throw new Error("invalid protocol id type: "+e)}const L=-1;N.lengthPrefixedVarSize=L,N.V=L,N.table=[[4,32,"ip4"],[6,16,"tcp"],[33,16,"dccp"],[41,128,"ip6"],[42,L,"ip6zone"],[53,L,"dns","resolvable"],[54,L,"dns4","resolvable"],[55,L,"dns6","resolvable"],[56,L,"dnsaddr","resolvable"],[132,16,"sctp"],[273,16,"udp"],[275,0,"p2p-webrtc-star"],[276,0,"p2p-webrtc-direct"],[277,0,"p2p-stardust"],[290,0,"p2p-circuit"],[301,0,"udt"],[302,0,"utp"],[400,L,"unix",!1,"path"],[421,L,"ipfs"],[421,L,"p2p"],[443,0,"https"],[444,96,"onion"],[445,296,"onion3"],[446,L,"garlic64"],[460,0,"quic"],[477,0,"ws"],[478,0,"wss"],[479,0,"p2p-websocket-star"],[480,0,"http"],[777,L,"memory"]],N.names={},N.codes={},N.table.map(e=>{const t=dt.apply(null,e);N.codes[t.code]=t,N.names[t.name]=t}),N.object=dt;function dt(e,t,r,n,o){return{code:e,size:t,name:r,resolvable:Boolean(n),path:Boolean(o)}}var K=N,ht=ue;function ue(e,t){return t instanceof Uint8Array?ue.toString(e,t):ue.toBytes(e,t)}ue.toString=function(t,r){t=K(t);switch(t.code){case 4:case 41:return jr(r);case 6:case 273:case 33:case 132:return ft(r);case 53:case 54:case 55:case 56:case 400:case 777:return $r(r);case 421:return zr(r);case 444:return mt(r);case 445:return mt(r);default:return M(r,"base16")}},ue.toBytes=function(t,r){t=K(t);switch(t.code){case 4:return pt(r);case 41:return pt(r);case 6:case 273:case 33:case 132:return Fe(parseInt(r,10));case 53:case 54:case 55:case 56:case 400:case 777:return Ur(r);case 421:return Fr(r);case 444:return Kr(r);case 445:return Qr(r);default:return ae(r,"base16")}};function pt(e){if(!ve.isIP(e))throw new Error("invalid ip address");return ve.toBytes(e)}function jr(e){const t=ve.toString(e);if(!t||!ve.isIP(t))throw new Error("invalid ip address");return t}function Fe(e){const t=new ArrayBuffer(2),r=new DataView(t);return r.setUint16(0,e),new Uint8Array(t)}function ft(e){const t=new DataView(e.buffer);return t.getUint16(0)}function Ur(e){const t=ae(e),r=Uint8Array.from(O.encode(t.length));return X([r,t],r.length+t.length)}function $r(e){const t=O.decode(e);if(e=e.slice(O.decode.bytes),e.length!==t)throw new Error("inconsistent lengths");return M(e)}function Fr(e){const t=new pe(e).multihash,r=Uint8Array.from(O.encode(t.length));return X([r,t],r.length+t.length)}function zr(e){const t=O.decode(e),r=e.slice(O.decode.bytes);if(r.length!==t)throw new Error("inconsistent lengths");return M(r,"base58btc")}function Kr(e){const t=e.split(":");if(t.length!==2)throw new Error("failed to parse onion addr: "+t+" does not contain a port number");if(t[0].length!==16)throw new Error("failed to parse onion addr: "+t[0]+" not a Tor onion address.");const r=it.decode("b"+t[0]),n=parseInt(t[1],10);if(n<1||n>65536)throw new Error("Port number is not in range(1, 65536)");const o=Fe(n);return X([r,o],r.length+o.length)}function Qr(e){const t=e.split(":");if(t.length!==2)throw new Error("failed to parse onion addr: "+t+" does not contain a port number");if(t[0].length!==56)throw new Error("failed to parse onion addr: "+t[0]+" not a Tor onion3 address.");const r=it.decode("b"+t[0]),n=parseInt(t[1],10);if(n<1||n>65536)throw new Error("Port number is not in range(1, 65536)");const o=Fe(n);return X([r,o],r.length+o.length)}function mt(e){const t=e.slice(0,e.length-2),r=e.slice(e.length-2),n=M(t,"base32"),o=ft(r);return n+":"+o}var U={stringToStringTuples:yt,stringTuplesToString:gt,tuplesToStringTuples:wt,stringTuplesToTuples:vt,bytesToTuples:ze,tuplesToBytes:bt,bytesToString:Vr,stringToBytes:Pt,fromString:Hr,fromBytes:It,validateBytes:Ke,isValidBytes:Gr,cleanPath:we,ParseError:Qe,protoFromTuple:le,sizeForAddr:_t};function yt(e){const t=[],r=e.split("/").slice(1);if(r.length===1&&r[0]==="")return[];for(let n=0;n<r.length;n++){const o=r[n],i=K(o);if(i.size===0){t.push([o]);continue}if(n++,n>=r.length)throw Qe("invalid address: "+e);if(i.path){t.push([o,we(r.slice(n).join("/"))]);break}t.push([o,r[n]])}return t}function gt(e){const t=[];return e.map(r=>{const n=le(r);t.push(n.name),r.length>1&&t.push(r[1])}),we(t.join("/"))}function vt(e){return e.map(t=>{Array.isArray(t)||(t=[t]);const r=le(t);return t.length>1?[r.code,ht.toBytes(r.code,t[1])]:[r.code]})}function wt(e){return e.map(t=>{const r=le(t);return t.length>1?[r.code,ht.toString(r.code,t[1])]:[r.code]})}function bt(e){return It(X(e.map(t=>{const r=le(t);let n=Uint8Array.from(O.encode(r.code));return t.length>1&&(n=X([n,t[1]])),n})))}function _t(e,t){if(e.size>0)return e.size/8;if(e.size===0)return 0;{const r=O.decode(t);return r+O.decode.bytes}}function ze(e){const t=[];let r=0;for(;r<e.length;){const n=O.decode(e,r),o=O.decode.bytes,i=K(n),s=_t(i,e.slice(r+o));if(s===0){t.push([n]),r+=o;continue}const a=e.slice(r+o,r+o+s);if(r+=s+o,r>e.length)throw Qe("Invalid address Uint8Array: "+M(e,"base16"));t.push([n,a])}return t}function Vr(e){const t=ze(e),r=wt(t);return gt(r)}function Pt(e){e=we(e);const t=yt(e),r=vt(t);return bt(r)}function Hr(e){return Pt(e)}function It(e){const t=Ke(e);if(t)throw t;return Uint8Array.from(e)}function Ke(e){try{ze(e)}catch(t){return t}}function Gr(e){return Ke(e)===void 0}function we(e){return"/"+e.trim().split("/").filter(t=>t).join("/")}function Qe(e){return new Error("Error parsing address: "+e)}function le(e){const t=K(e[0]);return t}var kt=R(function(e,t){const r=Symbol.for("nodejs.util.inspect.custom"),n=Ne.proto(function(o){if(!(this instanceof n))return new n(o);if(o==null&&(o=""),o instanceof Uint8Array)this.bytes=U.fromBytes(o);else if(typeof o=="string"||o instanceof String){if(o.length>0&&o.charAt(0)!=="/")throw new Error(`multiaddr "${o}" must start with a "/"`);this.bytes=U.fromString(o)}else if(o.bytes&&o.protos&&o.protoCodes)this.bytes=U.fromBytes(o.bytes);else throw new Error("addr must be a string, Buffer, or another Multiaddr")},{className:"Multiaddr",symbolName:"@multiformats/js-multiaddr/multiaddr"});n.prototype.toString=function(){return U.bytesToString(this.bytes)},n.prototype.toJSON=n.prototype.toString,n.prototype.toOptions=function(){const i={},s=this.toString().split("/");return i.family=s[1]==="ip4"?"ipv4":"ipv6",i.host=s[2],i.transport=s[3],i.port=parseInt(s[4]),i},n.prototype[r]=function(){return"<Multiaddr "+M(this.bytes,"base16")+" - "+U.bytesToString(this.bytes)+">"},n.prototype.inspect=function(){return"<Multiaddr "+M(this.bytes,"base16")+" - "+U.bytesToString(this.bytes)+">"},n.prototype.protos=function(){return this.protoCodes().map(i=>Object.assign({},K(i)))},n.prototype.protoCodes=function(){const i=[],s=this.bytes;let a=0;for(;a<s.length;){const l=O.decode(s,a),u=O.decode.bytes,d=K(l),c=U.sizeForAddr(d,s.slice(a+u));a+=c+u,i.push(l)}return i},n.prototype.protoNames=function(){return this.protos().map(i=>i.name)},n.prototype.tuples=function(){return U.bytesToTuples(this.bytes)},n.prototype.stringTuples=function(){const i=U.bytesToTuples(this.bytes);return U.tuplesToStringTuples(i)},n.prototype.encapsulate=function(i){return i=n(i),n(this.toString()+i.toString())},n.prototype.decapsulate=function(i){i=i.toString();const s=this.toString(),a=s.lastIndexOf(i);if(a<0)throw new Error("Address "+this+" does not contain subaddress: "+i);return n(s.slice(0,a))},n.prototype.decapsulateCode=function(i){const s=this.tuples();for(let a=s.length-1;a>=0;a--)if(s[a][0]===i)return n(U.tuplesToBytes(s.slice(0,a)));return this},n.prototype.getPeerId=function(){let i=null;try{const s=this.stringTuples().filter(a=>{if(a[0]===K.names.ipfs.code)return!0});i=s.pop()[1],i=M(new pe(i).multihash,"base58btc")}catch(s){i=null}return i},n.prototype.getPath=function(){let i=null;try{i=this.stringTuples().filter(s=>{const a=K(s[0]);if(a.path)return!0})[0][1]}catch(s){i=null}return i},n.prototype.equals=function(i){return oe(this.bytes,i.bytes)},n.prototype.nodeAddress=function(){const i=this.protoCodes(),s=this.protoNames(),a=this.toString().split("/").slice(1);if(a.length<4)throw new Error('multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6}/{address}/{tcp, udp}/{port}".');if(i[0]!==4&&i[0]!==41&&i[0]!==54&&i[0]!==55)throw new Error(`no protocol with name: "'${s[0]}'". Must have a valid family name: "{ip4, ip6, dns4, dns6}".`);if(a[2]!=="tcp"&&a[2]!=="udp")throw new Error(`no protocol with name: "'${s[1]}'". Must have a valid transport protocol: "{tcp, udp}".`);return{family:i[0]===41||i[0]===55?6:4,address:a[1],port:parseInt(a[3])}},n.fromNodeAddress=function(i,s){if(!i)throw new Error("requires node address object");if(!s)throw new Error("requires transport protocol");let a;switch(i.family){case"IPv4":a="ip4";break;case"IPv6":a="ip6";break;default:throw Error(`Invalid addr family. Got '${i.family}' instead of 'IPv4' or 'IPv6'`)}return n("/"+[a,i.address,s,i.port].join("/"))},n.prototype.isThinWaistAddress=function(i){const s=(i||this).protos();return s.length!==2||s[0].code!==4&&s[0].code!==41?!1:!(s[1].code!==6&&s[1].code!==273)},n.protocols=K,n.isName=function(i){return n.isMultiaddr(i)?i.protos().some(s=>s.resolvable):!1},n.resolve=function(i){return!n.isMultiaddr(i)||!n.isName(i)?Promise.reject(Error("not a valid name")):Promise.reject(new Error("not implemented yet"))},t=e.exports=n});const{Buffer:$}=F,Et=Symbol.for("BufferList");function A(e){if(!(this instanceof A))return new A(e);A._init.call(this,e)}A._init=function(t){Object.defineProperty(this,Et,{value:!0}),this._bufs=[],this.length=0,t&&this.append(t)},A.prototype._new=function(t){return new A(t)},A.prototype._offset=function(t){if(t===0)return[0,0];let r=0;for(let n=0;n<this._bufs.length;n++){const o=r+this._bufs[n].length;if(t<o||n===this._bufs.length-1)return[n,t-r];r=o}},A.prototype._reverseOffset=function(e){const t=e[0];let r=e[1];for(let n=0;n<t;n++)r+=this._bufs[n].length;return r},A.prototype.get=function(t){if(t>this.length||t<0)return;const r=this._offset(t);return this._bufs[r[0]][r[1]]},A.prototype.slice=function(t,r){return typeof t=="number"&&t<0&&(t+=this.length),typeof r=="number"&&r<0&&(r+=this.length),this.copy(null,0,t,r)},A.prototype.copy=function(t,r,n,o){if((typeof n!="number"||n<0)&&(n=0),(typeof o!="number"||o>this.length)&&(o=this.length),n>=this.length)return t||$.alloc(0);if(o<=0)return t||$.alloc(0);const i=!!t,s=this._offset(n),a=o-n;let l=a,u=i&&r||0,d=s[1];if(n===0&&o===this.length){if(!i)return this._bufs.length===1?this._bufs[0]:$.concat(this._bufs,this.length);for(let c=0;c<this._bufs.length;c++)this._bufs[c].copy(t,u),u+=this._bufs[c].length;return t}if(l<=this._bufs[s[0]].length-d)return i?this._bufs[s[0]].copy(t,r,d,d+l):this._bufs[s[0]].slice(d,d+l);i||(t=$.allocUnsafe(a));for(let c=s[0];c<this._bufs.length;c++){const f=this._bufs[c].length-d;if(l>f)this._bufs[c].copy(t,u,d),u+=f;else{this._bufs[c].copy(t,u,d,d+l),u+=f;break}l-=f,d&&(d=0)}return t.length>u?t.slice(0,u):t},A.prototype.shallowSlice=function(t,r){if(t=t||0,r=typeof r!="number"?this.length:r,t<0&&(t+=this.length),r<0&&(r+=this.length),t===r)return this._new();const n=this._offset(t),o=this._offset(r),i=this._bufs.slice(n[0],o[0]+1);return o[1]===0?i.pop():i[i.length-1]=i[i.length-1].slice(0,o[1]),n[1]!==0&&(i[0]=i[0].slice(n[1])),this._new(i)},A.prototype.toString=function(t,r,n){return this.slice(r,n).toString(t)},A.prototype.consume=function(t){if(t=Math.trunc(t),Number.isNaN(t)||t<=0)return this;for(;this._bufs.length;)if(t>=this._bufs[0].length)t-=this._bufs[0].length,this.length-=this._bufs[0].length,this._bufs.shift();else{this._bufs[0]=this._bufs[0].slice(t),this.length-=t;break}return this},A.prototype.duplicate=function(){const t=this._new();for(let r=0;r<this._bufs.length;r++)t.append(this._bufs[r]);return t},A.prototype.append=function(t){if(t==null)return this;if(t.buffer)this._appendBuffer($.from(t.buffer,t.byteOffset,t.byteLength));else if(Array.isArray(t))for(let r=0;r<t.length;r++)this.append(t[r]);else if(this._isBufferList(t))for(let r=0;r<t._bufs.length;r++)this.append(t._bufs[r]);else typeof t=="number"&&(t=t.toString()),this._appendBuffer($.from(t));return this},A.prototype._appendBuffer=function(t){this._bufs.push(t),this.length+=t.length},A.prototype.indexOf=function(e,t,r){if(r===void 0&&typeof t=="string"&&(r=t,t=void 0),typeof e=="function"||Array.isArray(e))throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.');if(typeof e=="number"?e=$.from([e]):typeof e=="string"?e=$.from(e,r):this._isBufferList(e)?e=e.slice():Array.isArray(e.buffer)?e=$.from(e.buffer,e.byteOffset,e.byteLength):$.isBuffer(e)||(e=$.from(e)),t=Number(t||0),isNaN(t)&&(t=0),t<0&&(t=this.length+t),t<0&&(t=0),e.length===0)return t>this.length?this.length:t;const n=this._offset(t);let o=n[0],i=n[1];for(;o<this._bufs.length;o++){const s=this._bufs[o];for(;i<s.length;){const a=s.length-i;if(a>=e.length){const l=s.indexOf(e,i);if(l!==-1)return this._reverseOffset([o,l]);i=s.length-e.length+1}else{const l=this._reverseOffset([o,i]);if(this._match(l,e))return l;i++}}i=0}return-1},A.prototype._match=function(e,t){if(this.length-e<t.length)return!1;for(let r=0;r<t.length;r++)if(this.get(e+r)!==t[r])return!1;return!0},function(){const e={readDoubleBE:8,readDoubleLE:8,readFloatBE:4,readFloatLE:4,readInt32BE:4,readInt32LE:4,readUInt32BE:4,readUInt32LE:4,readInt16BE:2,readInt16LE:2,readUInt16BE:2,readUInt16LE:2,readInt8:1,readUInt8:1,readIntBE:null,readIntLE:null,readUIntBE:null,readUIntLE:null};for(const t in e)(function(r){e[r]===null?A.prototype[r]=function(n,o){return this.slice(n,n+o)[r](0,o)}:A.prototype[r]=function(n){return this.slice(n,n+e[r])[r](0)}})(t)}(),A.prototype._isBufferList=function(t){return t instanceof A||A.isBufferList(t)},A.isBufferList=function(t){return t!=null&&t[Et]};var te=A;const{Buffer:Wr}=F,Tt=(e,t,r)=>{const n=O.encode(e,t,r);return Tt.bytes=O.encode.bytes,t||Wr.from(n)};var Ve=Tt;const{Buffer:At}=F,He=8,St=10*1024;function qt(e){e=e||{};const t=Math.max(e.poolSize||St,e.minPoolSize||He),r=e.lengthEncoder||Ve;return n=>async function*(){let o=At.alloc(t),i=0;for await(const s of n){r(s.length,o,i);const a=o.slice(i,i+r.bytes);i+=r.bytes,o.length-i<He&&(o=At.alloc(t),i=0),yield new te().append(a).append(s)}}()}qt.single=(e,t)=>{t=t||{};const r=t.lengthEncoder||Ve;return new te([r(e.length),e])};var Ge=qt,Yr=He,Xr=St;Ge.MIN_POOL_SIZE=Yr,Ge.DEFAULT_POOL_SIZE=Xr;const{Buffer:Jr}=F,Zr=e=>new Proxy({},{get:(t,r)=>r[0]==="l"?e[r]:e.get(parseInt(r))}),Rt=e=>{const t=O.decode(Jr.isBuffer(e)?e:Zr(e));return Rt.bytes=O.decode.bytes,t};var Ot=Rt;const{Buffer:en}=F,Dt=8,Ct=1024*1024*4,xt=en.alloc(0),G={LENGTH:"readLength",DATA:"readData"},tn={[G.LENGTH]:(e,t,r,n)=>{t=t.append(e);let o;try{o=n.lengthDecoder(t)}catch(i){if(t.length>n.maxLengthLength)throw Object.assign(i,{message:"message length too long",code:"ERR_MSG_LENGTH_TOO_LONG"});if(i instanceof RangeError)return{mode:G.LENGTH,buffer:t};throw i}if(o>n.maxDataLength)throw Object.assign(new Error("message data too long"),{code:"ERR_MSG_DATA_TOO_LONG"});return e=t.shallowSlice(n.lengthDecoder.bytes),t=new te,n.onLength&&n.onLength(o),o<=0?(n.onData&&n.onData(xt),{mode:G.LENGTH,chunk:e,buffer:t,data:xt}):{mode:G.DATA,chunk:e,buffer:t,state:{dataLength:o}}},[G.DATA]:(e,t,r,n)=>{if(t=t.append(e),t.length<r.dataLength)return{mode:G.DATA,buffer:t,state:r};const{dataLength:o}=r,i=t.shallowSlice(0,o);return e=t.length>o?t.shallowSlice(o):null,t=new te,n.onData&&n.onData(i),{mode:G.LENGTH,chunk:e,buffer:t,data:i}}};function We(e){return e=e||{},e.lengthDecoder=e.lengthDecoder||Ot,e.maxLengthLength=e.maxLengthLength||Dt,e.maxDataLength=e.maxDataLength||Ct,t=>async function*(){let r=new te,n=G.LENGTH,o;for await(let i of t)for(;i;){const s=tn[n](i,r,o,e);({mode:n,chunk:i,buffer:r,state:o}=s),s.data&&(yield s.data)}if(r.length)throw Object.assign(new Error("unexpected end of input"),{code:"ERR_UNEXPECTED_EOF"})}()}We.fromReader=(e,t)=>{t=t||{};let r=1;const n={[Symbol.asyncIterator](){return this},next:async()=>{try{return await e.next(r)}catch(o){if(o.code==="ERR_UNDER_READ")return{done:!0,value:null};throw o}finally{r=1}}};return t.onLength=o=>{r=o},We(t)(n)};var Ye=We,rn=Dt,nn=Ct;Ye.MAX_LENGTH_LENGTH=rn,Ye.MAX_DATA_LENGTH=nn;const{Buffer:on}=F,Mt=(e,t,r)=>(t=t||on.allocUnsafe(4),t.writeInt32BE(e,r),t);Mt.bytes=4;var sn=Mt;const Nt=e=>{if(e.length<4)throw RangeError("Could not decode int32BE");return e.readInt32BE(0)};Nt.bytes=4;var an=Nt,un=Ge,ln=Ye,cn=Ve,dn=Ot,hn=sn,pn=an,re={encode:un,decode:ln,varintEncode:cn,varintDecode:dn,int32BEEncode:hn,int32BEDecode:pn};const{AbortController:Bt,AbortSignal:fn}=typeof self!="undefined"?self:typeof window!="undefined"?window:void 0;var be=Bt,mn=fn,yn=Bt;be.AbortSignal=mn,be.default=yn;var Lt={createCipheriv:(e,t,r)=>{const n=fe.cipher.createCipher("AES-CTR",M(t,"ascii"));return n.start({iv:M(r,"ascii")}),{update:o=>(n.update(fe.util.createBuffer(M(o,"ascii"))),ae(n.output.getBytes(),"ascii"))}},createDecipheriv:(e,t,r)=>{const n=fe.cipher.createDecipher("AES-CTR",M(t,"ascii"));return n.start({iv:M(r,"ascii")}),{update:o=>(n.update(fe.util.createBuffer(M(o,"ascii"))),ae(n.output.getBytes(),"ascii"))}}};const jt={16:"aes-128-ctr",32:"aes-256-ctr"};var gn=function(e){const t=jt[e.length];if(!t){const r=Object.entries(jt).map(([n,o])=>`${n} (${o})`).join(" / ");throw T(new Error(`Invalid key length ${e.length} bytes. Must be ${r}`),"ERR_INVALID_KEY_LENGTH")}return t},vn=async function(e,t){const r=gn(e),n=Lt.createCipheriv(r,e,t),o=Lt.createDecipheriv(r,e,t),i={async encrypt(s){return n.update(s)},async decrypt(s){return o.update(s)}};return i},wn={create:vn};const Ut={sha1:"sha1","sha2-256":"sha256","sha2-512":"sha512"};function bn(e,t,r,n,o){const i=Ut[o];if(!i){const a=Object.keys(Ut).join(" / ");throw T(new Error(`Hash '${o}' is unknown or not supported. Must be ${a}`),"ERR_UNSUPPORTED_HASH_TYPE")}const s=_r(e,t,r,n,i);return Pr.encode64(s)}var _n=bn,Pn=wn,In=Ir,kn=kr,En=Er,Tn=_n,Xe={aes:Pn,hmac:In,keys:kn,randomBytes:En,pbkdf2:Tn};async function*An(e,t){let r=[];for await(const n of t)r.push(n),r.length===e&&(yield r,r=[]);r.length>0&&(yield r)}function*Sn(e,t){let r=[];for(const n of t)r.push(n),r.length===e&&(yield r,r=[]);r.length>0&&(yield r)}function $t(e,t){return t===void 0?r=>$t(e,r):t[Symbol.asyncIterator]?An(e,t):Sn(e,t)}function J(e){if(typeof e.next=="function")return e;if(typeof e[Symbol.iterator]=="function")return e[Symbol.iterator]();if(typeof e[Symbol.asyncIterator]=="function")return e[Symbol.asyncIterator]();throw new TypeError('"values" does not to conform to any of the iterator or iterable protocols')}function Je(){let e,t;const r=new Promise((n,o)=>{t=n,e=o});return{promise:r,reject:e,resolve:t}}function qn(e,t){const r=J(t),n=[],o=[];let i=!1,s=!1;function a(){for(;o.length>0&&n.length>0;){const c=o.shift(),{error:f,value:g}=n.shift();f?c.reject(f):c.resolve({done:!1,value:g})}for(;o.length>0&&s;){const{resolve:c}=o.shift();c({done:!0,value:void 0})}}async function l(){if(s)return;if(i)return;if(n.length>=e)return;i=!0;try{const{done:c,value:f}=await r.next();c?s=!0:n.push({value:f})}catch(c){s=!0,n.push({error:c})}a(),i=!1,l()}async function u(){if(n.length>0){const{error:f,value:g}=n.shift();if(f)throw f;return l(),{done:!1,value:g}}if(s)return{done:!0,value:void 0};const c=Je();return o.push(c),l(),c.promise}const d={next:u,[Symbol.asyncIterator]:()=>d};return d}function*Rn(e,t){const r=[];let n;try{for(const o of t){if(r.push(o),r.length<=e)continue;yield r.shift()}}catch(o){n=o}for(const o of r)yield o;if(n)throw n}function _e(e,t){return t===void 0?r=>_e(e,r):e===0?t:t[Symbol.asyncIterator]?qn(e,t):Rn(e,t)}async function On(e){const t=[];for await(const r of e)t.push(r);return t}function Dn(e){return e[Symbol.asyncIterator]?On(e):Array.from(e)}async function*Cn(e){for await(const t of e)yield*t}function*xn(e){for(const t of e)yield*t}function Mn(...e){const t=e.find(r=>r[Symbol.asyncIterator]!==void 0);return t?Cn(e):xn(e)}async function Nn(e){for await(const t of e);}function Bn(e){if(e[Symbol.asyncIterator])return Nn(e);for(const t of e);}async function*Ft(e,t){for await(const r of t)await e(r)&&(yield r)}function Pe(e,t){return t===void 0?r=>Ft(e,r):Ft(e,t)}async function*ce(e){for await(const t of e)t&&typeof t!="string"&&(t[Symbol.iterator]||t[Symbol.asyncIterator])?yield*ce(t):yield t}async function*zt(e,t){for await(const r of t)yield await e(r)}function Ie(e,t){return t===void 0?r=>zt(e,r):zt(e,t)}function Kt(e,t){return t===void 0?r=>Kt(e,r):Pe(r=>r!=null,ce(Ie(e,t)))}function Ln(e,t,r){const n=J(r),o=[],i=[];let s=!1,a=!1,l=0,u=null;function d(){for(;i.length>0&&o.length>0;){const{resolve:b}=i.shift(),p=o.shift();b({done:!1,value:p})}for(;i.length>0&&l===0&&s;){const{resolve:b,reject:p}=i.shift();u?(p(u),u=null):b({done:!0,value:void 0})}}async function c(){if(s){d();return}if(a)return;if(l+o.length>=e)return;a=!0,l++;try{const{done:b,value:p}=await n.next();b?(s=!0,l--,d()):f(p)}catch(b){s=!0,l--,u=b,d()}a=!1,c()}async function f(b){try{const p=await t(b);if(p&&p[Symbol.asyncIterator])for await(const h of p)o.push(h);else o.push(p)}catch(p){s=!0,u=p}l--,d(),c()}async function g(){if(o.length===0){const p=Je();return i.push(p),c(),p.promise}const b=o.shift();return c(),{done:!1,value:b}}const w={next:g,[Symbol.asyncIterator]:()=>w};return w}function ke(e,t,r){return t===void 0?(n,o)=>o?ke(e,n,o):ke(e,n):r===void 0?n=>ke(e,t,n):Pe(n=>n!=null,ce(Ln(e,t,r)))}async function jn(e){return new Promise(t=>{e.once("readable",()=>{t()})})}async function*Un(e){for(;;){const t=e.read();if(t!==null){yield t;continue}if(e._readableState.ended)break;await jn(e)}}function $n(e){return typeof e[Symbol.asyncIterator]=="function"?e:Un(e)}async function*Fn(...e){const t=new Set(e.map(J));for(;t.size>0;)for(const r of t){const n=await r.next();n.done?t.delete(r):yield n.value}}function Qt(e,...t){let r=e();for(const n of t)r=n(r);return r}async function*zn(e,t,r){let n=null;const o=l=>({value:t(l)}),i=async function*(l){for await(const u of l){if(n)return;yield u}},s=Qt(()=>r,_e(1),i,Ie(o),_e(e-1)),a=J(s);for(;;){const{value:l,done:u}=await a.next();if(u)break;try{const d=await l.value;n||(yield d)}catch(d){n=d}}if(n)throw n}function Ee(e,t,r){return t===void 0?(n,o)=>Ee(e,n,o):r===void 0?n=>Ee(e,t,n):e===1?Ie(t,r):zn(e,t,r)}function Te(e,t,r){return t===void 0?(n,o)=>o?Te(e,n,o):Te(e,n):r===void 0?n=>Te(e,t,n):Pe(n=>n!=null,ce(Ee(e,t,r)))}async function*Kn(...e){const t=e.map(J),r=new Set,n=new Map;let o=null,i=null,s=null;const a=c=>{o=c,i&&i(c)},l=c=>{s&&s(c)},u=()=>new Promise((c,f)=>{if(o&&f(o),n.size>0)return c();s=c,i=f}),d=c=>{const f=Promise.resolve(c.next()).then(async({done:g,value:w})=>{g||n.set(c,w),r.delete(f)});r.add(f),f.then(l,a)};for(const c of t)d(c);for(;;){if(r.size===0&&n.size===0)return;await u();for(const[c,f]of n)n.delete(c),yield f,d(c)}}async function Vt(e,t,r){let n=t;for await(const o of r)n=await e(n,o);return n}function Ze(e,t,r){return t===void 0?(n,o)=>o?Vt(e,n,o):Ze(e,n):r===void 0?n=>Ze(e,t,n):Vt(e,t,r)}async function*Qn(e,t){let r=0;for await(const n of t)if(yield await n,r++,r>=e)break}function*Vn(e,t){let r=0;for(const n of t)if(yield n,r++,r>=e)break}function Ht(e,t){return t===void 0?r=>Ht(e,r):t[Symbol.asyncIterator]?Qn(e,t):Vn(e,t)}async function*Gt(e,t){for await(const r of t)await e(r),yield r}function Hn(e,t){return t===void 0?r=>Gt(e,r):Gt(e,t)}function Wt(e,t){let r=e[0]+t[0],n=e[1]+t[1];if(n>=1e9){const o=n%1e9;r+=(n-o)/1e9,n=o}return[r,n]}async function*Gn(e,t){const r=t[Symbol.asyncIterator]();let n=[0,0];for(;;){const o=V.hrtime(),{value:i,done:s}=await r.next(),a=V.hrtime(o);if(n=Wt(n,a),e.progress&&e.progress(a,n),s)return e.total&&e.total(n),i;yield i}}function*Wn(e,t){const r=t[Symbol.iterator]();let n=[0,0];for(;;){const o=V.hrtime(),{value:i,done:s}=r.next(),a=V.hrtime(o);if(n=Wt(n,a),e.progress&&e.progress(a,n),s)return e.total&&e.total(n),i;yield i}}function Yt(e={},t){return t===void 0?r=>Yt(e,r):t[Symbol.asyncIterator]!==void 0?Gn(e,t):Wn(e,t)}function Yn(e,t,r){const n=J(r),o=[],i=[];let s=!1,a=!1,l=0,u=null;function d(){for(;i.length>0&&o.length>0;){const{resolve:b}=i.shift(),p=o.shift();b({done:!1,value:p})}for(;i.length>0&&l===0&&s;){const{resolve:b,reject:p}=i.shift();u?(p(u),u=null):b({done:!0,value:void 0})}}async function c(){if(s){d();return}if(a)return;if(l+o.length>=e)return;a=!0,l++;try{const{done:b,value:p}=await n.next();b?(s=!0,l--,d()):f(p)}catch(b){s=!0,l--,u=b,d()}a=!1,c()}async function f(b){try{const p=await t(b);o.push(p)}catch(p){s=!0,u=p}l--,d(),c()}async function g(){if(o.length===0){const p=Je();return i.push(p),c(),p.promise}const b=o.shift();return c(),{done:!1,value:b}}const w={next:g,[Symbol.asyncIterator]:()=>w};return w}function Ae(e,t,r){return t===void 0?(n,o)=>o?Ae(e,n,o):Ae(e,n):r===void 0?n=>Ae(e,t,n):Yn(e,t,r)}async function Xt(e,t){let r=null,n=null,o=null;const i=u=>{r=u,n&&n(u)},s=()=>{o&&o()},a=()=>{e.removeListener("error",i),e.removeListener("drain",s)};e.once("error",i);const l=()=>new Promise((u,d)=>{if(r)return d(r);e.once("drain",s),o=u,n=d});for await(const u of t)if(e.write(u)===!1&&await l(),r)break;if(a(),r)throw r}function Xn(e,t){return t===void 0?r=>Xt(e,r):Xt(e,t)}var Jn=Object.freeze({__proto__:null,batch:$t,buffer:_e,collect:Dn,concat:Mn,consume:Bn,filter:Pe,flatMap:Kt,flatTransform:ke,flatten:ce,fromStream:$n,getIterator:J,map:Ie,merge:Fn,parallelFlatMap:Te,parallelMap:Ee,parallelMerge:Kn,pipeline:Qt,reduce:Ze,take:Ht,tap:Hn,time:Yt,transform:Ae,writeToStream:Xn}),Jt=function(e){if(!e)throw Error("hashlru must have a max value, of type number, greater than 0");var t=0,r=Object.create(null),n=Object.create(null);function o(i,s){r[i]=s,t++,t>=e&&(t=0,n=r,r=Object.create(null))}return{has:function(i){return r[i]!==void 0||n[i]!==void 0},remove:function(i){r[i]!==void 0&&(r[i]=void 0),n[i]!==void 0&&(n[i]=void 0)},get:function(i){var s=r[i];if(s!==void 0)return s;if((s=n[i])!==void 0)return o(i,s),s},set:function(i,s){r[i]!==void 0?r[i]=s:o(i,s)},clear:function(){r=Object.create(null),n=Object.create(null)}}},Zt=Tr(Jn),Zn=(e,t)=>(t=t||(()=>{}),e.then(r=>new Promise(n=>{n(t())}).then(()=>r),r=>new Promise(n=>{n(t())}).then(()=>{throw r})));class er extends Error{constructor(e){super(e);this.name="TimeoutError"}}const tr=(e,t,r)=>new Promise((n,o)=>{if(typeof t!="number"||t<0)throw new TypeError("Expected `milliseconds` to be a positive number");if(t===Infinity){n(e);return}const i=setTimeout(()=>{if(typeof r=="function"){try{n(r())}catch(l){o(l)}return}const s=typeof r=="string"?r:`Promise timed out after ${t} milliseconds`,a=r instanceof Error?r:new er(s);typeof e.cancel=="function"&&e.cancel(),o(a)},t);Zn(e.then(n,o),()=>{clearTimeout(i)})});var Q=tr,ei=tr,ti=er;Q.default=ei,Q.TimeoutError=ti;var rr=R(function(e,t){/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */var r=F.Buffer;function n(i,s){for(var a in i)s[a]=i[a]}r.from&&r.alloc&&r.allocUnsafe&&r.allocUnsafeSlow?e.exports=F:(n(F,t),t.Buffer=o);function o(i,s,a){return r(i,s,a)}o.prototype=Object.create(r.prototype),n(r,o),o.from=function(i,s,a){if(typeof i=="number")throw new TypeError("Argument must not be a number");return r(i,s,a)},o.alloc=function(i,s,a){if(typeof i!="number")throw new TypeError("Argument must be a number");var l=r(i);return s!==void 0?typeof a=="string"?l.fill(s,a):l.fill(s):l.fill(0),l},o.allocUnsafe=function(i){if(typeof i!="number")throw new TypeError("Argument must be a number");return r(i)},o.allocUnsafeSlow=function(i){if(typeof i!="number")throw new TypeError("Argument must be a number");return F.SlowBuffer(i)}}),nr=R(function(e){var t=65536,r=4294967295;function n(){throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`)}var o=rr.Buffer,i=Me.crypto||Me.msCrypto;i&&i.getRandomValues?e.exports=s:e.exports=n;function s(a,l){if(a>r)throw new RangeError("requested too many random bytes");var u=o.allocUnsafe(a);if(a>0)if(a>t)for(var d=0;d<a;d+=t)i.getRandomValues(u.slice(d,d+t));else i.getRandomValues(u);return typeof l=="function"?V.nextTick(function(){l(null,u)}):u}});const{EventEmitter:ri}=Ce;function ir(e,t){if(e===t)return!0;if(e.length!==t.length)return!1;for(let r=0,n=e.length;r<n;++r)if(e[r]!==t[r])return!1;return!0}function et(){return{contacts:[],dontSplit:!1,left:null,right:null}}function de(e,t){if(!(t instanceof Uint8Array))throw new TypeError(e+" is not a Uint8Array")}class tt extends ri{constructor(e={}){super();this.localNodeId=e.localNodeId||nr(20),this.numberOfNodesPerKBucket=e.numberOfNodesPerKBucket||20,this.numberOfNodesToPing=e.numberOfNodesToPing||3,this.distance=e.distance||tt.distance,this.arbiter=e.arbiter||tt.arbiter,this.metadata=Object.assign({},e.metadata),de("option.localNodeId as parameter 1",this.localNodeId),this.root=et()}static arbiter(e,t){return e.vectorClock>t.vectorClock?e:t}static distance(e,t){let r=0,n=0;const o=Math.min(e.length,t.length),i=Math.max(e.length,t.length);for(;n<o;++n)r=r*256+(e[n]^t[n]);for(;n<i;++n)r=r*256+255;return r}add(e){de("contact.id",(e||{}).id);let t=0,r=this.root;for(;r.contacts===null;)r=this._determineNode(r,e.id,t++);const n=this._indexOf(r,e.id);return n>=0?(this._update(r,n,e),this):r.contacts.length<this.numberOfNodesPerKBucket?(r.contacts.push(e),this.emit("added",e),this):r.dontSplit?(this.emit("ping",r.contacts.slice(0,this.numberOfNodesToPing),e),this):(this._split(r,t),this.add(e))}closest(e,t=Infinity){if(de("id",e),!Number.isInteger(t)&&t!==Infinity||t<=0)throw new TypeError("n is not positive number");let r=[];for(let n=[this.root],o=0;n.length>0&&r.length<t;){const i=n.pop();if(i.contacts===null){const s=this._determineNode(i,e,o++);n.push(i.left===s?i.right:i.left),n.push(s)}else r=r.concat(i.contacts)}return r.map(n=>[this.distance(n.id,e),n]).sort((n,o)=>n[0]-o[0]).slice(0,t).map(n=>n[1])}count(){let e=0;for(const t=[this.root];t.length>0;){const r=t.pop();r.contacts===null?t.push(r.right,r.left):e+=r.contacts.length}return e}_determineNode(e,t,r){const n=r>>3,o=r%8;if(t.length<=n&&o!==0)return e.left;const i=t[n];return i&1<<7-o?e.right:e.left}get(e){de("id",e);let t=0,r=this.root;for(;r.contacts===null;)r=this._determineNode(r,e,t++);const n=this._indexOf(r,e);return n>=0?r.contacts[n]:null}_indexOf(e,t){for(let r=0;r<e.contacts.length;++r)if(ir(e.contacts[r].id,t))return r;return-1}remove(e){de("the id as parameter 1",e);let t=0,r=this.root;for(;r.contacts===null;)r=this._determineNode(r,e,t++);const n=this._indexOf(r,e);if(n>=0){const o=r.contacts.splice(n,1)[0];this.emit("removed",o)}return this}_split(e,t){e.left=et(),e.right=et();for(const o of e.contacts)this._determineNode(e,o.id,t).contacts.push(o);e.contacts=null;const r=this._determineNode(e,this.localNodeId,t),n=e.left===r?e.right:e.left;n.dontSplit=!0}toArray(){let e=[];for(const t=[this.root];t.length>0;){const r=t.pop();r.contacts===null?t.push(r.right,r.left):e=e.concat(r.contacts)}return e}_update(e,t,r){if(!ir(e.contacts[t].id,r.id))throw new Error("wrong index for _update");const n=e.contacts[t],o=this.arbiter(n,r);if(o===n&&n!==r)return;e.contacts.splice(t,1),e.contacts.push(o),this.emit("updated",n,o)}}var ni=tt,Z=W;function W(e,t){if(e.length!==t.length)throw new Error("Inputs should have the same length");for(var r=Buffer.allocUnsafe(e.length),n=0;n<e.length;n++)r[n]=e[n]^t[n];return r}W.compare=function(t,r){if(t.length!==r.length)throw new Error("Inputs should have the same length");for(var n=0;n<t.length;n++){if(t[n]===r[n])continue;return t[n]<r[n]?-1:1}return 0},W.gt=function(t,r){return W.compare(t,r)===1},W.lt=function(t,r){return W.compare(t,r)===-1},W.eq=function(t,r){return W.compare(t,r)===0};var or=async(e,t,{concurrency:r=Infinity,stopOnError:n=!0}={})=>new Promise((o,i)=>{if(typeof t!="function")throw new TypeError("Mapper function is required");if(!((Number.isSafeInteger(r)||r===Infinity)&&r>=1))throw new TypeError(`Expected \`concurrency\` to be an integer from 1 and up or \`Infinity\`, got \`${r}\` (${typeof r})`);const s=[],a=[],l=e[Symbol.iterator]();let u=!1,d=!1,c=0,f=0;const g=()=>{if(u)return;const w=l.next(),b=f;if(f++,w.done){d=!0,c===0&&(!n&&a.length!==0?i(new Le(a)):o(s));return}c++,(async()=>{try{const p=await w.value;s[b]=await t(p,b),c--,g()}catch(p){n?(u=!0,i(p)):(a.push(p),c--,g())}})()};for(let w=0;w<r&&!(g(),d);w++);}),P=R(function(e,t){const r=se.multihash,{Key:n}=Be,{Record:o}=z;t.convertBuffer=i=>se.digest(i,"sha2-256"),t.convertPeerId=i=>se.digest(i.id,"sha2-256"),t.bufferToKey=i=>new n("/"+t.encodeBase32(i),!1),t.keyForPublicKey=i=>X([ae("/pk/"),i.id]),t.isPublicKeyKey=i=>M(i.slice(0,4))==="/pk/",t.fromPublicKeyKey=i=>new Y(i.slice(4)),t.now=()=>Date.now(),t.encodeBase32=i=>{const s=new ot.Encoder;return s.write(i).finalize()},t.decodeBase32=i=>{const s=new ot.Decoder;return Uint8Array.from(s.write(i).finalize())},t.sortClosestPeers=async(i,s)=>{const a=await or(i,async l=>{const u=await t.convertPeerId(l);return{peer:l,distance:Z(u,s)}});return a.sort(t.xorCompare).map(l=>l.peer)},t.xorCompare=(i,s)=>Z.compare(i.distance,s.distance),t.pathSize=(i,s)=>Math.ceil(i/s),t.createPutRecord=(i,s)=>{const a=new Date,l=new o(i,s,a);return l.serialize()},t.logger=(i,s)=>{const a=["libp2p","dht"];s&&a.push(s),i&&a.push(`${i.toB58String().slice(0,8)}`),me.formatters.b=u=>r.toB58String(u);const l=me(a.join(":"));return l.error=me(a.concat(["error"]).join(":")),l},t.TimeoutError=class extends Error{get code(){return"ETIMEDOUT"}},t.withTimeout=(i,s)=>async(...a)=>Promise.race([i(...a),new Promise((l,u)=>{setTimeout(()=>{u(T(new Error("Async function did not complete before timeout"),"ETIMEDOUT"))},s)})]),t.mapParallel=async function(i,s){const a=[];for await(const l of i)a.push(s(l));return Promise.all(a)}});class ii{constructor(e,t){this.self=e,this._onPing=this._onPing.bind(this),this._onInit(t)}async _onInit(e){const t=await P.convertPeerId(this.self);this.kb=new ni({localNodeId:t,numberOfNodesPerKBucket:e,numberOfNodesToPing:1}),this.kb.on("ping",this._onPing)}_onPing(e,t){const r=e[0];this.kb.remove(r.id),this.kb.add(t)}get size(){return this.kb.count()}async find(e){const t=await P.convertPeerId(e),r=this.closestPeer(t);if(r&&r.isEqual(e))return r}closestPeer(e){const t=this.closestPeers(e,1);if(t.length>0)return t[0]}closestPeers(e,t){return this.kb.closest(e,t).map(r=>r.peer)}async add(e){const t=await P.convertPeerId(e);this.kb.add({id:t,peer:e})}async remove(e){const t=await P.convertPeerId(e);this.kb.remove(t)}}var oi=ii,x=R(function(e,t){const r=t.second=1e3,n=t.minute=60*r,o=t.hour=60*n;t.MAX_RECORD_AGE=36*o,t.PROTOCOL_DHT="/kad/1.0.0",t.PROVIDERS_KEY_PREFIX="/providers/",t.PROVIDERS_LRU_CACHE_SIZE=256,t.PROVIDERS_VALIDITY=24*o,t.PROVIDERS_CLEANUP_INTERVAL=o,t.READ_MESSAGE_TIMEOUT=10*r,t.GET_MANY_RECORD_COUNT=16,t.K=20,t.ALPHA=3,t.defaultRandomWalk={enabled:!0,queriesPerPeriod:1,interval:5*n,timeout:10*r,delay:10*r}});const sr=()=>{};class si{constructor({min:e=0,max:t=Infinity,handlers:r={}}){this.min=e,this.max=t,this._onConnect=r.onConnect||sr,this._onDisconnect=r.onDisconnect||sr,this.peers=new Set}set registrar(e){this._registrar=e}disconnect(e){this._onDisconnect(e)}}var ai=Ne(si,{className:"Topology",symbolName:"@libp2p/js-interfaces/topology"});class ui extends ai{constructor({min:e,max:t,multicodecs:r,handlers:n}){super({min:e,max:t,handlers:n});if(!r)throw new Error("one or more multicodec should be provided");if(!n)throw new Error("the handlers should be provided");if(typeof n.onConnect!="function")throw new Error("the 'onConnect' handler must be provided");if(typeof n.onDisconnect!="function")throw new Error("the 'onDisconnect' handler must be provided");this.multicodecs=Array.isArray(r)?r:[r],this._registrar=void 0,this._onProtocolChange=this._onProtocolChange.bind(this),this._onPeerConnect=this._onPeerConnect.bind(this)}set registrar(e){this._registrar=e,this._registrar.peerStore.on("change:protocols",this._onProtocolChange),this._registrar.connectionManager.on("peer:connect",this._onPeerConnect),this._updatePeers(this._registrar.peerStore.peers.values())}_updatePeers(e){for(const{id:t,protocols:r}of e)if(this.multicodecs.filter(n=>r.includes(n)).length){this.peers.add(t.toB58String());const n=this._registrar.getConnection(t);n&&this._onConnect(t,n)}else this.peers.delete(t.toB58String())}_onProtocolChange({peerId:e,protocols:t}){const r=this.peers.has(e.toB58String()),n=t.filter(o=>this.multicodecs.includes(o));r&&n.length===0&&this._onDisconnect(e);for(const o of t)if(this.multicodecs.includes(o)){const i=this._registrar.peerStore.get(e);this._updatePeers([i]);return}}_onPeerConnect(e){const t=e.remotePeer,r=this._registrar.peerStore.protoBook.get(t);if(!r)return;this.multicodecs.find(n=>r.includes(n))&&(this.peers.add(t.toB58String()),this._onConnect(t,e))}}var li=Ne(ui,{className:"MulticodecTopology",symbolName:"@libp2p/js-interfaces/topology/multicodec-topology"}),ci=`// can't use, because protocol-buffers doesn't support imports
// so we have to duplicate for now :(
// import "record.proto";

message Record {
  // adjusted for javascript
  optional bytes key = 1;
  optional bytes value = 2;
  optional bytes author = 3;
  optional bytes signature = 4;
  optional string timeReceived = 5;
}

message Message {
  enum MessageType {
    PUT_VALUE = 0;
    GET_VALUE = 1;
    ADD_PROVIDER = 2;
    GET_PROVIDERS = 3;
    FIND_NODE = 4;
    PING = 5;
  }

  enum ConnectionType {
    // sender does not have a connection to peer, and no extra information (default)
    NOT_CONNECTED = 0;

    // sender has a live connection to peer
    CONNECTED = 1;

    // sender recently connected to peer
    CAN_CONNECT = 2;

    // sender recently tried to connect to peer repeatedly but failed to connect
    // ("try" here is loose, but this should signal "made strong effort, failed")
    CANNOT_CONNECT = 3;
  }

  message Peer {
    // ID of a given peer.
    optional bytes id = 1;

    // multiaddrs for a given peer
    repeated bytes addrs = 2;

    // used to signal the sender's connection capabilities to the peer
    optional ConnectionType connection = 3;
  }

  // defines what type of message it is.
  optional MessageType type = 1;

  // defines what coral cluster level this query/response belongs to.
  // in case we want to implement coral's cluster rings in the future.
  optional int32 clusterLevelRaw = 10;

  // Used to specify the key associated with this message.
  // PUT_VALUE, GET_VALUE, ADD_PROVIDER, GET_PROVIDERS
  // adjusted for javascript
  optional bytes key = 2;

  // Used to return a value
  // PUT_VALUE, GET_VALUE
  // adjusted Record to bytes for js
  optional bytes record = 3;

  // Used to return peers closer to a key in a query
  // GET_VALUE, GET_PROVIDERS, FIND_NODE
  repeated Peer closerPeers = 8;

  // Used to return Providers
  // GET_VALUE, ADD_PROVIDER, GET_PROVIDERS
  repeated Peer providerPeers = 9;
}`;const{Record:di}=z,Se=Ar(ci),hi=Se.Message.MessageType,ar=Se.Message.ConnectionType;class qe{constructor(e,t,r){if(t&&!(t instanceof Uint8Array))throw new Error("Key must be a Uint8Array");this.type=e,this.key=t,this._clusterLevelRaw=r,this.closerPeers=[],this.providerPeers=[],this.record=null}get clusterLevel(){const e=this._clusterLevelRaw-1;return e<0?0:e}set clusterLevel(e){this._clusterLevelRaw=e}serialize(){const e={key:this.key,type:this.type,clusterLevelRaw:this._clusterLevelRaw,closerPeers:this.closerPeers.map(ur),providerPeers:this.providerPeers.map(ur)};return this.record&&(this.record instanceof Uint8Array?e.record=this.record:e.record=this.record.serialize()),Se.Message.encode(e)}static deserialize(e){const t=Se.Message.decode(e),r=new qe(t.type,t.key,t.clusterLevelRaw);return r.closerPeers=t.closerPeers.map(lr),r.providerPeers=t.providerPeers.map(lr),t.record&&(r.record=di.deserialize(t.record)),r}}qe.TYPES=hi,qe.CONNECTION_TYPES=ar;function ur(e){return{id:e.id.id,addrs:(e.multiaddrs||[]).map(t=>t.bytes),connection:ar.CONNECTED}}function lr(e){return{id:new Y(e.id),multiaddrs:e.addrs.map(t=>kt(t))}}var D=qe;const{Record:pi}=z;var fi=e=>{const t=P.logger(e.peerId,"rpc:get-value");return async function(n,o){const i=o.key;if(t("key: %b",i),!i||i.length===0)throw T(new Error("Invalid key"),"ERR_INVALID_KEY");const s=new D(D.TYPES.GET_VALUE,i,o.clusterLevel);if(P.isPublicKeyKey(i)){t("is public key");const u=P.fromPublicKeyKey(i);let d;if(e._isSelf(u))d=e.peerId;else{const c=e.peerStore.get(u);d=c&&c.id}if(d&&d.pubKey)return t("returning found public key"),s.record=new pi(i,d.pubKey.bytes),s}const[a,l]=await Promise.all([e._checkLocalDatastore(i),e._betterPeersToQuery(o,n)]);return a&&(t("got record"),s.record=a),l.length>0&&(t("got closer %s",l.length),s.closerPeers=l),s}},mi=e=>{const t=P.logger(e.peerId,"rpc:put-value");return async function(n,o){const i=o.key;t("key: %b",i);const s=o.record;if(!s){const l=`Empty record from: ${n.toB58String()}`;throw t.error(l),T(new Error(l),"ERR_EMPTY_RECORD")}await e._verifyRecordLocally(s),s.timeReceived=new Date;const a=P.bufferToKey(s.key);return await e.datastore.put(a,s.serialize()),e.onPut(s,n),o}},yi=e=>{const t=P.logger(e.peerId,"rpc:find-node");return async function(n,o){t("start");let i;oe(o.key,e.peerId.id)?i=[{id:e.peerId}]:i=await e._betterPeersToQuery(o,n);const s=new D(o.type,new Uint8Array(0),o.clusterLevel);return i.length>0?s.closerPeers=i:t("handle FindNode %s: could not find anything",n.toB58String()),s}},gi=e=>{const t=P.logger(e.peerId,"rpc:add-provider");return async function(n,o){if(t("start"),!o.key||o.key.length===0)throw T(new Error("Missing key"),"ERR_MISSING_KEY");let i;try{i=new pe(o.key)}catch(s){const a=`Invalid CID: ${s.message}`;throw T(new Error(a),"ERR_INVALID_CID")}return o.providerPeers.forEach(s=>{if(!s.id.isEqual(n)){t("invalid provider peer %s from %s",s.id.toB58String(),n.toB58String());return}if(s.multiaddrs.length<1){t("no valid addresses for provider %s. Ignore",n.toB58String());return}if(t("received provider %s for %s (addrs %s)",n.toB58String(),i.toBaseEncodedString(),s.multiaddrs.map(a=>a.toString())),!e._isSelf(s.id))return e.peerStore.addressBook.add(s.id,s.multiaddrs),e.providers.addProvider(i,s.id)}),e.providers.addProvider(i,n)}},vi=e=>{const t=P.logger(e.peerId,"rpc:get-providers");return async function(n,o){let i;try{i=new pe(o.key)}catch(g){throw T(new Error(`Invalid CID: ${g.message}`),"ERR_INVALID_CID")}t("%s",i.toBaseEncodedString());const s=P.bufferToKey(i.bytes),[a,l,u]=await Promise.all([e.datastore.has(s),e.providers.getProviders(i),e._betterPeersToQuery(o,n)]),d=l.map(g=>({id:g})),c=u.map(g=>({id:g.id}));a&&d.push({id:e.peerId});const f=new D(o.type,o.key,o.clusterLevel);return d.length>0&&(f.providerPeers=d),c.length>0&&(f.closerPeers=c),t("got %s providers %s closerPeers",d.length,c.length),f}},wi=e=>{const t=P.logger(e.peerId,"rpc:ping");return function(n,o){return t("from %s",n.toB58String()),o}};const ne=D.TYPES;var bi=e=>{const t={[ne.GET_VALUE]:fi(e),[ne.PUT_VALUE]:mi(e),[ne.FIND_NODE]:yi(e),[ne.ADD_PROVIDER]:gi(e),[ne.GET_PROVIDERS]:vi(e),[ne.PING]:wi(e)};return function(n){return t[n]}},_i=e=>{const t=P.logger(e.peerId,"rpc"),r=bi(e);async function n(o,i){const s=r(i.type);try{await e._add(o)}catch(a){t.error("Failed to update the kbucket store",a)}if(!s){t.error(`no handler found for message type: ${i.type}`);return}return s(o,i)}return async function({stream:i,connection:s}){const a=s.remotePeer;try{await e._add(a)}catch(u){t.error(u)}const l=a.toB58String();t("from: %s",l),await xe(i.source,re.decode(),u=>async function*(){for await(const d of u){const c=D.deserialize(d.slice()),f=await n(a,c);f&&(yield f.serialize())}}(),re.encode(),i.sink)}};const{consume:Pi}=Zt;class Ii{constructor(e){this.dht=e,this.readMessageTimeout=x.READ_MESSAGE_TIMEOUT,this._log=P.logger(this.dht.peerId,"net"),this._rpc=_i(this.dht),this._onPeerConnected=this._onPeerConnected.bind(this),this._running=!1}async start(){if(this._running)return;if(!this.dht.isStarted)throw T(new Error("Can not start network"),"ERR_CANNOT_START_NETWORK");this._running=!0,this.dht._clientMode===!1&&this.dht.registrar.handle(this.dht.protocol,this._rpc);const e=new li({multicodecs:[this.dht.protocol],handlers:{onConnect:this._onPeerConnected,onDisconnect:()=>{}}});this._registrarId=await this.dht.registrar.register(e)}async stop(){if(!this.dht.isStarted&&!this.isStarted)return;this._running=!1,await this.dht.registrar.unregister(this._registrarId)}get isStarted(){return this._running}get isConnected(){return this.dht.isStarted&&this.isStarted}async _onPeerConnected(e){await this.dht._add(e),this._log("added to the routing table: %s",e.toB58String())}async sendRequest(e,t){if(!this.isConnected)throw T(new Error("Network is offline"),"ERR_NETWORK_OFFLINE");const r=e.toB58String();this._log("sending to: %s",r);let n=this.dht.registrar.connectionManager.get(e);n||(n=await this.dht.dialer.connectToPeer(e));const{stream:o}=await n.newStream(this.dht.protocol);return this._writeReadMessage(o,t.serialize())}async sendMessage(e,t){if(!this.isConnected)throw T(new Error("Network is offline"),"ERR_NETWORK_OFFLINE");const r=e.toB58String();this._log("sending to: %s",r);let n=this.dht.registrar.connectionManager.get(e);n||(n=await this.dht.dialer.connectToPeer(e));const{stream:o}=await n.newStream(this.dht.protocol);return this._writeMessage(o,t.serialize())}async _writeReadMessage(e,t){return Q(ki(e,t),this.readMessageTimeout)}_writeMessage(e,t){return xe([t],re.encode(),e,Pi)}}async function ki(e,t){const r=await xe([t],re.encode(),e,re.decode(),async n=>{for await(const o of n)return o.slice()});if(r.length===0)throw T(new Error("No message received"),"ERR_NO_MESSAGE_RECEIVED");return D.deserialize(r)}var Ei=Ii;class Ti{constructor(e,t){this.originDhtKey=e,this.capacity=t,this.peerDistances=[]}get length(){return this.peerDistances.length}get peers(){return this.peerDistances.map(e=>e.peerId)}async add(e){if(this.peerDistances.find(n=>oe(n.peerId.id,e.id)))return;const t=await P.convertPeerId(e),r={peerId:e,distance:Z(this.originDhtKey,t)};this.peerDistances.push(r),this.peerDistances.sort((n,o)=>Z.compare(n.distance,o.distance)),this.peerDistances=this.peerDistances.slice(0,this.capacity)}async anyCloser(e){if(!e.length)return!1;if(!this.length)return!0;const t=await or(e,n=>P.convertPeerId(n)),r=this.peerDistances[this.peerDistances.length-1].distance;for(const n of t){const o=Z(this.originDhtKey,n);if(Z.compare(o,r)<0)return!0}return!1}}var Ai=Ti,Si=R(function(e,t){(function(){var r,n,o,i,s,a,l,u,d,c,f,g,w,b,p;o=Math.floor,c=Math.min,n=function(h,y){return h<y?-1:h>y?1:0},d=function(h,y,m,_,v){var I;if(m==null&&(m=0),v==null&&(v=n),m<0)throw new Error("lo must be non-negative");for(_==null&&(_=h.length);m<_;)I=o((m+_)/2),v(y,h[I])<0?_=I:m=I+1;return[].splice.apply(h,[m,m-m].concat(y)),y},a=function(h,y,m){return m==null&&(m=n),h.push(y),b(h,0,h.length-1,m)},s=function(h,y){var m,_;return y==null&&(y=n),m=h.pop(),h.length?(_=h[0],h[0]=m,p(h,0,y)):_=m,_},u=function(h,y,m){var _;return m==null&&(m=n),_=h[0],h[0]=y,p(h,0,m),_},l=function(h,y,m){var _;return m==null&&(m=n),h.length&&m(h[0],y)<0&&(_=[h[0],y],y=_[0],h[0]=_[1],p(h,0,m)),y},i=function(h,y){var m,_,v,I,k,E;for(y==null&&(y=n),I=function(){E=[];for(var S=0,C=o(h.length/2);0<=C?S<C:S>C;0<=C?S++:S--)E.push(S);return E}.apply(this).reverse(),k=[],_=0,v=I.length;_<v;_++)m=I[_],k.push(p(h,m,y));return k},w=function(h,y,m){var _;return m==null&&(m=n),_=h.indexOf(y),_===-1?void 0:(b(h,0,_,m),p(h,_,m))},f=function(h,y,m){var _,v,I,k,E;if(m==null&&(m=n),v=h.slice(0,y),!v.length)return v;for(i(v,m),E=h.slice(y),I=0,k=E.length;I<k;I++)_=E[I],l(v,_,m);return v.sort(m).reverse()},g=function(h,y,m){var _,v,I,k,E,S,C,B,ie,De;if(m==null&&(m=n),y*10<=h.length){if(k=h.slice(0,y).sort(m),!k.length)return k;for(I=k[k.length-1],B=h.slice(y),E=0,C=B.length;E<C;E++)_=B[E],m(_,I)<0&&(d(k,_,0,null,m),k.pop(),I=k[k.length-1]);return k}for(i(h,m),De=[],v=S=0,ie=c(y,h.length);0<=ie?S<ie:S>ie;v=0<=ie?++S:--S)De.push(s(h,m));return De},b=function(h,y,m,_){var v,I,k;for(_==null&&(_=n),v=h[m];m>y;){if(k=m-1>>1,I=h[k],_(v,I)<0){h[m]=I,m=k;continue}break}return h[m]=v},p=function(h,y,m){var _,v,I,k,E;for(m==null&&(m=n),v=h.length,E=y,I=h[y],_=2*y+1;_<v;)k=_+1,k<v&&!(m(h[_],h[k])<0)&&(_=k),h[y]=h[_],y=_,_=2*y+1;return h[y]=I,b(h,E,y,m)},r=function(){h.push=a,h.pop=s,h.replace=u,h.pushpop=l,h.heapify=i,h.updateItem=w,h.nlargest=f,h.nsmallest=g;function h(y){this.cmp=y??n,this.nodes=[]}return h.prototype.push=function(y){return a(this.nodes,y,this.cmp)},h.prototype.pop=function(){return s(this.nodes,this.cmp)},h.prototype.peek=function(){return this.nodes[0]},h.prototype.contains=function(y){return this.nodes.indexOf(y)!==-1},h.prototype.replace=function(y){return u(this.nodes,y,this.cmp)},h.prototype.pushpop=function(y){return l(this.nodes,y,this.cmp)},h.prototype.heapify=function(){return i(this.nodes,this.cmp)},h.prototype.updateItem=function(y){return w(this.nodes,y,this.cmp)},h.prototype.clear=function(){return this.nodes=[]},h.prototype.empty=function(){return this.nodes.length===0},h.prototype.size=function(){return this.nodes.length},h.prototype.clone=function(){var y;return y=new h,y.nodes=this.nodes.slice(0),y},h.prototype.toArray=function(){return this.nodes.slice(0)},h.prototype.insert=h.prototype.push,h.prototype.top=h.prototype.peek,h.prototype.front=h.prototype.peek,h.prototype.has=h.prototype.contains,h.prototype.copy=h.prototype.clone,h}(),function(h,y){return e.exports=y()}(this,function(){return r})}).call(Me)}),qi=Si;const rt=me("libp2p:dht:peer-queue");class nt{static async fromPeerId(e){const t=await P.convertPeerId(e);return new nt(t)}static async fromKey(e){const t=await P.convertBuffer(e);return new nt(t)}constructor(e){rt("create: %b",e),this.from=e,this.heap=new qi(P.xorCompare)}async enqueue(e){rt("enqueue %s",e.toB58String());const t=await P.convertPeerId(e),r={id:e,distance:Z(this.from,t)};this.heap.push(r)}dequeue(){const e=this.heap.pop();return rt("dequeue %s",e.id.toB58String()),e.id}get length(){return this.heap.size()}}var Ri=nt;const Oi=3e4;class Di{constructor(e,t){if(this.run=e,this.queryFunc=P.withTimeout(t,Oi),!this.queryFunc)throw new Error("Path requires a `queryFn` to be specified");if(typeof this.queryFunc!="function")throw new Error("Path expected `queryFn` to be a function. Got "+typeof this.queryFunc);this.initialPeers=[],this.peersToQuery=null}addInitialPeer(e){this.initialPeers.push(e)}async execute(){const e=await Ri.fromKey(this.run.query.key);this.peersToQuery=e,await Promise.all(this.initialPeers.map(t=>this.addPeerToQuery(t))),await this.run.workerQueue(this)}async addPeerToQuery(e){if(this.run.query.dht._isSelf(e))return;if(this.run.peersSeen.has(e.toB58String()))return;await this.peersToQuery.enqueue(e)}}var Ci=Di;function xi(e,t,r,n){for(var o=e.length,i=r+(n?1:-1);n?i--:++i<o;)if(t(e[i],i,e))return i;return-1}var Mi=xi;function Ni(e){return e!==e}var Bi=Ni;function Li(e,t,r){for(var n=r-1,o=e.length;++n<o;)if(e[n]===t)return n;return-1}var ji=Li;function Ui(e,t,r){return t===t?ji(e,t,r):Mi(e,Bi,r)}var $i=Ui,Fi=Array.isArray,zi=Fi;function Ki(){}var Qi=Ki,Vi=R(function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=r;function r(n){return function(){if(n===null)throw new Error("Callback was already called.");var o=n;n=null,o.apply(this,arguments)}}e.exports=t.default}),cr=R(function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=r;function r(n,o){o=o|0;for(var i=Math.max(n.length-o,0),s=Array(i),a=0;a<i;a++)s[a]=n[o+a];return s}e.exports=t.default}),dr=R(function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.hasNextTick=t.hasSetImmediate=void 0,t.fallback=s,t.wrap=a;var r=n(cr);function n(u){return u&&u.__esModule?u:{default:u}}var o=t.hasSetImmediate=typeof setImmediate=="function"&&setImmediate,i=t.hasNextTick=typeof V=="object"&&typeof V.nextTick=="function";function s(u){setTimeout(u,0)}function a(u){return function(d){var c=(0,r.default)(arguments,1);u(function(){d.apply(null,c)})}}var l;o?l=setImmediate:i?l=V.nextTick:l=s,t.default=a(l)}),Hi=R(function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=r;function r(){this.head=this.tail=null,this.length=0}function n(o,i){o.length=1,o.head=o.tail=i}r.prototype.removeLink=function(o){return o.prev?o.prev.next=o.next:this.head=o.next,o.next?o.next.prev=o.prev:this.tail=o.prev,o.prev=o.next=null,this.length-=1,o},r.prototype.empty=function(){for(;this.head;)this.shift();return this},r.prototype.insertAfter=function(o,i){i.prev=o,i.next=o.next,o.next?o.next.prev=i:this.tail=i,o.next=i,this.length+=1},r.prototype.insertBefore=function(o,i){i.prev=o.prev,i.next=o,o.prev?o.prev.next=i:this.head=i,o.prev=i,this.length+=1},r.prototype.unshift=function(o){this.head?this.insertBefore(this.head,o):n(this,o)},r.prototype.push=function(o){this.tail?this.insertAfter(this.tail,o):n(this,o)},r.prototype.shift=function(){return this.head&&this.removeLink(this.head)},r.prototype.pop=function(){return this.tail&&this.removeLink(this.tail)},r.prototype.toArray=function(){for(var o=Array(this.length),i=this.head,s=0;s<this.length;s++)o[s]=i.data,i=i.next;return o},r.prototype.remove=function(o){for(var i=this.head;i;){var s=i.next;o(i)&&this.removeLink(i),i=s}return this},e.exports=t.default});function Gi(e){var t=typeof e;return e!=null&&(t=="object"||t=="function")}var Wi=Gi,Yi=R(function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(o){return function(){var i=(0,r.default)(arguments),s=i.pop();o.call(this,i,s)}};var r=n(cr);function n(o){return o&&o.__esModule?o:{default:o}}e.exports=t.default}),Xi=R(function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=s;var r=i(Wi),n=i(Yi),o=i(dr);function i(u){return u&&u.__esModule?u:{default:u}}function s(u){return(0,n.default)(function(d,c){var f;try{f=u.apply(this,d)}catch(g){return c(g)}(0,r.default)(f)&&typeof f.then=="function"?f.then(function(g){a(c,null,g)},function(g){a(c,g.message?g:new Error(g))}):c(null,f)})}function a(u,d,c){try{u(d,c)}catch(f){(0,o.default)(l,f)}}function l(u){throw u}e.exports=t.default}),hr=R(function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.isAsync=void 0;var r=n(Xi);function n(a){return a&&a.__esModule?a:{default:a}}var o=typeof Symbol=="function";function i(a){return o&&a[Symbol.toStringTag]==="AsyncFunction"}function s(a){return i(a)?(0,r.default)(a):a}t.default=s,t.isAsync=i}),Ji=R(function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=d;var r=u($i),n=u(zi),o=u(Qi),i=u(Vi),s=u(dr),a=u(Hi),l=u(hr);function u(c){return c&&c.__esModule?c:{default:c}}function d(c,f,g){if(f==null)f=1;else if(f===0)throw new Error("Concurrency must not be zero");var w=(0,l.default)(c),b=0,p=[],h=!1;function y(I,k,E){if(E!=null&&typeof E!="function")throw new Error("task callback must be a function");if(v.started=!0,(0,n.default)(I)||(I=[I]),I.length===0&&v.idle())return(0,s.default)(function(){v.drain()});for(var S=0,C=I.length;S<C;S++){var B={data:I[S],callback:E||o.default};k?v._tasks.unshift(B):v._tasks.push(B)}h||(h=!0,(0,s.default)(function(){h=!1,v.process()}))}function m(I){return function(k){b-=1;for(var E=0,S=I.length;E<S;E++){var C=I[E],B=(0,r.default)(p,C,0);B===0?p.shift():B>0&&p.splice(B,1),C.callback.apply(C,arguments),k!=null&&v.error(k,C.data)}b<=v.concurrency-v.buffer&&v.unsaturated(),v.idle()&&v.drain(),v.process()}}var _=!1,v={_tasks:new a.default,concurrency:f,payload:g,saturated:o.default,unsaturated:o.default,buffer:f/4,empty:o.default,drain:o.default,error:o.default,started:!1,paused:!1,push:function(I,k){y(I,!1,k)},kill:function(){v.drain=o.default,v._tasks.empty()},unshift:function(I,k){y(I,!0,k)},remove:function(I){v._tasks.remove(I)},process:function(){if(_)return;for(_=!0;!v.paused&&b<v.concurrency&&v._tasks.length;){var I=[],k=[],E=v._tasks.length;v.payload&&(E=Math.min(E,v.payload));for(var S=0;S<E;S++){var C=v._tasks.shift();I.push(C),p.push(C),k.push(C.data)}b+=1,v._tasks.length===0&&v.empty(),b===v.concurrency&&v.saturated();var B=(0,i.default)(m(I));w(k,B)}_=!1},length:function(){return v._tasks.length},running:function(){return b},workersList:function(){return p},idle:function(){return v._tasks.length+b===0},pause:function(){v.paused=!0},resume:function(){if(v.paused===!1)return;v.paused=!1,(0,s.default)(v.process)}};return v}e.exports=t.default}),Zi=R(function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(i,s){var a=(0,n.default)(i);return(0,r.default)(function(l,u){a(l[0],u)},s,1)};var r=o(Ji),n=o(hr);function o(i){return i&&i.__esModule?i:{default:i}}e.exports=t.default}),eo=Object.prototype.toString,to=function(e){return eo.call(e)==="[object Function]"},pr=typeof setImmediate=="function"?setImmediate:function(){var t=[].slice.apply(arguments);t.splice(1,0,0),setTimeout.apply(null,t)},ro=function(e){if(!to(e.then))throw new TypeError("Expected a promise");return function(t){e.then(function(r){pr(t,null,r)},function(r){pr(t,r)})}};class no{constructor(e,t,r,n){this.dht=e,this.run=t,this.path=r,this.log=n,this.concurrency=this.dht.concurrency,this.queue=this.setupQueue(),this.execution=null}setupQueue(){const e=Zi((t,r)=>{ro(this.processNext(t))(r)},this.concurrency);return e.error=t=>{this.log.error("queue",t),this.stop(t)},e.drain=()=>{this.log("queue:drain"),this.stop()},e.unsaturated=()=>{this.running&&this.fill()},e.buffer=0,e}stop(e){if(!this.running)return;this.running=!1,this.queue.kill(),this.log("worker:stop, %d workers still running",this.run.workers.filter(t=>t.running).length),e?this.execution.reject(e):this.execution.resolve()}async execute(){this.running=!0,this.execution={};const e=new Promise((t,r)=>Object.assign(this.execution,{resolve:t,reject:r}));this.fill(),await e}fill(){for(;this.queue.running()+this.queue.length()<this.concurrency&&this.path.peersToQuery.length>0;)this.queue.push(this.path.peersToQuery.dequeue())}async processNext(e){if(!this.running)return;if(this.run.peersSeen.has(e.toB58String()))return;let t,r;try{t=await this.run.continueQuerying(this)}catch(i){r=i}if(!this.running)return;if(r)throw r;if(!t){this.stop();return}if(this.run.peersSeen.has(e.toB58String()))return;this.run.peersSeen.add(e.toB58String()),this.log("queue:work");let n,o;try{n=await this.execQuery(e)}catch(i){o=i}if(!this.running)return;if(this.log("queue:work:done",o,n),o)throw o;if(n&&n.queryComplete){this.log("query:complete"),this.run.stop();return}n&&n.pathComplete&&this.stop()}async execQuery(e){let t,r;try{t=await this.path.queryFunc(e)}catch(n){r=n}if(!this.running)return;if(r){this.run.errors.push(r);return}if(await this.run.peersQueried.add(e),t.pathComplete||t.queryComplete)return this.path.res=t,{pathComplete:t.pathComplete,queryComplete:t.queryComplete};t.closerPeers&&t.closerPeers.length>0&&await Promise.all(t.closerPeers.map(async n=>{if(this.dht._isSelf(n.id))return;this.dht._peerDiscovered(n.id,n.multiaddrs),await this.path.addPeerToQuery(n.id)}))}}var io=no;class oo extends Ce{constructor(e){super();this.query=e,this.running=!1,this.workers=[],this.peersSeen=new Set,this.errors=[],this.peersQueried=null}stop(){if(!this.running)return;this.running=!1;for(const e of this.workers)e.stop()}async execute(e){const t=[],r=Math.min(this.query.dht.disjointPaths,e.length);for(let o=0;o<r;o++)t.push(new Ci(this,this.query.makePath(o,r)));e.forEach((o,i)=>{t[i%r].addInitialPeer(o)}),await this.executePaths(t);const n={finalSet:new Set(this.peersQueried.peers),paths:[]};for(const o of t)o.res&&(o.res.pathComplete||o.res.queryComplete)&&(o.res.success=!0,n.paths.push(o.res));return n}async executePaths(e){this.running=!0,this.emit("start");try{await Promise.all(e.map(t=>t.execute()))}finally{this.stop(),this.emit("complete")}if(this.errors.length===this.peersSeen.size)throw this.errors[0]}async workerQueue(e){await this.init(),await this.startWorker(e)}async startWorker(e){const t=new io(this.query.dht,this,e,this.query._log);this.workers.push(t),await t.execute()}async init(){if(this.peersQueried)return;if(this.peersQueriedPromise){await this.peersQueriedPromise;return}this.peersQueriedPromise=(async()=>{const e=await P.convertBuffer(this.query.key);this.peersQueried=new Ai(e,this.query.dht.kBucketSize)})(),await this.peersQueriedPromise,delete this.peersQueriedPromise}async continueQuerying(e){if(this.peersQueried.length<this.peersQueried.capacity)return!0;const t=e.queue.workersList().map(n=>n.data),r=await this.peersQueried.anyCloser(t);return!!r}}var so=oo;const ao=se.multihash;class uo{constructor(e,t,r){this.dht=e,this.key=t,this.makePath=r,this._log=P.logger(this.dht.peerId,"query:"+ao.toB58String(t)),this.running=!1,this._onStart=this._onStart.bind(this),this._onComplete=this._onComplete.bind(this)}async run(e){return this.dht._queryManager.running?e.length===0?(this._log.error("Running query with no peers"),{finalSet:new Set,paths:[]}):(this._run=new so(this),this._log(`query running with K=${this.dht.kBucketSize}, A=${this.dht.concurrency}, D=${Math.min(this.dht.disjointPaths,e.length)}`),this._run.once("start",this._onStart),this._run.once("complete",this._onComplete),this._run.execute(e)):(this._log.error("Attempt to run query after shutdown"),{finalSet:new Set,paths:[]})}_onStart(){this.running=!0,this._startTime=Date.now(),this._log("query:start"),this.dht._queryManager.queryStarted(this)}_onComplete(){this.stop()}stop(){if(this._log(`query:done in ${Date.now()-this._startTime}ms`),this._run&&this._log(`${this._run.errors.length} of ${this._run.peersSeen.size} peers errored (${this._run.errors.length/this._run.peersSeen.size*100}% fail rate)`),!this.running)return;this._run.removeListener("start",this._onStart),this._run.removeListener("complete",this._onComplete),this.running=!1,this._run&&this._run.stop(),this.dht._queryManager.queryCompleted(this)}}var Re=uo;const lo=z.Record;var co=e=>{const t=async(o,i)=>e.datastore.put(P.bufferToKey(o),i),r=async o=>{e._log("getLocal %b",o);const i=await e.datastore.get(P.bufferToKey(o));e._log("found %b in local datastore",o);const s=lo.deserialize(i);return await e._verifyRecordLocally(s),s},n=async(o,i,s)=>{const a=await P.createPutRecord(o,s);return Promise.all(i.map(async l=>{if(oe(l.val,s))return;if(e._isSelf(l.from)){try{await e._putLocal(o,a)}catch(u){e._log.error("Failed error correcting self",u)}return}try{await e._putValueToPeer(o,a,l.from)}catch(u){e._log.error("Failed error correcting entry",u)}}))};return{async _putLocal(o,i){return t(o,i)},async put(o,i,s={}){e._log("PutValue %b",o);const a=await P.createPutRecord(o,i);await t(o,a);let l=0,u=0;await P.mapParallel(e.getClosestPeers(o,{shallow:!0}),async c=>{try{l+=1,await e._putValueToPeer(o,a,c),u+=1}catch(f){e._log.error("Failed to put to peer (%b): %s",c.id,f)}});const d=s.minPeers||l;if(d>u){const c=T(new Error(`Failed to put value to enough peers: ${u}/${d}`),"ERR_NOT_ENOUGH_PUT_PEERS");throw e._log.error(c),c}},async get(o,i={}){i.timeout=i.timeout||x.minute,e._log("_get %b",o);const s=await e.getMany(o,x.GET_MANY_RECORD_COUNT,i),a=s.map(d=>d.val);let l=0;try{l=z.selection.bestRecord(e.selectors,o,a)}catch(d){if(d.code!=="ERR_NO_SELECTOR_FUNCTION_FOR_RECORD_KEY")throw d}const u=a[l];if(e._log("GetValue %b %s",o,u),!u)throw T(new Error("best value was not found"),"ERR_NOT_FOUND");return await n(o,s,u),u},async getMany(o,i,s={}){s.timeout=s.timeout||x.minute,e._log("getMany %b (%s)",o,i);let a=[],l;try{l=await r(o)}catch(w){if(i===0)throw w}if(l&&a.push({val:l.value,from:e.peerId}),a.length>=i)return a;const u=[],d=await P.convertBuffer(o),c=e.routingTable.closestPeers(d,this.kBucketSize);if(e._log("peers in rt: %d",c.length),c.length===0){const w="Failed to lookup key! No peers from routing table!";if(e._log.error(w),a.length===0)throw T(new Error(w),"ERR_NO_PEERS_IN_ROUTING_TABLE");return a}const f=new Re(e,o,(w,b)=>{const p=P.pathSize(i-a.length,b),h=[];return u.push(h),async y=>{let m,_,v;try{const k=await e._getValueOrPeers(y,o);m=k.record,_=k.peers}catch(k){if(k.code!=="ERR_INVALID_RECORD")throw k;v=k}const I={closerPeers:_};return(m&&m.value||v)&&h.push({val:m&&m.value,from:y}),h.length>=p&&(I.pathComplete=!0),I}});let g;try{await Q(f.run(c),s.timeout)}catch(w){g=w}if(f.stop(),a=[].concat.apply(a,u).slice(0,i),g&&a.length===0)throw g;return a}}};class ho{constructor(){this.list=[]}push(e){return this.has(e.id)?!1:(this.list.push(e),!0)}has(e){const t=this.list.find(r=>r.id.isEqual(e));return Boolean(t)}toArray(){return this.list.slice()}pop(){return this.list.pop()}get length(){return this.list.length}}var po=ho;class fo extends po{constructor(e){super();this.limit=e}push(e){return this.length<this.limit?super.push(e):!1}}var fr=fo,mo=e=>{const t=async(r,n)=>{const o=new D(D.TYPES.GET_PROVIDERS,n.bytes,0);return e.network.sendRequest(r,o)};return{async provide(r){e._log("provide: %s",r.toBaseEncodedString());const n=[];await e.providers.addProvider(r,e.peerId);const o=e.libp2p?e.libp2p.multiaddrs:[],i=new D(D.TYPES.ADD_PROVIDER,r.bytes,0);if(i.providerPeers=[{id:e.peerId,multiaddrs:o}],await P.mapParallel(e.getClosestPeers(r.bytes),async s=>{e._log("putProvider %s to %s",r.toBaseEncodedString(),s.toB58String());try{await e.network.sendMessage(s,i)}catch(a){n.push(a)}}),n.length)throw T(new Error(`Failed to provide to ${n.length} of ${e.kBucketSize} peers`,"ERR_SOME_PROVIDES_FAILED"),{errors:n})},async*findProviders(r,n={}){const o=n.timeout||x.minute,i=n.maxNumProviders||x.K;e._log("findProviders %s",r.toBaseEncodedString());const s=new fr(i),a=await e.providers.getProviders(r);if(a.forEach(c=>{const f=e.peerStore.get(c)||{};s.push({id:f.id||c,multiaddrs:(f.addresses||[]).map(g=>g.multiaddr)})}),s.length>=i){for(const c of s.toArray())yield c;return}const l=[],u=new Re(e,r.bytes,(c,f)=>{const g=P.pathSize(i-s.length,f),w=new fr(g);return l.push(w),async b=>{const p=await t(b,r),h=p.providerPeers;return e._log("(%s) found %s provider entries",e.peerId.toB58String(),h.length),h.forEach(y=>{w.push({id:y.id})}),w.length>=g?{pathComplete:!0}:{closerPeers:p.closerPeers}}}),d=e.routingTable.closestPeers(r.bytes,e.kBucketSize);try{await Q(u.run(d),o)}catch(c){if(c.name!==Q.TimeoutError.name)throw c}finally{u.stop()}if(l.forEach(c=>{c.toArray().forEach(f=>{s.push(f)})}),s.length===0)throw T(new Error("no providers found"),"ERR_NOT_FOUND");for(const c of s.toArray())yield c}}},yo=e=>{const t=async i=>{e._log("findPeerLocal %s",i.toB58String());const s=await e.routingTable.find(i),a=s&&e.peerStore.get(s);if(a)return{id:a.id,multiaddrs:a.addresses.map(l=>l.multiaddr)}},r=async(i,s)=>{const a=new D(D.TYPES.GET_VALUE,s,0);return e.network.sendRequest(i,a)},n=async(i,s)=>{e._log("closerPeersSingle %b from %s",i,s.toB58String());const a=await e.peerRouting._findPeerSingle(s,new Y(i));return a.closerPeers.filter(l=>!e._isSelf(l.id)).map(l=>(e.peerStore.addressBook.add(l.id,l.multiaddrs),l))},o=async i=>{const s=P.keyForPublicKey(i),a=await r(i,s);if(!a.record||!a.record.value)throw T(`Node not responding with its public key: ${i.toB58String()}`,"ERR_INVALID_RECORD");const l=Y.createFromPubKey(a.record.value);if(!l.isEqual(i))throw T("public key does not match id","ERR_PUBLIC_KEY_DOES_NOT_MATCH_ID");return l.pubKey};return{async _findPeerSingle(i,s){e._log("findPeerSingle %s",i.toB58String());const a=new D(D.TYPES.FIND_NODE,s.id,0);return e.network.sendRequest(i,a)},async findPeer(i,s={}){s.timeout=s.timeout||x.minute,e._log("findPeer %s",i.toB58String());const a=await t(i);if(a!=null)return e._log("found local"),a;const l=await P.convertPeerId(i),u=e.routingTable.closestPeers(l,e.kBucketSize);if(u.length===0)throw T(new Error("Peer lookup failed"),"ERR_LOOKUP_FAILED");const d=u.find(p=>p.isEqual(i));if(d){const p=e.peerStore.get(i);if(p)return e._log("found in peerStore"),{id:p.id,multiaddrs:p.addresses.map(h=>h.multiaddr)}}const c=new Re(e,i.id,()=>async p=>{const h=await this._findPeerSingle(p,i),y=h.closerPeers.find(m=>m.id.isEqual(i));return y?{peer:y,queryComplete:!0}:{closerPeers:h.closerPeers}});let f,g;try{g=await Q(c.run(u),s.timeout)}catch(p){f=p}if(c.stop(),f)throw f;let w=!1;if(g.paths.forEach(p=>{p.success&&(w=!0,e.peerStore.addressBook.add(p.peer.id,p.peer.multiaddrs))}),e._log("findPeer %s: %s",i.toB58String(),w),!w)throw T(new Error("No peer found"),"ERR_NOT_FOUND");const b=e.peerStore.get(i);return{id:b.id,multiaddrs:b.addresses.map(p=>p.multiaddr)}},async*getClosestPeers(i,s={shallow:!1}){e._log("getClosestPeers to %b",i);const a=await P.convertBuffer(i),l=e.routingTable.closestPeers(a,e.kBucketSize),u=new Re(e,i,()=>async f=>{const g=await n(i,f);return{closerPeers:g,pathComplete:s.shallow?!0:void 0}}),d=await u.run(l);if(!d||!d.finalSet)return[];const c=await P.sortClosestPeers(Array.from(d.finalSet),a);for(const f of c.slice(0,e.kBucketSize))yield f},async getPublicKey(i){e._log("getPublicKey %s",i.toB58String());const s=e.peerStore.get(i);if(s&&s.id.pubKey)return e._log("getPublicKey: found local copy"),s.id.pubKey;let a;try{a=await o(i)}catch(u){const d=P.keyForPublicKey(i),c=await e.get(d);a=Xe.keys.unmarshalPublicKey(c)}s.id=new Y(i.id,null,a);const l=s.addresses.map(u=>u.multiaddr);return e.peerStore.addressBook.add(s.id,l),e.peerStore.keyBook.set(s.id,a),a}}},go=R(function(e){var t=Object.prototype.hasOwnProperty,r="~";function n(){}Object.create&&(n.prototype=Object.create(null),new n().__proto__||(r=!1));function o(l,u,d){this.fn=l,this.context=u,this.once=d||!1}function i(l,u,d,c,f){if(typeof d!="function")throw new TypeError("The listener must be a function");var g=new o(d,c||l,f),w=r?r+u:u;return l._events[w]?l._events[w].fn?l._events[w]=[l._events[w],g]:l._events[w].push(g):(l._events[w]=g,l._eventsCount++),l}function s(l,u){--l._eventsCount===0?l._events=new n:delete l._events[u]}function a(){this._events=new n,this._eventsCount=0}a.prototype.eventNames=function(){var u=[],d,c;if(this._eventsCount===0)return u;for(c in d=this._events)t.call(d,c)&&u.push(r?c.slice(1):c);return Object.getOwnPropertySymbols?u.concat(Object.getOwnPropertySymbols(d)):u},a.prototype.listeners=function(u){var d=r?r+u:u,c=this._events[d];if(!c)return[];if(c.fn)return[c.fn];for(var f=0,g=c.length,w=new Array(g);f<g;f++)w[f]=c[f].fn;return w},a.prototype.listenerCount=function(u){var d=r?r+u:u,c=this._events[d];return c?c.fn?1:c.length:0},a.prototype.emit=function(u,d,c,f,g,w){var b=r?r+u:u;if(!this._events[b])return!1;var p=this._events[b],h=arguments.length,y,m;if(p.fn){p.once&&this.removeListener(u,p.fn,void 0,!0);switch(h){case 1:return p.fn.call(p.context),!0;case 2:return p.fn.call(p.context,d),!0;case 3:return p.fn.call(p.context,d,c),!0;case 4:return p.fn.call(p.context,d,c,f),!0;case 5:return p.fn.call(p.context,d,c,f,g),!0;case 6:return p.fn.call(p.context,d,c,f,g,w),!0}for(m=1,y=new Array(h-1);m<h;m++)y[m-1]=arguments[m];p.fn.apply(p.context,y)}else{var _=p.length,v;for(m=0;m<_;m++){p[m].once&&this.removeListener(u,p[m].fn,void 0,!0);switch(h){case 1:p[m].fn.call(p[m].context);break;case 2:p[m].fn.call(p[m].context,d);break;case 3:p[m].fn.call(p[m].context,d,c);break;case 4:p[m].fn.call(p[m].context,d,c,f);break;default:if(!y)for(v=1,y=new Array(h-1);v<h;v++)y[v-1]=arguments[v];p[m].fn.apply(p[m].context,y)}}}return!0},a.prototype.on=function(u,d,c){return i(this,u,d,c,!1)},a.prototype.once=function(u,d,c){return i(this,u,d,c,!0)},a.prototype.removeListener=function(u,d,c,f){var g=r?r+u:u;if(!this._events[g])return this;if(!d)return s(this,g),this;var w=this._events[g];if(w.fn)w.fn===d&&(!f||w.once)&&(!c||w.context===c)&&s(this,g);else{for(var b=0,p=[],h=w.length;b<h;b++)(w[b].fn!==d||f&&!w[b].once||c&&w[b].context!==c)&&p.push(w[b]);p.length?this._events[g]=p.length===1?p[0]:p:s(this,g)}return this},a.prototype.removeAllListeners=function(u){var d;return u?(d=r?r+u:u,this._events[d]&&s(this,d)):(this._events=new n,this._eventsCount=0),this},a.prototype.off=a.prototype.removeListener,a.prototype.addListener=a.prototype.on,a.prefixed=r,a.EventEmitter=a,e.exports=a}),vo=R(function(e,t){Object.defineProperty(t,"__esModule",{value:!0});function r(n,o,i){let s=0,a=n.length;for(;a>0;){const l=a/2|0;let u=s+l;i(n[u],o)<=0?(s=++u,a-=l+1):a=l}return s}t.default=r}),wo=R(function(e,t){Object.defineProperty(t,"__esModule",{value:!0});class r{constructor(){this._queue=[]}enqueue(n,o){o=Object.assign({priority:0},o);const i={priority:o.priority,run:n};if(this.size&&this._queue[this.size-1].priority>=o.priority){this._queue.push(i);return}const s=vo.default(this._queue,i,(a,l)=>l.priority-a.priority);this._queue.splice(s,0,i)}dequeue(){const n=this._queue.shift();return n==null?void 0:n.run}filter(n){return this._queue.filter(o=>o.priority===n.priority).map(o=>o.run)}get size(){return this._queue.length}}t.default=r}),bo=R(function(e,t){Object.defineProperty(t,"__esModule",{value:!0});const r=()=>{},n=new Q.TimeoutError;class o extends go{constructor(i){var s,a,l,u;super();if(this._intervalCount=0,this._intervalEnd=0,this._pendingCount=0,this._resolveEmpty=r,this._resolveIdle=r,i=Object.assign({carryoverConcurrencyCount:!1,intervalCap:Infinity,interval:0,concurrency:Infinity,autoStart:!0,queueClass:wo.default},i),!(typeof i.intervalCap=="number"&&i.intervalCap>=1))throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${(a=(s=i.intervalCap)===null||s===void 0?void 0:s.toString())!==null&&a!==void 0?a:""}\` (${typeof i.intervalCap})`);if(i.interval===void 0||!(Number.isFinite(i.interval)&&i.interval>=0))throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${(u=(l=i.interval)===null||l===void 0?void 0:l.toString())!==null&&u!==void 0?u:""}\` (${typeof i.interval})`);this._carryoverConcurrencyCount=i.carryoverConcurrencyCount,this._isIntervalIgnored=i.intervalCap===Infinity||i.interval===0,this._intervalCap=i.intervalCap,this._interval=i.interval,this._queue=new i.queueClass,this._queueClass=i.queueClass,this.concurrency=i.concurrency,this._timeout=i.timeout,this._throwOnTimeout=i.throwOnTimeout===!0,this._isPaused=i.autoStart===!1}get _doesIntervalAllowAnother(){return this._isIntervalIgnored||this._intervalCount<this._intervalCap}get _doesConcurrentAllowAnother(){return this._pendingCount<this._concurrency}_next(){this._pendingCount--,this._tryToStartAnother(),this.emit("next")}_resolvePromises(){this._resolveEmpty(),this._resolveEmpty=r,this._pendingCount===0&&(this._resolveIdle(),this._resolveIdle=r,this.emit("idle"))}_onResumeInterval(){this._onInterval(),this._initializeIntervalIfNeeded(),this._timeoutId=void 0}_isIntervalPaused(){const i=Date.now();if(this._intervalId===void 0){const s=this._intervalEnd-i;if(s<0)this._intervalCount=this._carryoverConcurrencyCount?this._pendingCount:0;else return this._timeoutId===void 0&&(this._timeoutId=setTimeout(()=>{this._onResumeInterval()},s)),!0}return!1}_tryToStartAnother(){if(this._queue.size===0)return this._intervalId&&clearInterval(this._intervalId),this._intervalId=void 0,this._resolvePromises(),!1;if(!this._isPaused){const i=!this._isIntervalPaused();if(this._doesIntervalAllowAnother&&this._doesConcurrentAllowAnother){const s=this._queue.dequeue();return s?(this.emit("active"),s(),i&&this._initializeIntervalIfNeeded(),!0):!1}}return!1}_initializeIntervalIfNeeded(){if(this._isIntervalIgnored||this._intervalId!==void 0)return;this._intervalId=setInterval(()=>{this._onInterval()},this._interval),this._intervalEnd=Date.now()+this._interval}_onInterval(){this._intervalCount===0&&this._pendingCount===0&&this._intervalId&&(clearInterval(this._intervalId),this._intervalId=void 0),this._intervalCount=this._carryoverConcurrencyCount?this._pendingCount:0,this._processQueue()}_processQueue(){for(;this._tryToStartAnother(););}get concurrency(){return this._concurrency}set concurrency(i){if(!(typeof i=="number"&&i>=1))throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${i}\` (${typeof i})`);this._concurrency=i,this._processQueue()}async add(i,s={}){return new Promise((a,l)=>{const u=async()=>{this._pendingCount++,this._intervalCount++;try{const d=this._timeout===void 0&&s.timeout===void 0?i():Q.default(Promise.resolve(i()),s.timeout===void 0?this._timeout:s.timeout,()=>{(s.throwOnTimeout===void 0?this._throwOnTimeout:s.throwOnTimeout)&&l(n);return});a(await d)}catch(d){l(d)}this._next()};this._queue.enqueue(u,s),this._tryToStartAnother(),this.emit("add")})}async addAll(i,s){return Promise.all(i.map(async a=>this.add(a,s)))}start(){return this._isPaused?(this._isPaused=!1,this._processQueue(),this):this}pause(){this._isPaused=!0}clear(){this._queue=new this._queueClass}async onEmpty(){return this._queue.size===0?void 0:new Promise(i=>{const s=this._resolveEmpty;this._resolveEmpty=()=>{s(),i()}})}async onIdle(){return this._pendingCount===0&&this._queue.size===0?void 0:new Promise(i=>{const s=this._resolveIdle;this._resolveIdle=()=>{s(),i()}})}get size(){return this._queue.size}sizeBy(i){return this._queue.filter(i).length}get pending(){return this._pendingCount}get isPaused(){return this._isPaused}get timeout(){return this._timeout}set timeout(i){this._timeout=i}}t.default=o});const{Key:_o}=Be,{default:Po}=bo;class Io{constructor(e,t,r){this.datastore=e,this._log=P.logger(t,"providers"),this.cleanupInterval=x.PROVIDERS_CLEANUP_INTERVAL,this.provideValidity=x.PROVIDERS_VALIDITY,this.lruCacheSize=r||x.PROVIDERS_LRU_CACHE_SIZE,this.providers=Jt(this.lruCacheSize),this.syncQueue=new Po({concurrency:1})}start(){this._cleaner=setInterval(()=>this._cleanup(),this.cleanupInterval)}stop(){clearInterval(this._cleaner),this._cleaner=null}_cleanup(){return this.syncQueue.add(async()=>{this._log("start cleanup");const e=Date.now();let t=0,r=0;const n=new Map,o=this.datastore.batch(),i=this.datastore.query({prefix:x.PROVIDERS_KEY_PREFIX});for await(const s of i)try{const{cid:a,peerId:l}=mr(s.key),u=yr(s.value),d=Date.now(),c=d-u,f=c>this.provideValidity;if(this._log("comparing: %d - %d = %d > %d %s",d,u,c,this.provideValidity,f?"(expired)":""),f){r++,o.delete(s.key);const g=n.get(a)||new Set;g.add(l),n.set(a,g)}t++}catch(a){this._log.error(a.message)}this._log("deleting %d / %d entries",r,t),n.size&&await o.commit();for(const[s,a]of n){const l=he(s),u=this.providers.get(l);if(u){for(const d of a)u.delete(d);u.size===0?this.providers.remove(l):this.providers.set(l,u)}}this._log("Cleanup successful (%dms)",Date.now()-e)})}async _getProvidersMap(e){const t=he(e);let r=this.providers.get(t);return r||(r=await Eo(this.datastore,e),this.providers.set(t,r)),r}async addProvider(e,t){return this.syncQueue.add(async()=>{this._log("addProvider %s",e.toBaseEncodedString());const r=await this._getProvidersMap(e);this._log("loaded %s provs",r.size);const n=Date.now();r.set(P.encodeBase32(t.id),n);const o=he(e);return this.providers.set(o,r),ko(this.datastore,e,t,n)})}async getProviders(e){return this.syncQueue.add(async()=>{this._log("getProviders %s",e.toBaseEncodedString());const t=await this._getProvidersMap(e);return[...t.keys()].map(r=>new Y(P.decodeBase32(r)))})}}function he(e){return e=typeof e=="string"?e:P.encodeBase32(e.bytes),x.PROVIDERS_KEY_PREFIX+e}async function ko(e,t,r,n){const o=[he(t),"/",P.encodeBase32(r.id)].join(""),i=new _o(o),s=Uint8Array.from(O.encode(n));return e.put(i,s)}function mr(e){const t=e.toString().split("/");if(t.length!==4)throw new Error("incorrectly formatted provider entry key in datastore: "+e);return{cid:t[2],peerId:t[3]}}async function Eo(e,t){const r=new Map,n=e.query({prefix:he(t)});for await(const o of n){const{peerId:i}=mr(o.key);r.set(i,yr(o.value))}return r}function yr(e){return O.decode(e)}var To=Io,Ao=async(e,t,{concurrency:r=Infinity,stopOnError:n=!0}={})=>new Promise((o,i)=>{if(typeof t!="function")throw new TypeError("Mapper function is required");if(!((Number.isSafeInteger(r)||r===Infinity)&&r>=1))throw new TypeError(`Expected \`concurrency\` to be an integer from 1 and up or \`Infinity\`, got \`${r}\` (${typeof r})`);const s=[],a=[],l=e[Symbol.iterator]();let u=!1,d=!1,c=0,f=0;const g=()=>{if(u)return;const w=l.next(),b=f;if(f++,w.done){d=!0,c===0&&(!n&&a.length!==0?i(new Le(a)):o(s));return}c++,(async()=>{try{const p=await w.value;s[b]=await t(p,b),c--,g()}catch(p){n?(u=!0,i(p)):(a.push(p),c--,g())}})()};for(let w=0;w<r&&!(g(),d);w++);});const gr=async(e,t,r)=>Ao(new Array(e).fill(),(n,o)=>t(o),r);var vr=gr,So=gr;vr.default=So;const{logger:qo}=P;class Ro{constructor(e,t){if(!e)throw new Error("Random Walk needs an instance of the Kademlia DHT");this._kadDHT=e,this._options={...x.defaultRandomWalk,...t},this.log=qo(e.peerId,"random-walk"),this._timeoutId=void 0}start(){if(this._timeoutId||!this._options.enabled)return;this._timeoutId=setTimeout(()=>{this._runPeriodically()},this._options.delay)}stop(){this._timeoutId&&(clearTimeout(this._timeoutId),this._timeoutId=void 0),this._controller&&this._controller.abort()}async _runPeriodically(){for(;this._timeoutId;){try{await this._walk(this._options.queriesPerPeriod,this._options.timeout)}catch(e){this._kadDHT._log.error("random-walk:error",e)}await new Promise(e=>{this._timeoutId=setTimeout(e,this._options.interval)})}}async _walk(e,t){this.log("start"),this._controller=new be;try{await vr(e,async r=>{this.log("running query %d",r);try{const n=await this._randomPeerId();if(!this._controller)return;await this._query(n,{timeout:t,signal:this._controller.signal})}catch(n){if(n&&n.code!=="ETIMEDOUT")throw this.log.error("query %d finished with error",r,n),n}this.log("finished query %d",r)})}finally{this._controller=null,this.log("finished queries")}}async _query(e,t){this.log("query:%s",e.toB58String());let r;try{r=await this._kadDHT.findPeer(e,t)}catch(n){if(n&&n.code==="ERR_NOT_FOUND")return;throw n}throw this.log("query:found",r),T(`random-walk: ACTUALLY FOUND PEER: ${r}, ${e.toB58String()}`,"ERR_FOUND_RANDOM_PEER")}async _randomPeerId(){const e=await se(Xe.randomBytes(16),"sha2-256");return new Y(e)}}var Oo=Ro;class Do{constructor(){this.queries=new Set,this.running=!1}queryStarted(e){this.queries.add(e)}queryCompleted(e){this.queries.delete(e)}start(){this.running=!0}stop(){this.running=!1;for(const e of this.queries)e.stop();this.queries.clear()}}var Co=Do;const{EventEmitter:xo}=Ce,{MemoryDatastore:Mo}=Be,wr=z.Record;class No extends xo{constructor({libp2p:e,dialer:t,peerId:r,peerStore:n,registrar:o,protocolPrefix:i="/ipfs",forceProtocolLegacy:s=!1,datastore:a=new Mo,kBucketSize:l=x.K,clientMode:u=!1,concurrency:d=x.ALPHA,validators:c={},selectors:f={},randomWalk:g={},onPut:w=()=>{},onRemove:b=()=>{}}){super();if(!t)throw new Error("libp2p-kad-dht requires an instance of Dialer");this.libp2p=e,this.dialer=t,this.peerId=r,this.peerStore=n,this.registrar=o,this.protocol=i+(s?"":x.PROTOCOL_DHT),this.kBucketSize=l,this._clientMode=u,this.concurrency=d,this.disjointPaths=Math.ceil(this.kBucketSize/2),this.routingTable=new oi(this.peerId,this.kBucketSize),this.datastore=a,this.providers=new To(this.datastore,this.peerId),this.validators={pk:z.validator.validators.pk,...c},this.selectors={pk:z.selection.selectors.pk,...f},this.network=new Ei(this),this._log=P.logger(this.peerId),this.randomWalk=new Oo(this,g),this._queryManager=new Co,this._running=!1,this.contentFetching=co(this),this.contentRouting=mo(this),this.peerRouting=yo(this),this.onPut=w,this.onRemove=b}get isStarted(){return this._running}async start(){this._running=!0,this.providers.start(),this._queryManager.start(),await this.network.start(),this.randomWalk.start()}stop(){return this._running=!1,this.randomWalk.stop(),this.providers.stop(),this._queryManager.stop(),this.network.stop()}async put(e,t,r={}){return this.contentFetching.put(e,t,r)}async get(e,t={}){return this.contentFetching.get(e,t)}async getMany(e,t,r={}){return this.contentFetching.getMany(e,t,r)}async removeLocal(e){this._log("removeLocal: %b",e);const t=P.bufferToKey(e);try{await this.datastore.delete(t)}catch(r){if(r.code==="ERR_NOT_FOUND")return;throw r}}async provide(e){return this.contentRouting.provide(e)}async*findProviders(e,t={}){for await(const r of this.contentRouting.findProviders(e,t))yield r}async findPeer(e,t={}){return this.peerRouting.findPeer(e,t)}async*getClosestPeers(e,t={shallow:!1}){for await(const r of this.peerRouting.getClosestPeers(e,t))yield r}async getPublicKey(e){return this.peerRouting.getPublicKey(e)}_peerDiscovered(e,t){this.emit("peer",{id:e,multiaddrs:t})}async _nearestPeersToQuery(e){const t=await P.convertBuffer(e.key),r=this.routingTable.closestPeers(t,this.kBucketSize);return r.map(n=>{const o=this.peerStore.get(n);return{id:n,multiaddrs:o?o.addresses.map(i=>i.multiaddr):[]}})}async _betterPeersToQuery(e,t){this._log("betterPeersToQuery");const r=await this._nearestPeersToQuery(e);return r.filter(n=>this._isSelf(n.id)?(this._log.error("trying to return self as closer"),!1):!n.id.isEqual(t))}async _checkLocalDatastore(e){this._log("checkLocalDatastore: %b",e);const t=P.bufferToKey(e);let r;try{r=await this.datastore.get(t)}catch(o){if(o.code==="ERR_NOT_FOUND")return;throw o}const n=wr.deserialize(r);if(!n)throw T("Invalid record","ERR_INVALID_RECORD");if(n.timeReceived==null||P.now()-n.timeReceived>x.MAX_RECORD_AGE){await this.datastore.delete(t),this.onRemove(n);return}return n}async _add(e){await this.routingTable.add(e)}async _verifyRecordLocally(e){this._log("verifyRecordLocally"),await z.validator.verifyRecord(this.validators,e)}_isSelf(e){return e&&oe(this.peerId.id,e.id)}async _putValueToPeer(e,t,r){const n=new D(D.TYPES.PUT_VALUE,e,0);n.record=t;const o=await this.network.sendRequest(r,n);if(!o.record.value.equals(wr.deserialize(t).value))throw T(new Error("value not put correctly"),"ERR_PUT_VALUE_INVALID")}async _getValueOrPeers(e,t){const r=await this._getValueSingle(e,t),n=r.closerPeers,o=r.record;if(o){try{await this._verifyRecordOnline(o)}catch(i){const s="invalid record received, discarded";throw this._log(s),T(new Error(s),"ERR_INVALID_RECORD")}return{record:o,peers:n}}if(n.length>0)return{peers:n};throw T(new Error("Not found"),"ERR_NOT_FOUND")}async _getValueSingle(e,t){const r=new D(D.TYPES.GET_VALUE,t,0);return this.network.sendRequest(e,r)}async _verifyRecordOnline(e){await z.validator.verifyRecord(this.validators,e)}}var Oe=No,br="/ipfs"+x.PROTOCOL_DHT;Oe.multicodec=br;var Bo=Object.freeze(Object.assign(Object.create(null),Oe,{default:Oe,multicodec:br}));export{te as B,Le as a,ge as b,re as c,be as d,Xe as e,rr as f,nr as g,Jt as h,Bo as i,Oe as j,Q as p,Zt as r,kt as s};
