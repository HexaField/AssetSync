import{e as Ce}from"./events-18451fd5.js";import{s as pe,f as fe,p as vr,u as wr,g as br,k as _r,r as Pr,a as G,b as me,i as xe}from"./index-f214b2ff.js";import{p as W}from"./process-e9e98960.js";import{b as Z}from"./buffer-es6-e6024076.js";import{c as x,g as Ir,a as kr}from"./_commonjsHelpers-c99fd594.js";import{c as Y,v as R,a as nt,e as oe,g as se,f as F,b as Er}from"./index-c4e59f80.js";import{t as M}from"./to-string-b6e14ed9.js";import{f as ae}from"./from-string-5d106fde.js";import{c as Me}from"./key-6d7f3d3d.js";import{d as it}from"./__node-resolve:empty-d7309c3b.js";import{e as T}from"./index-4f726977.js";import{s as Ne}from"./index-85b101c8.js";import{b as ot}from"./base32-ae13e88d.js";import{b as Tr}from"./browser-f3be077b.js";var Ar=(e,t=1,r)=>{if(r={indent:" ",includeEmptyLines:!1,...r},typeof e!="string")throw new TypeError(`Expected \`input\` to be a \`string\`, got \`${typeof e}\``);if(typeof t!="number")throw new TypeError(`Expected \`count\` to be a \`number\`, got \`${typeof t}\``);if(typeof r.indent!="string")throw new TypeError(`Expected \`options.indent\` to be a \`string\`, got \`${typeof r.indent}\``);if(t===0)return e;const n=r.includeEmptyLines?/^/gm:/^(?!\s*$)/gm;return e.replace(n,r.indent.repeat(t))};const st=/\s+at.*(?:\(|\s)(.*)\)?/,Sr=/^(?:(?:(?:node|(?:internal\/[\w/]*|.*node_modules\/(?:babel-polyfill|pirates)\/.*)?\w+)\.js:\d+:\d+)|native)/,qr=typeof it.homedir=="undefined"?"":it.homedir();var Rr=(e,t)=>(t=Object.assign({pretty:!1},t),e.replace(/\\/g,"/").split(`
`).filter(r=>{const n=r.match(st);if(n===null||!n[1])return!0;const i=n[1];return i.includes(".app/Contents/Resources/electron.asar")||i.includes(".app/Contents/Resources/default_app.asar")?!1:!Sr.test(i)}).filter(r=>r.trim()!=="").map(r=>t.pretty?r.replace(st,(n,i)=>n.replace(i,i.replace(qr,"~"))):r).join(`
`));const Dr=e=>e.replace(/\s+at .*aggregate-error\/index.js:\d+:\d+\)?/g,"");class Or extends Error{constructor(e){if(!Array.isArray(e))throw new TypeError(`Expected input to be an Array, got ${typeof e}`);e=[...e].map(r=>r instanceof Error?r:r!==null&&typeof r=="object"?Object.assign(new Error(r.message),r):new Error(r));let t=e.map(r=>typeof r.stack=="string"?Dr(Rr(r.stack)):String(r)).join(`
`);t=`
`+Ar(t,4),super(t),this.name="AggregateError",Object.defineProperty(this,"_errors",{value:e})}*[Symbol.iterator](){for(const e of this._errors)yield e}}var Be=Or;const at="[a-fA-F\\d:]",Q=e=>e&&e.includeBoundaries?`(?:(?<=\\s|^)(?=${at})|(?<=${at})(?=\\s|$))`:"",j="(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}",q="[a-fA-F\\d]{1,4}",ye=`
(
(?:${q}:){7}(?:${q}|:)|                                // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:${q}:){6}(?:${j}|:${q}|:)|                         // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:${q}:){5}(?::${j}|(:${q}){1,2}|:)|                 // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:${q}:){4}(?:(:${q}){0,1}:${j}|(:${q}){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:${q}:){3}(?:(:${q}){0,2}:${j}|(:${q}){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:${q}:){2}(?:(:${q}){0,3}:${j}|(:${q}){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:${q}:){1}(?:(:${q}){0,4}:${j}|(:${q}){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::((?::${q}){0,5}:${j}|(?::${q}){1,7}|:))           // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(%[0-9a-zA-Z]{1,})?                                           // %eth0            %1
`.replace(/\s*\/\/.*$/gm,"").replace(/\n/g,"").trim(),Cr=new RegExp(`(?:^${j}$)|(?:^${ye}$)`),xr=new RegExp(`^${j}$`),Mr=new RegExp(`^${ye}$`),Le=e=>e&&e.exact?Cr:new RegExp(`(?:${Q(e)}${j}${Q(e)})|(?:${Q(e)}${ye}${Q(e)})`,"g");Le.v4=e=>e&&e.exact?xr:new RegExp(`${Q(e)}${j}${Q(e)}`,"g"),Le.v6=e=>e&&e.exact?Mr:new RegExp(`${Q(e)}${ye}${Q(e)}`,"g");var je=Le;const ee=e=>je({exact:!0}).test(e);ee.v4=e=>je.v4({exact:!0}).test(e),ee.v6=e=>je.v6({exact:!0}).test(e),ee.version=e=>ee(e)?ee.v4(e)?4:6:void 0;var ge=ee;const Nr=ge,Ue=ge.v4,ut=ge.v6,lt=function(e,t,r){r=~~r;var n;if(Ue(e))n=t||new Uint8Array(r+4),e.split(/\./g).map(function(d){n[r++]=parseInt(d,10)&255});else if(ut(e)){var i=e.split(":",8),o;for(o=0;o<i.length;o++){var s=Ue(i[o]),a;s&&(a=lt(i[o]),i[o]=M(a.slice(0,2),"base16")),a&&++o<8&&i.splice(o,0,M(a.slice(2,4),"base16"))}if(i[0]==="")for(;i.length<8;)i.unshift("0");else if(i[i.length-1]==="")for(;i.length<8;)i.push("0");else if(i.length<8){for(o=0;o<i.length&&i[o]!=="";o++);var l=[o,"1"];for(o=9-i.length;o>0;o--)l.push("0");i.splice.apply(i,l)}for(n=t||new Uint8Array(r+16),o=0;o<i.length;o++){var u=parseInt(i[o],16);n[r++]=u>>8&255,n[r++]=u&255}}if(!n)throw Error("Invalid ip address: "+e);return n},Br=function(e,t,r){t=~~t,r=r||e.length-t;var n=[],i;const o=new DataView(e.buffer);if(r===4){for(let s=0;s<r;s++)n.push(e[t+s]);i=n.join(".")}else if(r===16){for(let s=0;s<r;s+=2)n.push(o.getUint16(t+s).toString(16));i=n.join(":"),i=i.replace(/(^|:)0(:0)*:0(:|$)/,"$1::$3"),i=i.replace(/:{3,4}/,"::")}return i};var ve={isIP:Nr,isV4:Ue,isV6:ut,toBytes:lt,toString:Br};function N(e){if(typeof e=="number"){if(N.codes[e])return N.codes[e];throw new Error("no protocol with code: "+e)}else if(typeof e=="string"||e instanceof String){if(N.names[e])return N.names[e];throw new Error("no protocol with name: "+e)}throw new Error("invalid protocol id type: "+e)}const L=-1;N.lengthPrefixedVarSize=L,N.V=L,N.table=[[4,32,"ip4"],[6,16,"tcp"],[33,16,"dccp"],[41,128,"ip6"],[42,L,"ip6zone"],[53,L,"dns","resolvable"],[54,L,"dns4","resolvable"],[55,L,"dns6","resolvable"],[56,L,"dnsaddr","resolvable"],[132,16,"sctp"],[273,16,"udp"],[275,0,"p2p-webrtc-star"],[276,0,"p2p-webrtc-direct"],[277,0,"p2p-stardust"],[290,0,"p2p-circuit"],[301,0,"udt"],[302,0,"utp"],[400,L,"unix",!1,"path"],[421,L,"ipfs"],[421,L,"p2p"],[443,0,"https"],[444,96,"onion"],[445,296,"onion3"],[446,L,"garlic64"],[460,0,"quic"],[477,0,"ws"],[478,0,"wss"],[479,0,"p2p-websocket-star"],[480,0,"http"],[777,L,"memory"]],N.names={},N.codes={},N.table.map(e=>{const t=ct.apply(null,e);N.codes[t.code]=t,N.names[t.name]=t}),N.object=ct;function ct(e,t,r,n,i){return{code:e,size:t,name:r,resolvable:Boolean(n),path:Boolean(i)}}var z=N,dt=ue;function ue(e,t){return t instanceof Uint8Array?ue.toString(e,t):ue.toBytes(e,t)}ue.toString=function(t,r){t=z(t);switch(t.code){case 4:case 41:return Lr(r);case 6:case 273:case 33:case 132:return pt(r);case 53:case 54:case 55:case 56:case 400:case 777:return Ur(r);case 421:return Fr(r);case 444:return ft(r);case 445:return ft(r);default:return M(r,"base16")}},ue.toBytes=function(t,r){t=z(t);switch(t.code){case 4:return ht(r);case 41:return ht(r);case 6:case 273:case 33:case 132:return $e(parseInt(r,10));case 53:case 54:case 55:case 56:case 400:case 777:return jr(r);case 421:return $r(r);case 444:return zr(r);case 445:return Kr(r);default:return ae(r,"base16")}};function ht(e){if(!ve.isIP(e))throw new Error("invalid ip address");return ve.toBytes(e)}function Lr(e){const t=ve.toString(e);if(!t||!ve.isIP(t))throw new Error("invalid ip address");return t}function $e(e){const t=new ArrayBuffer(2),r=new DataView(t);return r.setUint16(0,e),new Uint8Array(t)}function pt(e){const t=new DataView(e.buffer);return t.getUint16(0)}function jr(e){const t=ae(e),r=Uint8Array.from(R.encode(t.length));return Y([r,t],r.length+t.length)}function Ur(e){const t=R.decode(e);if(e=e.slice(R.decode.bytes),e.length!==t)throw new Error("inconsistent lengths");return M(e)}function $r(e){const t=new pe(e).multihash,r=Uint8Array.from(R.encode(t.length));return Y([r,t],r.length+t.length)}function Fr(e){const t=R.decode(e),r=e.slice(R.decode.bytes);if(r.length!==t)throw new Error("inconsistent lengths");return M(r,"base58btc")}function zr(e){const t=e.split(":");if(t.length!==2)throw new Error("failed to parse onion addr: "+t+" does not contain a port number");if(t[0].length!==16)throw new Error("failed to parse onion addr: "+t[0]+" not a Tor onion address.");const r=nt.decode("b"+t[0]),n=parseInt(t[1],10);if(n<1||n>65536)throw new Error("Port number is not in range(1, 65536)");const i=$e(n);return Y([r,i],r.length+i.length)}function Kr(e){const t=e.split(":");if(t.length!==2)throw new Error("failed to parse onion addr: "+t+" does not contain a port number");if(t[0].length!==56)throw new Error("failed to parse onion addr: "+t[0]+" not a Tor onion3 address.");const r=nt.decode("b"+t[0]),n=parseInt(t[1],10);if(n<1||n>65536)throw new Error("Port number is not in range(1, 65536)");const i=$e(n);return Y([r,i],r.length+i.length)}function ft(e){const t=e.slice(0,e.length-2),r=e.slice(e.length-2),n=M(t,"base32"),i=pt(r);return n+":"+i}var U={stringToStringTuples:mt,stringTuplesToString:yt,tuplesToStringTuples:vt,stringTuplesToTuples:gt,bytesToTuples:Fe,tuplesToBytes:wt,bytesToString:Qr,stringToBytes:_t,fromString:Hr,fromBytes:Pt,validateBytes:ze,isValidBytes:Vr,cleanPath:we,ParseError:Ke,protoFromTuple:le,sizeForAddr:bt};function mt(e){const t=[],r=e.split("/").slice(1);if(r.length===1&&r[0]==="")return[];for(let n=0;n<r.length;n++){const i=r[n],o=z(i);if(o.size===0){t.push([i]);continue}if(n++,n>=r.length)throw Ke("invalid address: "+e);if(o.path){t.push([i,we(r.slice(n).join("/"))]);break}t.push([i,r[n]])}return t}function yt(e){const t=[];return e.map(r=>{const n=le(r);t.push(n.name),r.length>1&&t.push(r[1])}),we(t.join("/"))}function gt(e){return e.map(t=>{Array.isArray(t)||(t=[t]);const r=le(t);return t.length>1?[r.code,dt.toBytes(r.code,t[1])]:[r.code]})}function vt(e){return e.map(t=>{const r=le(t);return t.length>1?[r.code,dt.toString(r.code,t[1])]:[r.code]})}function wt(e){return Pt(Y(e.map(t=>{const r=le(t);let n=Uint8Array.from(R.encode(r.code));return t.length>1&&(n=Y([n,t[1]])),n})))}function bt(e,t){if(e.size>0)return e.size/8;if(e.size===0)return 0;{const r=R.decode(t);return r+R.decode.bytes}}function Fe(e){const t=[];let r=0;for(;r<e.length;){const n=R.decode(e,r),i=R.decode.bytes,o=z(n),s=bt(o,e.slice(r+i));if(s===0){t.push([n]),r+=i;continue}const a=e.slice(r+i,r+i+s);if(r+=s+i,r>e.length)throw Ke("Invalid address Uint8Array: "+M(e,"base16"));t.push([n,a])}return t}function Qr(e){const t=Fe(e),r=vt(t);return yt(r)}function _t(e){e=we(e);const t=mt(e),r=gt(t);return wt(r)}function Hr(e){return _t(e)}function Pt(e){const t=ze(e);if(t)throw t;return Uint8Array.from(e)}function ze(e){try{Fe(e)}catch(t){return t}}function Vr(e){return ze(e)===void 0}function we(e){return"/"+e.trim().split("/").filter(t=>t).join("/")}function Ke(e){return new Error("Error parsing address: "+e)}function le(e){const t=z(e[0]);return t}var It=x(function(e,t){const r=Symbol.for("nodejs.util.inspect.custom"),n=Me.proto(function(i){if(!(this instanceof n))return new n(i);if(i==null&&(i=""),i instanceof Uint8Array)this.bytes=U.fromBytes(i);else if(typeof i=="string"||i instanceof String){if(i.length>0&&i.charAt(0)!=="/")throw new Error(`multiaddr "${i}" must start with a "/"`);this.bytes=U.fromString(i)}else if(i.bytes&&i.protos&&i.protoCodes)this.bytes=U.fromBytes(i.bytes);else throw new Error("addr must be a string, Buffer, or another Multiaddr")},{className:"Multiaddr",symbolName:"@multiformats/js-multiaddr/multiaddr"});n.prototype.toString=function(){return U.bytesToString(this.bytes)},n.prototype.toJSON=n.prototype.toString,n.prototype.toOptions=function(){const o={},s=this.toString().split("/");return o.family=s[1]==="ip4"?"ipv4":"ipv6",o.host=s[2],o.transport=s[3],o.port=parseInt(s[4]),o},n.prototype[r]=function(){return"<Multiaddr "+M(this.bytes,"base16")+" - "+U.bytesToString(this.bytes)+">"},n.prototype.inspect=function(){return"<Multiaddr "+M(this.bytes,"base16")+" - "+U.bytesToString(this.bytes)+">"},n.prototype.protos=function(){return this.protoCodes().map(o=>Object.assign({},z(o)))},n.prototype.protoCodes=function(){const o=[],s=this.bytes;let a=0;for(;a<s.length;){const l=R.decode(s,a),u=R.decode.bytes,d=z(l),c=U.sizeForAddr(d,s.slice(a+u));a+=c+u,o.push(l)}return o},n.prototype.protoNames=function(){return this.protos().map(o=>o.name)},n.prototype.tuples=function(){return U.bytesToTuples(this.bytes)},n.prototype.stringTuples=function(){const o=U.bytesToTuples(this.bytes);return U.tuplesToStringTuples(o)},n.prototype.encapsulate=function(o){return o=n(o),n(this.toString()+o.toString())},n.prototype.decapsulate=function(o){o=o.toString();const s=this.toString(),a=s.lastIndexOf(o);if(a<0)throw new Error("Address "+this+" does not contain subaddress: "+o);return n(s.slice(0,a))},n.prototype.decapsulateCode=function(o){const s=this.tuples();for(let a=s.length-1;a>=0;a--)if(s[a][0]===o)return n(U.tuplesToBytes(s.slice(0,a)));return this},n.prototype.getPeerId=function(){let o=null;try{const s=this.stringTuples().filter(a=>{if(a[0]===z.names.ipfs.code)return!0});o=s.pop()[1],o=M(new pe(o).multihash,"base58btc")}catch(s){o=null}return o},n.prototype.getPath=function(){let o=null;try{o=this.stringTuples().filter(s=>{const a=z(s[0]);if(a.path)return!0})[0][1]}catch(s){o=null}return o},n.prototype.equals=function(o){return oe(this.bytes,o.bytes)},n.prototype.nodeAddress=function(){const o=this.protoCodes(),s=this.protoNames(),a=this.toString().split("/").slice(1);if(a.length<4)throw new Error('multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6}/{address}/{tcp, udp}/{port}".');if(o[0]!==4&&o[0]!==41&&o[0]!==54&&o[0]!==55)throw new Error(`no protocol with name: "'${s[0]}'". Must have a valid family name: "{ip4, ip6, dns4, dns6}".`);if(a[2]!=="tcp"&&a[2]!=="udp")throw new Error(`no protocol with name: "'${s[1]}'". Must have a valid transport protocol: "{tcp, udp}".`);return{family:o[0]===41||o[0]===55?6:4,address:a[1],port:parseInt(a[3])}},n.fromNodeAddress=function(o,s){if(!o)throw new Error("requires node address object");if(!s)throw new Error("requires transport protocol");let a;switch(o.family){case"IPv4":a="ip4";break;case"IPv6":a="ip6";break;default:throw Error(`Invalid addr family. Got '${o.family}' instead of 'IPv4' or 'IPv6'`)}return n("/"+[a,o.address,s,o.port].join("/"))},n.prototype.isThinWaistAddress=function(o){const s=(o||this).protos();return s.length!==2||s[0].code!==4&&s[0].code!==41?!1:!(s[1].code!==6&&s[1].code!==273)},n.protocols=z,n.isName=function(o){return n.isMultiaddr(o)?o.protos().some(s=>s.resolvable):!1},n.resolve=function(o){return!n.isMultiaddr(o)||!n.isName(o)?Promise.reject(Error("not a valid name")):Promise.reject(new Error("not implemented yet"))},t=e.exports=n});const{Buffer:$}=Z,kt=Symbol.for("BufferList");function A(e){if(!(this instanceof A))return new A(e);A._init.call(this,e)}A._init=function(t){Object.defineProperty(this,kt,{value:!0}),this._bufs=[],this.length=0,t&&this.append(t)},A.prototype._new=function(t){return new A(t)},A.prototype._offset=function(t){if(t===0)return[0,0];let r=0;for(let n=0;n<this._bufs.length;n++){const i=r+this._bufs[n].length;if(t<i||n===this._bufs.length-1)return[n,t-r];r=i}},A.prototype._reverseOffset=function(e){const t=e[0];let r=e[1];for(let n=0;n<t;n++)r+=this._bufs[n].length;return r},A.prototype.get=function(t){if(t>this.length||t<0)return;const r=this._offset(t);return this._bufs[r[0]][r[1]]},A.prototype.slice=function(t,r){return typeof t=="number"&&t<0&&(t+=this.length),typeof r=="number"&&r<0&&(r+=this.length),this.copy(null,0,t,r)},A.prototype.copy=function(t,r,n,i){if((typeof n!="number"||n<0)&&(n=0),(typeof i!="number"||i>this.length)&&(i=this.length),n>=this.length)return t||$.alloc(0);if(i<=0)return t||$.alloc(0);const o=!!t,s=this._offset(n),a=i-n;let l=a,u=o&&r||0,d=s[1];if(n===0&&i===this.length){if(!o)return this._bufs.length===1?this._bufs[0]:$.concat(this._bufs,this.length);for(let c=0;c<this._bufs.length;c++)this._bufs[c].copy(t,u),u+=this._bufs[c].length;return t}if(l<=this._bufs[s[0]].length-d)return o?this._bufs[s[0]].copy(t,r,d,d+l):this._bufs[s[0]].slice(d,d+l);o||(t=$.allocUnsafe(a));for(let c=s[0];c<this._bufs.length;c++){const f=this._bufs[c].length-d;if(l>f)this._bufs[c].copy(t,u,d),u+=f;else{this._bufs[c].copy(t,u,d,d+l),u+=f;break}l-=f,d&&(d=0)}return t.length>u?t.slice(0,u):t},A.prototype.shallowSlice=function(t,r){if(t=t||0,r=typeof r!="number"?this.length:r,t<0&&(t+=this.length),r<0&&(r+=this.length),t===r)return this._new();const n=this._offset(t),i=this._offset(r),o=this._bufs.slice(n[0],i[0]+1);return i[1]===0?o.pop():o[o.length-1]=o[o.length-1].slice(0,i[1]),n[1]!==0&&(o[0]=o[0].slice(n[1])),this._new(o)},A.prototype.toString=function(t,r,n){return this.slice(r,n).toString(t)},A.prototype.consume=function(t){if(t=Math.trunc(t),Number.isNaN(t)||t<=0)return this;for(;this._bufs.length;)if(t>=this._bufs[0].length)t-=this._bufs[0].length,this.length-=this._bufs[0].length,this._bufs.shift();else{this._bufs[0]=this._bufs[0].slice(t),this.length-=t;break}return this},A.prototype.duplicate=function(){const t=this._new();for(let r=0;r<this._bufs.length;r++)t.append(this._bufs[r]);return t},A.prototype.append=function(t){if(t==null)return this;if(t.buffer)this._appendBuffer($.from(t.buffer,t.byteOffset,t.byteLength));else if(Array.isArray(t))for(let r=0;r<t.length;r++)this.append(t[r]);else if(this._isBufferList(t))for(let r=0;r<t._bufs.length;r++)this.append(t._bufs[r]);else typeof t=="number"&&(t=t.toString()),this._appendBuffer($.from(t));return this},A.prototype._appendBuffer=function(t){this._bufs.push(t),this.length+=t.length},A.prototype.indexOf=function(e,t,r){if(r===void 0&&typeof t=="string"&&(r=t,t=void 0),typeof e=="function"||Array.isArray(e))throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.');if(typeof e=="number"?e=$.from([e]):typeof e=="string"?e=$.from(e,r):this._isBufferList(e)?e=e.slice():Array.isArray(e.buffer)?e=$.from(e.buffer,e.byteOffset,e.byteLength):$.isBuffer(e)||(e=$.from(e)),t=Number(t||0),isNaN(t)&&(t=0),t<0&&(t=this.length+t),t<0&&(t=0),e.length===0)return t>this.length?this.length:t;const n=this._offset(t);let i=n[0],o=n[1];for(;i<this._bufs.length;i++){const s=this._bufs[i];for(;o<s.length;){const a=s.length-o;if(a>=e.length){const l=s.indexOf(e,o);if(l!==-1)return this._reverseOffset([i,l]);o=s.length-e.length+1}else{const l=this._reverseOffset([i,o]);if(this._match(l,e))return l;o++}}o=0}return-1},A.prototype._match=function(e,t){if(this.length-e<t.length)return!1;for(let r=0;r<t.length;r++)if(this.get(e+r)!==t[r])return!1;return!0},function(){const e={readDoubleBE:8,readDoubleLE:8,readFloatBE:4,readFloatLE:4,readInt32BE:4,readInt32LE:4,readUInt32BE:4,readUInt32LE:4,readInt16BE:2,readInt16LE:2,readUInt16BE:2,readUInt16LE:2,readInt8:1,readUInt8:1,readIntBE:null,readIntLE:null,readUIntBE:null,readUIntLE:null};for(const t in e)(function(r){e[r]===null?A.prototype[r]=function(n,i){return this.slice(n,n+i)[r](0,i)}:A.prototype[r]=function(n){return this.slice(n,n+e[r])[r](0)}})(t)}(),A.prototype._isBufferList=function(t){return t instanceof A||A.isBufferList(t)},A.isBufferList=function(t){return t!=null&&t[kt]};var te=A;const{Buffer:Gr}=Z,Et=(e,t,r)=>{const n=R.encode(e,t,r);return Et.bytes=R.encode.bytes,t||Gr.from(n)};var Qe=Et;const{Buffer:Tt}=Z,He=8,At=10*1024;function St(e){e=e||{};const t=Math.max(e.poolSize||At,e.minPoolSize||He),r=e.lengthEncoder||Qe;return n=>async function*(){let i=Tt.alloc(t),o=0;for await(const s of n){r(s.length,i,o);const a=i.slice(o,o+r.bytes);o+=r.bytes,i.length-o<He&&(i=Tt.alloc(t),o=0),yield new te().append(a).append(s)}}()}St.single=(e,t)=>{t=t||{};const r=t.lengthEncoder||Qe;return new te([r(e.length),e])};var Ve=St,Wr=He,Yr=At;Ve.MIN_POOL_SIZE=Wr,Ve.DEFAULT_POOL_SIZE=Yr;const{Buffer:Xr}=Z,Jr=e=>new Proxy({},{get:(t,r)=>r[0]==="l"?e[r]:e.get(parseInt(r))}),qt=e=>{const t=R.decode(Xr.isBuffer(e)?e:Jr(e));return qt.bytes=R.decode.bytes,t};var Rt=qt;const{Buffer:Zr}=Z,Dt=8,Ot=1024*1024*4,Ct=Zr.alloc(0),H={LENGTH:"readLength",DATA:"readData"},en={[H.LENGTH]:(e,t,r,n)=>{t=t.append(e);let i;try{i=n.lengthDecoder(t)}catch(o){if(t.length>n.maxLengthLength)throw Object.assign(o,{message:"message length too long",code:"ERR_MSG_LENGTH_TOO_LONG"});if(o instanceof RangeError)return{mode:H.LENGTH,buffer:t};throw o}if(i>n.maxDataLength)throw Object.assign(new Error("message data too long"),{code:"ERR_MSG_DATA_TOO_LONG"});return e=t.shallowSlice(n.lengthDecoder.bytes),t=new te,n.onLength&&n.onLength(i),i<=0?(n.onData&&n.onData(Ct),{mode:H.LENGTH,chunk:e,buffer:t,data:Ct}):{mode:H.DATA,chunk:e,buffer:t,state:{dataLength:i}}},[H.DATA]:(e,t,r,n)=>{if(t=t.append(e),t.length<r.dataLength)return{mode:H.DATA,buffer:t,state:r};const{dataLength:i}=r,o=t.shallowSlice(0,i);return e=t.length>i?t.shallowSlice(i):null,t=new te,n.onData&&n.onData(o),{mode:H.LENGTH,chunk:e,buffer:t,data:o}}};function Ge(e){return e=e||{},e.lengthDecoder=e.lengthDecoder||Rt,e.maxLengthLength=e.maxLengthLength||Dt,e.maxDataLength=e.maxDataLength||Ot,t=>async function*(){let r=new te,n=H.LENGTH,i;for await(let o of t)for(;o;){const s=en[n](o,r,i,e);({mode:n,chunk:o,buffer:r,state:i}=s),s.data&&(yield s.data)}if(r.length)throw Object.assign(new Error("unexpected end of input"),{code:"ERR_UNEXPECTED_EOF"})}()}Ge.fromReader=(e,t)=>{t=t||{};let r=1;const n={[Symbol.asyncIterator](){return this},next:async()=>{try{return await e.next(r)}catch(i){if(i.code==="ERR_UNDER_READ")return{done:!0,value:null};throw i}finally{r=1}}};return t.onLength=i=>{r=i},Ge(t)(n)};var We=Ge,tn=Dt,rn=Ot;We.MAX_LENGTH_LENGTH=tn,We.MAX_DATA_LENGTH=rn;const{Buffer:nn}=Z,xt=(e,t,r)=>(t=t||nn.allocUnsafe(4),t.writeInt32BE(e,r),t);xt.bytes=4;var on=xt;const Mt=e=>{if(e.length<4)throw RangeError("Could not decode int32BE");return e.readInt32BE(0)};Mt.bytes=4;var sn=Mt,an=Ve,un=We,ln=Qe,cn=Rt,dn=on,hn=sn,re={encode:an,decode:un,varintEncode:ln,varintDecode:cn,int32BEEncode:dn,int32BEDecode:hn};const{AbortController:Nt,AbortSignal:pn}=typeof self!="undefined"?self:typeof window!="undefined"?window:void 0;var be=Nt,fn=pn,mn=Nt;be.AbortSignal=fn,be.default=mn;var Bt={createCipheriv:(e,t,r)=>{const n=fe.cipher.createCipher("AES-CTR",M(t,"ascii"));return n.start({iv:M(r,"ascii")}),{update:i=>(n.update(fe.util.createBuffer(M(i,"ascii"))),ae(n.output.getBytes(),"ascii"))}},createDecipheriv:(e,t,r)=>{const n=fe.cipher.createDecipher("AES-CTR",M(t,"ascii"));return n.start({iv:M(r,"ascii")}),{update:i=>(n.update(fe.util.createBuffer(M(i,"ascii"))),ae(n.output.getBytes(),"ascii"))}}};const Lt={16:"aes-128-ctr",32:"aes-256-ctr"};var yn=function(e){const t=Lt[e.length];if(!t){const r=Object.entries(Lt).map(([n,i])=>`${n} (${i})`).join(" / ");throw T(new Error(`Invalid key length ${e.length} bytes. Must be ${r}`),"ERR_INVALID_KEY_LENGTH")}return t},gn=async function(e,t){const r=yn(e),n=Bt.createCipheriv(r,e,t),i=Bt.createDecipheriv(r,e,t),o={async encrypt(s){return n.update(s)},async decrypt(s){return i.update(s)}};return o},vn={create:gn};const jt={sha1:"sha1","sha2-256":"sha256","sha2-512":"sha512"};function wn(e,t,r,n,i){const o=jt[i];if(!o){const a=Object.keys(jt).join(" / ");throw T(new Error(`Hash '${i}' is unknown or not supported. Must be ${a}`),"ERR_UNSUPPORTED_HASH_TYPE")}const s=vr(e,t,r,n,o);return wr.encode64(s)}var bn=wn,_n=vn,Pn=br,In=_r,kn=Pr,En=bn,Ye={aes:_n,hmac:Pn,keys:In,randomBytes:kn,pbkdf2:En};async function*Tn(e,t){let r=[];for await(const n of t)r.push(n),r.length===e&&(yield r,r=[]);r.length>0&&(yield r)}function*An(e,t){let r=[];for(const n of t)r.push(n),r.length===e&&(yield r,r=[]);r.length>0&&(yield r)}function Ut(e,t){return t===void 0?r=>Ut(e,r):t[Symbol.asyncIterator]?Tn(e,t):An(e,t)}function X(e){if(typeof e.next=="function")return e;if(typeof e[Symbol.iterator]=="function")return e[Symbol.iterator]();if(typeof e[Symbol.asyncIterator]=="function")return e[Symbol.asyncIterator]();throw new TypeError('"values" does not to conform to any of the iterator or iterable protocols')}function Xe(){let e,t;const r=new Promise((n,i)=>{t=n,e=i});return{promise:r,reject:e,resolve:t}}function Sn(e,t){const r=X(t),n=[],i=[];let o=!1,s=!1;function a(){for(;i.length>0&&n.length>0;){const c=i.shift(),{error:f,value:g}=n.shift();f?c.reject(f):c.resolve({done:!1,value:g})}for(;i.length>0&&s;){const{resolve:c}=i.shift();c({done:!0,value:void 0})}}async function l(){if(s)return;if(o)return;if(n.length>=e)return;o=!0;try{const{done:c,value:f}=await r.next();c?s=!0:n.push({value:f})}catch(c){s=!0,n.push({error:c})}a(),o=!1,l()}async function u(){if(n.length>0){const{error:f,value:g}=n.shift();if(f)throw f;return l(),{done:!1,value:g}}if(s)return{done:!0,value:void 0};const c=Xe();return i.push(c),l(),c.promise}const d={next:u,[Symbol.asyncIterator]:()=>d};return d}function*qn(e,t){const r=[];let n;try{for(const i of t){if(r.push(i),r.length<=e)continue;yield r.shift()}}catch(i){n=i}for(const i of r)yield i;if(n)throw n}function _e(e,t){return t===void 0?r=>_e(e,r):e===0?t:t[Symbol.asyncIterator]?Sn(e,t):qn(e,t)}async function Rn(e){const t=[];for await(const r of e)t.push(r);return t}function Dn(e){return e[Symbol.asyncIterator]?Rn(e):Array.from(e)}async function*On(e){for await(const t of e)yield*t}function*Cn(e){for(const t of e)yield*t}function xn(...e){const t=e.find(r=>r[Symbol.asyncIterator]!==void 0);return t?On(e):Cn(e)}async function Mn(e){for await(const t of e);}function Nn(e){if(e[Symbol.asyncIterator])return Mn(e);for(const t of e);}async function*$t(e,t){for await(const r of t)await e(r)&&(yield r)}function Pe(e,t){return t===void 0?r=>$t(e,r):$t(e,t)}async function*ce(e){for await(const t of e)t&&typeof t!="string"&&(t[Symbol.iterator]||t[Symbol.asyncIterator])?yield*ce(t):yield t}async function*Ft(e,t){for await(const r of t)yield await e(r)}function Ie(e,t){return t===void 0?r=>Ft(e,r):Ft(e,t)}function zt(e,t){return t===void 0?r=>zt(e,r):Pe(r=>r!=null,ce(Ie(e,t)))}function Bn(e,t,r){const n=X(r),i=[],o=[];let s=!1,a=!1,l=0,u=null;function d(){for(;o.length>0&&i.length>0;){const{resolve:b}=o.shift(),p=i.shift();b({done:!1,value:p})}for(;o.length>0&&l===0&&s;){const{resolve:b,reject:p}=o.shift();u?(p(u),u=null):b({done:!0,value:void 0})}}async function c(){if(s){d();return}if(a)return;if(l+i.length>=e)return;a=!0,l++;try{const{done:b,value:p}=await n.next();b?(s=!0,l--,d()):f(p)}catch(b){s=!0,l--,u=b,d()}a=!1,c()}async function f(b){try{const p=await t(b);if(p&&p[Symbol.asyncIterator])for await(const h of p)i.push(h);else i.push(p)}catch(p){s=!0,u=p}l--,d(),c()}async function g(){if(i.length===0){const p=Xe();return o.push(p),c(),p.promise}const b=i.shift();return c(),{done:!1,value:b}}const w={next:g,[Symbol.asyncIterator]:()=>w};return w}function ke(e,t,r){return t===void 0?(n,i)=>i?ke(e,n,i):ke(e,n):r===void 0?n=>ke(e,t,n):Pe(n=>n!=null,ce(Bn(e,t,r)))}async function Ln(e){return new Promise(t=>{e.once("readable",()=>{t()})})}async function*jn(e){for(;;){const t=e.read();if(t!==null){yield t;continue}if(e._readableState.ended)break;await Ln(e)}}function Un(e){return typeof e[Symbol.asyncIterator]=="function"?e:jn(e)}async function*$n(...e){const t=new Set(e.map(X));for(;t.size>0;)for(const r of t){const n=await r.next();n.done?t.delete(r):yield n.value}}function Kt(e,...t){let r=e();for(const n of t)r=n(r);return r}async function*Fn(e,t,r){let n=null;const i=l=>({value:t(l)}),o=async function*(l){for await(const u of l){if(n)return;yield u}},s=Kt(()=>r,_e(1),o,Ie(i),_e(e-1)),a=X(s);for(;;){const{value:l,done:u}=await a.next();if(u)break;try{const d=await l.value;n||(yield d)}catch(d){n=d}}if(n)throw n}function Ee(e,t,r){return t===void 0?(n,i)=>Ee(e,n,i):r===void 0?n=>Ee(e,t,n):e===1?Ie(t,r):Fn(e,t,r)}function Te(e,t,r){return t===void 0?(n,i)=>i?Te(e,n,i):Te(e,n):r===void 0?n=>Te(e,t,n):Pe(n=>n!=null,ce(Ee(e,t,r)))}async function*zn(...e){const t=e.map(X),r=new Set,n=new Map;let i=null,o=null,s=null;const a=c=>{i=c,o&&o(c)},l=c=>{s&&s(c)},u=()=>new Promise((c,f)=>{if(i&&f(i),n.size>0)return c();s=c,o=f}),d=c=>{const f=Promise.resolve(c.next()).then(async({done:g,value:w})=>{g||n.set(c,w),r.delete(f)});r.add(f),f.then(l,a)};for(const c of t)d(c);for(;;){if(r.size===0&&n.size===0)return;await u();for(const[c,f]of n)n.delete(c),yield f,d(c)}}async function Qt(e,t,r){let n=t;for await(const i of r)n=await e(n,i);return n}function Je(e,t,r){return t===void 0?(n,i)=>i?Qt(e,n,i):Je(e,n):r===void 0?n=>Je(e,t,n):Qt(e,t,r)}async function*Kn(e,t){let r=0;for await(const n of t)if(yield await n,r++,r>=e)break}function*Qn(e,t){let r=0;for(const n of t)if(yield n,r++,r>=e)break}function Ht(e,t){return t===void 0?r=>Ht(e,r):t[Symbol.asyncIterator]?Kn(e,t):Qn(e,t)}async function*Vt(e,t){for await(const r of t)await e(r),yield r}function Hn(e,t){return t===void 0?r=>Vt(e,r):Vt(e,t)}function Gt(e,t){let r=e[0]+t[0],n=e[1]+t[1];if(n>=1e9){const i=n%1e9;r+=(n-i)/1e9,n=i}return[r,n]}async function*Vn(e,t){const r=t[Symbol.asyncIterator]();let n=[0,0];for(;;){const i=W.hrtime(),{value:o,done:s}=await r.next(),a=W.hrtime(i);if(n=Gt(n,a),e.progress&&e.progress(a,n),s)return e.total&&e.total(n),o;yield o}}function*Gn(e,t){const r=t[Symbol.iterator]();let n=[0,0];for(;;){const i=W.hrtime(),{value:o,done:s}=r.next(),a=W.hrtime(i);if(n=Gt(n,a),e.progress&&e.progress(a,n),s)return e.total&&e.total(n),o;yield o}}function Wt(e={},t){return t===void 0?r=>Wt(e,r):t[Symbol.asyncIterator]!==void 0?Vn(e,t):Gn(e,t)}function Wn(e,t,r){const n=X(r),i=[],o=[];let s=!1,a=!1,l=0,u=null;function d(){for(;o.length>0&&i.length>0;){const{resolve:b}=o.shift(),p=i.shift();b({done:!1,value:p})}for(;o.length>0&&l===0&&s;){const{resolve:b,reject:p}=o.shift();u?(p(u),u=null):b({done:!0,value:void 0})}}async function c(){if(s){d();return}if(a)return;if(l+i.length>=e)return;a=!0,l++;try{const{done:b,value:p}=await n.next();b?(s=!0,l--,d()):f(p)}catch(b){s=!0,l--,u=b,d()}a=!1,c()}async function f(b){try{const p=await t(b);i.push(p)}catch(p){s=!0,u=p}l--,d(),c()}async function g(){if(i.length===0){const p=Xe();return o.push(p),c(),p.promise}const b=i.shift();return c(),{done:!1,value:b}}const w={next:g,[Symbol.asyncIterator]:()=>w};return w}function Ae(e,t,r){return t===void 0?(n,i)=>i?Ae(e,n,i):Ae(e,n):r===void 0?n=>Ae(e,t,n):Wn(e,t,r)}async function Yt(e,t){let r=null,n=null,i=null;const o=u=>{r=u,n&&n(u)},s=()=>{i&&i()},a=()=>{e.removeListener("error",o),e.removeListener("drain",s)};e.once("error",o);const l=()=>new Promise((u,d)=>{if(r)return d(r);e.once("drain",s),i=u,n=d});for await(const u of t)if(e.write(u)===!1&&await l(),r)break;if(a(),r)throw r}function Yn(e,t){return t===void 0?r=>Yt(e,r):Yt(e,t)}var Xn=Object.freeze({__proto__:null,batch:Ut,buffer:_e,collect:Dn,concat:xn,consume:Nn,filter:Pe,flatMap:zt,flatTransform:ke,flatten:ce,fromStream:Un,getIterator:X,map:Ie,merge:$n,parallelFlatMap:Te,parallelMap:Ee,parallelMerge:zn,pipeline:Kt,reduce:Je,take:Ht,tap:Hn,time:Wt,transform:Ae,writeToStream:Yn}),Xt=function(e){if(!e)throw Error("hashlru must have a max value, of type number, greater than 0");var t=0,r=Object.create(null),n=Object.create(null);function i(o,s){r[o]=s,t++,t>=e&&(t=0,n=r,r=Object.create(null))}return{has:function(o){return r[o]!==void 0||n[o]!==void 0},remove:function(o){r[o]!==void 0&&(r[o]=void 0),n[o]!==void 0&&(n[o]=void 0)},get:function(o){var s=r[o];if(s!==void 0)return s;if((s=n[o])!==void 0)return i(o,s),s},set:function(o,s){r[o]!==void 0?r[o]=s:i(o,s)},clear:function(){r=Object.create(null),n=Object.create(null)}}},Jt=Ir(Xn),Jn=(e,t)=>(t=t||(()=>{}),e.then(r=>new Promise(n=>{n(t())}).then(()=>r),r=>new Promise(n=>{n(t())}).then(()=>{throw r})));class Zt extends Error{constructor(e){super(e);this.name="TimeoutError"}}const er=(e,t,r)=>new Promise((n,i)=>{if(typeof t!="number"||t<0)throw new TypeError("Expected `milliseconds` to be a positive number");if(t===Infinity){n(e);return}const o=setTimeout(()=>{if(typeof r=="function"){try{n(r())}catch(l){i(l)}return}const s=typeof r=="string"?r:`Promise timed out after ${t} milliseconds`,a=r instanceof Error?r:new Zt(s);typeof e.cancel=="function"&&e.cancel(),i(a)},t);Jn(e.then(n,i),()=>{clearTimeout(o)})});var K=er,Zn=er,ei=Zt;K.default=Zn,K.TimeoutError=ei;const{EventEmitter:ti}=Ce;function tr(e,t){if(e===t)return!0;if(e.length!==t.length)return!1;for(let r=0,n=e.length;r<n;++r)if(e[r]!==t[r])return!1;return!0}function Ze(){return{contacts:[],dontSplit:!1,left:null,right:null}}function de(e,t){if(!(t instanceof Uint8Array))throw new TypeError(e+" is not a Uint8Array")}class et extends ti{constructor(e={}){super();this.localNodeId=e.localNodeId||Tr(20),this.numberOfNodesPerKBucket=e.numberOfNodesPerKBucket||20,this.numberOfNodesToPing=e.numberOfNodesToPing||3,this.distance=e.distance||et.distance,this.arbiter=e.arbiter||et.arbiter,this.metadata=Object.assign({},e.metadata),de("option.localNodeId as parameter 1",this.localNodeId),this.root=Ze()}static arbiter(e,t){return e.vectorClock>t.vectorClock?e:t}static distance(e,t){let r=0,n=0;const i=Math.min(e.length,t.length),o=Math.max(e.length,t.length);for(;n<i;++n)r=r*256+(e[n]^t[n]);for(;n<o;++n)r=r*256+255;return r}add(e){de("contact.id",(e||{}).id);let t=0,r=this.root;for(;r.contacts===null;)r=this._determineNode(r,e.id,t++);const n=this._indexOf(r,e.id);return n>=0?(this._update(r,n,e),this):r.contacts.length<this.numberOfNodesPerKBucket?(r.contacts.push(e),this.emit("added",e),this):r.dontSplit?(this.emit("ping",r.contacts.slice(0,this.numberOfNodesToPing),e),this):(this._split(r,t),this.add(e))}closest(e,t=Infinity){if(de("id",e),!Number.isInteger(t)&&t!==Infinity||t<=0)throw new TypeError("n is not positive number");let r=[];for(let n=[this.root],i=0;n.length>0&&r.length<t;){const o=n.pop();if(o.contacts===null){const s=this._determineNode(o,e,i++);n.push(o.left===s?o.right:o.left),n.push(s)}else r=r.concat(o.contacts)}return r.map(n=>[this.distance(n.id,e),n]).sort((n,i)=>n[0]-i[0]).slice(0,t).map(n=>n[1])}count(){let e=0;for(const t=[this.root];t.length>0;){const r=t.pop();r.contacts===null?t.push(r.right,r.left):e+=r.contacts.length}return e}_determineNode(e,t,r){const n=r>>3,i=r%8;if(t.length<=n&&i!==0)return e.left;const o=t[n];return o&1<<7-i?e.right:e.left}get(e){de("id",e);let t=0,r=this.root;for(;r.contacts===null;)r=this._determineNode(r,e,t++);const n=this._indexOf(r,e);return n>=0?r.contacts[n]:null}_indexOf(e,t){for(let r=0;r<e.contacts.length;++r)if(tr(e.contacts[r].id,t))return r;return-1}remove(e){de("the id as parameter 1",e);let t=0,r=this.root;for(;r.contacts===null;)r=this._determineNode(r,e,t++);const n=this._indexOf(r,e);if(n>=0){const i=r.contacts.splice(n,1)[0];this.emit("removed",i)}return this}_split(e,t){e.left=Ze(),e.right=Ze();for(const i of e.contacts)this._determineNode(e,i.id,t).contacts.push(i);e.contacts=null;const r=this._determineNode(e,this.localNodeId,t),n=e.left===r?e.right:e.left;n.dontSplit=!0}toArray(){let e=[];for(const t=[this.root];t.length>0;){const r=t.pop();r.contacts===null?t.push(r.right,r.left):e=e.concat(r.contacts)}return e}_update(e,t,r){if(!tr(e.contacts[t].id,r.id))throw new Error("wrong index for _update");const n=e.contacts[t],i=this.arbiter(n,r);if(i===n&&n!==r)return;e.contacts.splice(t,1),e.contacts.push(i),this.emit("updated",n,i)}}var ri=et,J=V;function V(e,t){if(e.length!==t.length)throw new Error("Inputs should have the same length");for(var r=Buffer.allocUnsafe(e.length),n=0;n<e.length;n++)r[n]=e[n]^t[n];return r}V.compare=function(t,r){if(t.length!==r.length)throw new Error("Inputs should have the same length");for(var n=0;n<t.length;n++){if(t[n]===r[n])continue;return t[n]<r[n]?-1:1}return 0},V.gt=function(t,r){return V.compare(t,r)===1},V.lt=function(t,r){return V.compare(t,r)===-1},V.eq=function(t,r){return V.compare(t,r)===0};var rr=async(e,t,{concurrency:r=Infinity,stopOnError:n=!0}={})=>new Promise((i,o)=>{if(typeof t!="function")throw new TypeError("Mapper function is required");if(!((Number.isSafeInteger(r)||r===Infinity)&&r>=1))throw new TypeError(`Expected \`concurrency\` to be an integer from 1 and up or \`Infinity\`, got \`${r}\` (${typeof r})`);const s=[],a=[],l=e[Symbol.iterator]();let u=!1,d=!1,c=0,f=0;const g=()=>{if(u)return;const w=l.next(),b=f;if(f++,w.done){d=!0,c===0&&(!n&&a.length!==0?o(new Be(a)):i(s));return}c++,(async()=>{try{const p=await w.value;s[b]=await t(p,b),c--,g()}catch(p){n?(u=!0,o(p)):(a.push(p),c--,g())}})()};for(let w=0;w<r&&!(g(),d);w++);}),P=x(function(e,t){const r=se.multihash,{Key:n}=Ne,{Record:i}=F;t.convertBuffer=o=>se.digest(o,"sha2-256"),t.convertPeerId=o=>se.digest(o.id,"sha2-256"),t.bufferToKey=o=>new n("/"+t.encodeBase32(o),!1),t.keyForPublicKey=o=>Y([ae("/pk/"),o.id]),t.isPublicKeyKey=o=>M(o.slice(0,4))==="/pk/",t.fromPublicKeyKey=o=>new G(o.slice(4)),t.now=()=>Date.now(),t.encodeBase32=o=>{const s=new ot.Encoder;return s.write(o).finalize()},t.decodeBase32=o=>{const s=new ot.Decoder;return Uint8Array.from(s.write(o).finalize())},t.sortClosestPeers=async(o,s)=>{const a=await rr(o,async l=>{const u=await t.convertPeerId(l);return{peer:l,distance:J(u,s)}});return a.sort(t.xorCompare).map(l=>l.peer)},t.xorCompare=(o,s)=>J.compare(o.distance,s.distance),t.pathSize=(o,s)=>Math.ceil(o/s),t.createPutRecord=(o,s)=>{const a=new Date,l=new i(o,s,a);return l.serialize()},t.logger=(o,s)=>{const a=["libp2p","dht"];s&&a.push(s),o&&a.push(`${o.toB58String().slice(0,8)}`),me.formatters.b=u=>r.toB58String(u);const l=me(a.join(":"));return l.error=me(a.concat(["error"]).join(":")),l},t.TimeoutError=class extends Error{get code(){return"ETIMEDOUT"}},t.withTimeout=(o,s)=>async(...a)=>Promise.race([o(...a),new Promise((l,u)=>{setTimeout(()=>{u(T(new Error("Async function did not complete before timeout"),"ETIMEDOUT"))},s)})]),t.mapParallel=async function(o,s){const a=[];for await(const l of o)a.push(s(l));return Promise.all(a)}});class ni{constructor(e,t){this.self=e,this._onPing=this._onPing.bind(this),this._onInit(t)}async _onInit(e){const t=await P.convertPeerId(this.self);this.kb=new ri({localNodeId:t,numberOfNodesPerKBucket:e,numberOfNodesToPing:1}),this.kb.on("ping",this._onPing)}_onPing(e,t){const r=e[0];this.kb.remove(r.id),this.kb.add(t)}get size(){return this.kb.count()}async find(e){const t=await P.convertPeerId(e),r=this.closestPeer(t);if(r&&r.isEqual(e))return r}closestPeer(e){const t=this.closestPeers(e,1);if(t.length>0)return t[0]}closestPeers(e,t){return this.kb.closest(e,t).map(r=>r.peer)}async add(e){const t=await P.convertPeerId(e);this.kb.add({id:t,peer:e})}async remove(e){const t=await P.convertPeerId(e);this.kb.remove(t)}}var ii=ni,C=x(function(e,t){const r=t.second=1e3,n=t.minute=60*r,i=t.hour=60*n;t.MAX_RECORD_AGE=36*i,t.PROTOCOL_DHT="/kad/1.0.0",t.PROVIDERS_KEY_PREFIX="/providers/",t.PROVIDERS_LRU_CACHE_SIZE=256,t.PROVIDERS_VALIDITY=24*i,t.PROVIDERS_CLEANUP_INTERVAL=i,t.READ_MESSAGE_TIMEOUT=10*r,t.GET_MANY_RECORD_COUNT=16,t.K=20,t.ALPHA=3,t.defaultRandomWalk={enabled:!0,queriesPerPeriod:1,interval:5*n,timeout:10*r,delay:10*r}});const nr=()=>{};class oi{constructor({min:e=0,max:t=Infinity,handlers:r={}}){this.min=e,this.max=t,this._onConnect=r.onConnect||nr,this._onDisconnect=r.onDisconnect||nr,this.peers=new Set}set registrar(e){this._registrar=e}disconnect(e){this._onDisconnect(e)}}var si=Me(oi,{className:"Topology",symbolName:"@libp2p/js-interfaces/topology"});class ai extends si{constructor({min:e,max:t,multicodecs:r,handlers:n}){super({min:e,max:t,handlers:n});if(!r)throw new Error("one or more multicodec should be provided");if(!n)throw new Error("the handlers should be provided");if(typeof n.onConnect!="function")throw new Error("the 'onConnect' handler must be provided");if(typeof n.onDisconnect!="function")throw new Error("the 'onDisconnect' handler must be provided");this.multicodecs=Array.isArray(r)?r:[r],this._registrar=void 0,this._onProtocolChange=this._onProtocolChange.bind(this),this._onPeerConnect=this._onPeerConnect.bind(this)}set registrar(e){this._registrar=e,this._registrar.peerStore.on("change:protocols",this._onProtocolChange),this._registrar.connectionManager.on("peer:connect",this._onPeerConnect),this._updatePeers(this._registrar.peerStore.peers.values())}_updatePeers(e){for(const{id:t,protocols:r}of e)if(this.multicodecs.filter(n=>r.includes(n)).length){this.peers.add(t.toB58String());const n=this._registrar.getConnection(t);n&&this._onConnect(t,n)}else this.peers.delete(t.toB58String())}_onProtocolChange({peerId:e,protocols:t}){const r=this.peers.has(e.toB58String()),n=t.filter(i=>this.multicodecs.includes(i));r&&n.length===0&&this._onDisconnect(e);for(const i of t)if(this.multicodecs.includes(i)){const o=this._registrar.peerStore.get(e);this._updatePeers([o]);return}}_onPeerConnect(e){const t=e.remotePeer,r=this._registrar.peerStore.protoBook.get(t);if(!r)return;this.multicodecs.find(n=>r.includes(n))&&(this.peers.add(t.toB58String()),this._onConnect(t,e))}}var ui=Me(ai,{className:"MulticodecTopology",symbolName:"@libp2p/js-interfaces/topology/multicodec-topology"}),li=`// can't use, because protocol-buffers doesn't support imports
// so we have to duplicate for now :(
// import "record.proto";

message Record {
  // adjusted for javascript
  optional bytes key = 1;
  optional bytes value = 2;
  optional bytes author = 3;
  optional bytes signature = 4;
  optional string timeReceived = 5;
}

message Message {
  enum MessageType {
    PUT_VALUE = 0;
    GET_VALUE = 1;
    ADD_PROVIDER = 2;
    GET_PROVIDERS = 3;
    FIND_NODE = 4;
    PING = 5;
  }

  enum ConnectionType {
    // sender does not have a connection to peer, and no extra information (default)
    NOT_CONNECTED = 0;

    // sender has a live connection to peer
    CONNECTED = 1;

    // sender recently connected to peer
    CAN_CONNECT = 2;

    // sender recently tried to connect to peer repeatedly but failed to connect
    // ("try" here is loose, but this should signal "made strong effort, failed")
    CANNOT_CONNECT = 3;
  }

  message Peer {
    // ID of a given peer.
    optional bytes id = 1;

    // multiaddrs for a given peer
    repeated bytes addrs = 2;

    // used to signal the sender's connection capabilities to the peer
    optional ConnectionType connection = 3;
  }

  // defines what type of message it is.
  optional MessageType type = 1;

  // defines what coral cluster level this query/response belongs to.
  // in case we want to implement coral's cluster rings in the future.
  optional int32 clusterLevelRaw = 10;

  // Used to specify the key associated with this message.
  // PUT_VALUE, GET_VALUE, ADD_PROVIDER, GET_PROVIDERS
  // adjusted for javascript
  optional bytes key = 2;

  // Used to return a value
  // PUT_VALUE, GET_VALUE
  // adjusted Record to bytes for js
  optional bytes record = 3;

  // Used to return peers closer to a key in a query
  // GET_VALUE, GET_PROVIDERS, FIND_NODE
  repeated Peer closerPeers = 8;

  // Used to return Providers
  // GET_VALUE, ADD_PROVIDER, GET_PROVIDERS
  repeated Peer providerPeers = 9;
}`;const{Record:ci}=F,Se=Er(li),di=Se.Message.MessageType,ir=Se.Message.ConnectionType;class qe{constructor(e,t,r){if(t&&!(t instanceof Uint8Array))throw new Error("Key must be a Uint8Array");this.type=e,this.key=t,this._clusterLevelRaw=r,this.closerPeers=[],this.providerPeers=[],this.record=null}get clusterLevel(){const e=this._clusterLevelRaw-1;return e<0?0:e}set clusterLevel(e){this._clusterLevelRaw=e}serialize(){const e={key:this.key,type:this.type,clusterLevelRaw:this._clusterLevelRaw,closerPeers:this.closerPeers.map(or),providerPeers:this.providerPeers.map(or)};return this.record&&(this.record instanceof Uint8Array?e.record=this.record:e.record=this.record.serialize()),Se.Message.encode(e)}static deserialize(e){const t=Se.Message.decode(e),r=new qe(t.type,t.key,t.clusterLevelRaw);return r.closerPeers=t.closerPeers.map(sr),r.providerPeers=t.providerPeers.map(sr),t.record&&(r.record=ci.deserialize(t.record)),r}}qe.TYPES=di,qe.CONNECTION_TYPES=ir;function or(e){return{id:e.id.id,addrs:(e.multiaddrs||[]).map(t=>t.bytes),connection:ir.CONNECTED}}function sr(e){return{id:new G(e.id),multiaddrs:e.addrs.map(t=>It(t))}}var D=qe;const{Record:hi}=F;var pi=e=>{const t=P.logger(e.peerId,"rpc:get-value");return async function(n,i){const o=i.key;if(t("key: %b",o),!o||o.length===0)throw T(new Error("Invalid key"),"ERR_INVALID_KEY");const s=new D(D.TYPES.GET_VALUE,o,i.clusterLevel);if(P.isPublicKeyKey(o)){t("is public key");const u=P.fromPublicKeyKey(o);let d;if(e._isSelf(u))d=e.peerId;else{const c=e.peerStore.get(u);d=c&&c.id}if(d&&d.pubKey)return t("returning found public key"),s.record=new hi(o,d.pubKey.bytes),s}const[a,l]=await Promise.all([e._checkLocalDatastore(o),e._betterPeersToQuery(i,n)]);return a&&(t("got record"),s.record=a),l.length>0&&(t("got closer %s",l.length),s.closerPeers=l),s}},fi=e=>{const t=P.logger(e.peerId,"rpc:put-value");return async function(n,i){const o=i.key;t("key: %b",o);const s=i.record;if(!s){const l=`Empty record from: ${n.toB58String()}`;throw t.error(l),T(new Error(l),"ERR_EMPTY_RECORD")}await e._verifyRecordLocally(s),s.timeReceived=new Date;const a=P.bufferToKey(s.key);return await e.datastore.put(a,s.serialize()),e.onPut(s,n),i}},mi=e=>{const t=P.logger(e.peerId,"rpc:find-node");return async function(n,i){t("start");let o;oe(i.key,e.peerId.id)?o=[{id:e.peerId}]:o=await e._betterPeersToQuery(i,n);const s=new D(i.type,new Uint8Array(0),i.clusterLevel);return o.length>0?s.closerPeers=o:t("handle FindNode %s: could not find anything",n.toB58String()),s}},yi=e=>{const t=P.logger(e.peerId,"rpc:add-provider");return async function(n,i){if(t("start"),!i.key||i.key.length===0)throw T(new Error("Missing key"),"ERR_MISSING_KEY");let o;try{o=new pe(i.key)}catch(s){const a=`Invalid CID: ${s.message}`;throw T(new Error(a),"ERR_INVALID_CID")}return i.providerPeers.forEach(s=>{if(!s.id.isEqual(n)){t("invalid provider peer %s from %s",s.id.toB58String(),n.toB58String());return}if(s.multiaddrs.length<1){t("no valid addresses for provider %s. Ignore",n.toB58String());return}if(t("received provider %s for %s (addrs %s)",n.toB58String(),o.toBaseEncodedString(),s.multiaddrs.map(a=>a.toString())),!e._isSelf(s.id))return e.peerStore.addressBook.add(s.id,s.multiaddrs),e.providers.addProvider(o,s.id)}),e.providers.addProvider(o,n)}},gi=e=>{const t=P.logger(e.peerId,"rpc:get-providers");return async function(n,i){let o;try{o=new pe(i.key)}catch(g){throw T(new Error(`Invalid CID: ${g.message}`),"ERR_INVALID_CID")}t("%s",o.toBaseEncodedString());const s=P.bufferToKey(o.bytes),[a,l,u]=await Promise.all([e.datastore.has(s),e.providers.getProviders(o),e._betterPeersToQuery(i,n)]),d=l.map(g=>({id:g})),c=u.map(g=>({id:g.id}));a&&d.push({id:e.peerId});const f=new D(i.type,i.key,i.clusterLevel);return d.length>0&&(f.providerPeers=d),c.length>0&&(f.closerPeers=c),t("got %s providers %s closerPeers",d.length,c.length),f}},vi=e=>{const t=P.logger(e.peerId,"rpc:ping");return function(n,i){return t("from %s",n.toB58String()),i}};const ne=D.TYPES;var wi=e=>{const t={[ne.GET_VALUE]:pi(e),[ne.PUT_VALUE]:fi(e),[ne.FIND_NODE]:mi(e),[ne.ADD_PROVIDER]:yi(e),[ne.GET_PROVIDERS]:gi(e),[ne.PING]:vi(e)};return function(n){return t[n]}},bi=e=>{const t=P.logger(e.peerId,"rpc"),r=wi(e);async function n(i,o){const s=r(o.type);try{await e._add(i)}catch(a){t.error("Failed to update the kbucket store",a)}if(!s){t.error(`no handler found for message type: ${o.type}`);return}return s(i,o)}return async function({stream:o,connection:s}){const a=s.remotePeer;try{await e._add(a)}catch(u){t.error(u)}const l=a.toB58String();t("from: %s",l),await xe(o.source,re.decode(),u=>async function*(){for await(const d of u){const c=D.deserialize(d.slice()),f=await n(a,c);f&&(yield f.serialize())}}(),re.encode(),o.sink)}};const{consume:_i}=Jt;class Pi{constructor(e){this.dht=e,this.readMessageTimeout=C.READ_MESSAGE_TIMEOUT,this._log=P.logger(this.dht.peerId,"net"),this._rpc=bi(this.dht),this._onPeerConnected=this._onPeerConnected.bind(this),this._running=!1}async start(){if(this._running)return;if(!this.dht.isStarted)throw T(new Error("Can not start network"),"ERR_CANNOT_START_NETWORK");this._running=!0,this.dht._clientMode===!1&&this.dht.registrar.handle(this.dht.protocol,this._rpc);const e=new ui({multicodecs:[this.dht.protocol],handlers:{onConnect:this._onPeerConnected,onDisconnect:()=>{}}});this._registrarId=await this.dht.registrar.register(e)}async stop(){if(!this.dht.isStarted&&!this.isStarted)return;this._running=!1,await this.dht.registrar.unregister(this._registrarId)}get isStarted(){return this._running}get isConnected(){return this.dht.isStarted&&this.isStarted}async _onPeerConnected(e){await this.dht._add(e),this._log("added to the routing table: %s",e.toB58String())}async sendRequest(e,t){if(!this.isConnected)throw T(new Error("Network is offline"),"ERR_NETWORK_OFFLINE");const r=e.toB58String();this._log("sending to: %s",r);let n=this.dht.registrar.connectionManager.get(e);n||(n=await this.dht.dialer.connectToPeer(e));const{stream:i}=await n.newStream(this.dht.protocol);return this._writeReadMessage(i,t.serialize())}async sendMessage(e,t){if(!this.isConnected)throw T(new Error("Network is offline"),"ERR_NETWORK_OFFLINE");const r=e.toB58String();this._log("sending to: %s",r);let n=this.dht.registrar.connectionManager.get(e);n||(n=await this.dht.dialer.connectToPeer(e));const{stream:i}=await n.newStream(this.dht.protocol);return this._writeMessage(i,t.serialize())}async _writeReadMessage(e,t){return K(Ii(e,t),this.readMessageTimeout)}_writeMessage(e,t){return xe([t],re.encode(),e,_i)}}async function Ii(e,t){const r=await xe([t],re.encode(),e,re.decode(),async n=>{for await(const i of n)return i.slice()});if(r.length===0)throw T(new Error("No message received"),"ERR_NO_MESSAGE_RECEIVED");return D.deserialize(r)}var ki=Pi;class Ei{constructor(e,t){this.originDhtKey=e,this.capacity=t,this.peerDistances=[]}get length(){return this.peerDistances.length}get peers(){return this.peerDistances.map(e=>e.peerId)}async add(e){if(this.peerDistances.find(n=>oe(n.peerId.id,e.id)))return;const t=await P.convertPeerId(e),r={peerId:e,distance:J(this.originDhtKey,t)};this.peerDistances.push(r),this.peerDistances.sort((n,i)=>J.compare(n.distance,i.distance)),this.peerDistances=this.peerDistances.slice(0,this.capacity)}async anyCloser(e){if(!e.length)return!1;if(!this.length)return!0;const t=await rr(e,n=>P.convertPeerId(n)),r=this.peerDistances[this.peerDistances.length-1].distance;for(const n of t){const i=J(this.originDhtKey,n);if(J.compare(i,r)<0)return!0}return!1}}var Ti=Ei,Ai=x(function(e,t){(function(){var r,n,i,o,s,a,l,u,d,c,f,g,w,b,p;i=Math.floor,c=Math.min,n=function(h,y){return h<y?-1:h>y?1:0},d=function(h,y,m,_,v){var I;if(m==null&&(m=0),v==null&&(v=n),m<0)throw new Error("lo must be non-negative");for(_==null&&(_=h.length);m<_;)I=i((m+_)/2),v(y,h[I])<0?_=I:m=I+1;return[].splice.apply(h,[m,m-m].concat(y)),y},a=function(h,y,m){return m==null&&(m=n),h.push(y),b(h,0,h.length-1,m)},s=function(h,y){var m,_;return y==null&&(y=n),m=h.pop(),h.length?(_=h[0],h[0]=m,p(h,0,y)):_=m,_},u=function(h,y,m){var _;return m==null&&(m=n),_=h[0],h[0]=y,p(h,0,m),_},l=function(h,y,m){var _;return m==null&&(m=n),h.length&&m(h[0],y)<0&&(_=[h[0],y],y=_[0],h[0]=_[1],p(h,0,m)),y},o=function(h,y){var m,_,v,I,k,E;for(y==null&&(y=n),I=function(){E=[];for(var S=0,O=i(h.length/2);0<=O?S<O:S>O;0<=O?S++:S--)E.push(S);return E}.apply(this).reverse(),k=[],_=0,v=I.length;_<v;_++)m=I[_],k.push(p(h,m,y));return k},w=function(h,y,m){var _;return m==null&&(m=n),_=h.indexOf(y),_===-1?void 0:(b(h,0,_,m),p(h,_,m))},f=function(h,y,m){var _,v,I,k,E;if(m==null&&(m=n),v=h.slice(0,y),!v.length)return v;for(o(v,m),E=h.slice(y),I=0,k=E.length;I<k;I++)_=E[I],l(v,_,m);return v.sort(m).reverse()},g=function(h,y,m){var _,v,I,k,E,S,O,B,ie,Oe;if(m==null&&(m=n),y*10<=h.length){if(k=h.slice(0,y).sort(m),!k.length)return k;for(I=k[k.length-1],B=h.slice(y),E=0,O=B.length;E<O;E++)_=B[E],m(_,I)<0&&(d(k,_,0,null,m),k.pop(),I=k[k.length-1]);return k}for(o(h,m),Oe=[],v=S=0,ie=c(y,h.length);0<=ie?S<ie:S>ie;v=0<=ie?++S:--S)Oe.push(s(h,m));return Oe},b=function(h,y,m,_){var v,I,k;for(_==null&&(_=n),v=h[m];m>y;){if(k=m-1>>1,I=h[k],_(v,I)<0){h[m]=I,m=k;continue}break}return h[m]=v},p=function(h,y,m){var _,v,I,k,E;for(m==null&&(m=n),v=h.length,E=y,I=h[y],_=2*y+1;_<v;)k=_+1,k<v&&!(m(h[_],h[k])<0)&&(_=k),h[y]=h[_],y=_,_=2*y+1;return h[y]=I,b(h,E,y,m)},r=function(){h.push=a,h.pop=s,h.replace=u,h.pushpop=l,h.heapify=o,h.updateItem=w,h.nlargest=f,h.nsmallest=g;function h(y){this.cmp=y??n,this.nodes=[]}return h.prototype.push=function(y){return a(this.nodes,y,this.cmp)},h.prototype.pop=function(){return s(this.nodes,this.cmp)},h.prototype.peek=function(){return this.nodes[0]},h.prototype.contains=function(y){return this.nodes.indexOf(y)!==-1},h.prototype.replace=function(y){return u(this.nodes,y,this.cmp)},h.prototype.pushpop=function(y){return l(this.nodes,y,this.cmp)},h.prototype.heapify=function(){return o(this.nodes,this.cmp)},h.prototype.updateItem=function(y){return w(this.nodes,y,this.cmp)},h.prototype.clear=function(){return this.nodes=[]},h.prototype.empty=function(){return this.nodes.length===0},h.prototype.size=function(){return this.nodes.length},h.prototype.clone=function(){var y;return y=new h,y.nodes=this.nodes.slice(0),y},h.prototype.toArray=function(){return this.nodes.slice(0)},h.prototype.insert=h.prototype.push,h.prototype.top=h.prototype.peek,h.prototype.front=h.prototype.peek,h.prototype.has=h.prototype.contains,h.prototype.copy=h.prototype.clone,h}(),function(h,y){return e.exports=y()}(this,function(){return r})}).call(kr)}),Si=Ai;const tt=me("libp2p:dht:peer-queue");class rt{static async fromPeerId(e){const t=await P.convertPeerId(e);return new rt(t)}static async fromKey(e){const t=await P.convertBuffer(e);return new rt(t)}constructor(e){tt("create: %b",e),this.from=e,this.heap=new Si(P.xorCompare)}async enqueue(e){tt("enqueue %s",e.toB58String());const t=await P.convertPeerId(e),r={id:e,distance:J(this.from,t)};this.heap.push(r)}dequeue(){const e=this.heap.pop();return tt("dequeue %s",e.id.toB58String()),e.id}get length(){return this.heap.size()}}var qi=rt;const Ri=3e4;class Di{constructor(e,t){if(this.run=e,this.queryFunc=P.withTimeout(t,Ri),!this.queryFunc)throw new Error("Path requires a `queryFn` to be specified");if(typeof this.queryFunc!="function")throw new Error("Path expected `queryFn` to be a function. Got "+typeof this.queryFunc);this.initialPeers=[],this.peersToQuery=null}addInitialPeer(e){this.initialPeers.push(e)}async execute(){const e=await qi.fromKey(this.run.query.key);this.peersToQuery=e,await Promise.all(this.initialPeers.map(t=>this.addPeerToQuery(t))),await this.run.workerQueue(this)}async addPeerToQuery(e){if(this.run.query.dht._isSelf(e))return;if(this.run.peersSeen.has(e.toB58String()))return;await this.peersToQuery.enqueue(e)}}var Oi=Di;function Ci(e,t,r,n){for(var i=e.length,o=r+(n?1:-1);n?o--:++o<i;)if(t(e[o],o,e))return o;return-1}var xi=Ci;function Mi(e){return e!==e}var Ni=Mi;function Bi(e,t,r){for(var n=r-1,i=e.length;++n<i;)if(e[n]===t)return n;return-1}var Li=Bi;function ji(e,t,r){return t===t?Li(e,t,r):xi(e,Ni,r)}var Ui=ji,$i=Array.isArray,Fi=$i;function zi(){}var Ki=zi,Qi=x(function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=r;function r(n){return function(){if(n===null)throw new Error("Callback was already called.");var i=n;n=null,i.apply(this,arguments)}}e.exports=t.default}),ar=x(function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=r;function r(n,i){i=i|0;for(var o=Math.max(n.length-i,0),s=Array(o),a=0;a<o;a++)s[a]=n[i+a];return s}e.exports=t.default}),ur=x(function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.hasNextTick=t.hasSetImmediate=void 0,t.fallback=s,t.wrap=a;var r=n(ar);function n(u){return u&&u.__esModule?u:{default:u}}var i=t.hasSetImmediate=typeof setImmediate=="function"&&setImmediate,o=t.hasNextTick=typeof W=="object"&&typeof W.nextTick=="function";function s(u){setTimeout(u,0)}function a(u){return function(d){var c=(0,r.default)(arguments,1);u(function(){d.apply(null,c)})}}var l;i?l=setImmediate:o?l=W.nextTick:l=s,t.default=a(l)}),Hi=x(function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=r;function r(){this.head=this.tail=null,this.length=0}function n(i,o){i.length=1,i.head=i.tail=o}r.prototype.removeLink=function(i){return i.prev?i.prev.next=i.next:this.head=i.next,i.next?i.next.prev=i.prev:this.tail=i.prev,i.prev=i.next=null,this.length-=1,i},r.prototype.empty=function(){for(;this.head;)this.shift();return this},r.prototype.insertAfter=function(i,o){o.prev=i,o.next=i.next,i.next?i.next.prev=o:this.tail=o,i.next=o,this.length+=1},r.prototype.insertBefore=function(i,o){o.prev=i.prev,o.next=i,i.prev?i.prev.next=o:this.head=o,i.prev=o,this.length+=1},r.prototype.unshift=function(i){this.head?this.insertBefore(this.head,i):n(this,i)},r.prototype.push=function(i){this.tail?this.insertAfter(this.tail,i):n(this,i)},r.prototype.shift=function(){return this.head&&this.removeLink(this.head)},r.prototype.pop=function(){return this.tail&&this.removeLink(this.tail)},r.prototype.toArray=function(){for(var i=Array(this.length),o=this.head,s=0;s<this.length;s++)i[s]=o.data,o=o.next;return i},r.prototype.remove=function(i){for(var o=this.head;o;){var s=o.next;i(o)&&this.removeLink(o),o=s}return this},e.exports=t.default});function Vi(e){var t=typeof e;return e!=null&&(t=="object"||t=="function")}var Gi=Vi,Wi=x(function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(i){return function(){var o=(0,r.default)(arguments),s=o.pop();i.call(this,o,s)}};var r=n(ar);function n(i){return i&&i.__esModule?i:{default:i}}e.exports=t.default}),Yi=x(function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=s;var r=o(Gi),n=o(Wi),i=o(ur);function o(u){return u&&u.__esModule?u:{default:u}}function s(u){return(0,n.default)(function(d,c){var f;try{f=u.apply(this,d)}catch(g){return c(g)}(0,r.default)(f)&&typeof f.then=="function"?f.then(function(g){a(c,null,g)},function(g){a(c,g.message?g:new Error(g))}):c(null,f)})}function a(u,d,c){try{u(d,c)}catch(f){(0,i.default)(l,f)}}function l(u){throw u}e.exports=t.default}),lr=x(function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.isAsync=void 0;var r=n(Yi);function n(a){return a&&a.__esModule?a:{default:a}}var i=typeof Symbol=="function";function o(a){return i&&a[Symbol.toStringTag]==="AsyncFunction"}function s(a){return o(a)?(0,r.default)(a):a}t.default=s,t.isAsync=o}),Xi=x(function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=d;var r=u(Ui),n=u(Fi),i=u(Ki),o=u(Qi),s=u(ur),a=u(Hi),l=u(lr);function u(c){return c&&c.__esModule?c:{default:c}}function d(c,f,g){if(f==null)f=1;else if(f===0)throw new Error("Concurrency must not be zero");var w=(0,l.default)(c),b=0,p=[],h=!1;function y(I,k,E){if(E!=null&&typeof E!="function")throw new Error("task callback must be a function");if(v.started=!0,(0,n.default)(I)||(I=[I]),I.length===0&&v.idle())return(0,s.default)(function(){v.drain()});for(var S=0,O=I.length;S<O;S++){var B={data:I[S],callback:E||i.default};k?v._tasks.unshift(B):v._tasks.push(B)}h||(h=!0,(0,s.default)(function(){h=!1,v.process()}))}function m(I){return function(k){b-=1;for(var E=0,S=I.length;E<S;E++){var O=I[E],B=(0,r.default)(p,O,0);B===0?p.shift():B>0&&p.splice(B,1),O.callback.apply(O,arguments),k!=null&&v.error(k,O.data)}b<=v.concurrency-v.buffer&&v.unsaturated(),v.idle()&&v.drain(),v.process()}}var _=!1,v={_tasks:new a.default,concurrency:f,payload:g,saturated:i.default,unsaturated:i.default,buffer:f/4,empty:i.default,drain:i.default,error:i.default,started:!1,paused:!1,push:function(I,k){y(I,!1,k)},kill:function(){v.drain=i.default,v._tasks.empty()},unshift:function(I,k){y(I,!0,k)},remove:function(I){v._tasks.remove(I)},process:function(){if(_)return;for(_=!0;!v.paused&&b<v.concurrency&&v._tasks.length;){var I=[],k=[],E=v._tasks.length;v.payload&&(E=Math.min(E,v.payload));for(var S=0;S<E;S++){var O=v._tasks.shift();I.push(O),p.push(O),k.push(O.data)}b+=1,v._tasks.length===0&&v.empty(),b===v.concurrency&&v.saturated();var B=(0,o.default)(m(I));w(k,B)}_=!1},length:function(){return v._tasks.length},running:function(){return b},workersList:function(){return p},idle:function(){return v._tasks.length+b===0},pause:function(){v.paused=!0},resume:function(){if(v.paused===!1)return;v.paused=!1,(0,s.default)(v.process)}};return v}e.exports=t.default}),Ji=x(function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(o,s){var a=(0,n.default)(o);return(0,r.default)(function(l,u){a(l[0],u)},s,1)};var r=i(Xi),n=i(lr);function i(o){return o&&o.__esModule?o:{default:o}}e.exports=t.default}),Zi=Object.prototype.toString,eo=function(e){return Zi.call(e)==="[object Function]"},cr=typeof setImmediate=="function"?setImmediate:function(){var t=[].slice.apply(arguments);t.splice(1,0,0),setTimeout.apply(null,t)},to=function(e){if(!eo(e.then))throw new TypeError("Expected a promise");return function(t){e.then(function(r){cr(t,null,r)},function(r){cr(t,r)})}};class ro{constructor(e,t,r,n){this.dht=e,this.run=t,this.path=r,this.log=n,this.concurrency=this.dht.concurrency,this.queue=this.setupQueue(),this.execution=null}setupQueue(){const e=Ji((t,r)=>{to(this.processNext(t))(r)},this.concurrency);return e.error=t=>{this.log.error("queue",t),this.stop(t)},e.drain=()=>{this.log("queue:drain"),this.stop()},e.unsaturated=()=>{this.running&&this.fill()},e.buffer=0,e}stop(e){if(!this.running)return;this.running=!1,this.queue.kill(),this.log("worker:stop, %d workers still running",this.run.workers.filter(t=>t.running).length),e?this.execution.reject(e):this.execution.resolve()}async execute(){this.running=!0,this.execution={};const e=new Promise((t,r)=>Object.assign(this.execution,{resolve:t,reject:r}));this.fill(),await e}fill(){for(;this.queue.running()+this.queue.length()<this.concurrency&&this.path.peersToQuery.length>0;)this.queue.push(this.path.peersToQuery.dequeue())}async processNext(e){if(!this.running)return;if(this.run.peersSeen.has(e.toB58String()))return;let t,r;try{t=await this.run.continueQuerying(this)}catch(o){r=o}if(!this.running)return;if(r)throw r;if(!t){this.stop();return}if(this.run.peersSeen.has(e.toB58String()))return;this.run.peersSeen.add(e.toB58String()),this.log("queue:work");let n,i;try{n=await this.execQuery(e)}catch(o){i=o}if(!this.running)return;if(this.log("queue:work:done",i,n),i)throw i;if(n&&n.queryComplete){this.log("query:complete"),this.run.stop();return}n&&n.pathComplete&&this.stop()}async execQuery(e){let t,r;try{t=await this.path.queryFunc(e)}catch(n){r=n}if(!this.running)return;if(r){this.run.errors.push(r);return}if(await this.run.peersQueried.add(e),t.pathComplete||t.queryComplete)return this.path.res=t,{pathComplete:t.pathComplete,queryComplete:t.queryComplete};t.closerPeers&&t.closerPeers.length>0&&await Promise.all(t.closerPeers.map(async n=>{if(this.dht._isSelf(n.id))return;this.dht._peerDiscovered(n.id,n.multiaddrs),await this.path.addPeerToQuery(n.id)}))}}var no=ro;class io extends Ce{constructor(e){super();this.query=e,this.running=!1,this.workers=[],this.peersSeen=new Set,this.errors=[],this.peersQueried=null}stop(){if(!this.running)return;this.running=!1;for(const e of this.workers)e.stop()}async execute(e){const t=[],r=Math.min(this.query.dht.disjointPaths,e.length);for(let i=0;i<r;i++)t.push(new Oi(this,this.query.makePath(i,r)));e.forEach((i,o)=>{t[o%r].addInitialPeer(i)}),await this.executePaths(t);const n={finalSet:new Set(this.peersQueried.peers),paths:[]};for(const i of t)i.res&&(i.res.pathComplete||i.res.queryComplete)&&(i.res.success=!0,n.paths.push(i.res));return n}async executePaths(e){this.running=!0,this.emit("start");try{await Promise.all(e.map(t=>t.execute()))}finally{this.stop(),this.emit("complete")}if(this.errors.length===this.peersSeen.size)throw this.errors[0]}async workerQueue(e){await this.init(),await this.startWorker(e)}async startWorker(e){const t=new no(this.query.dht,this,e,this.query._log);this.workers.push(t),await t.execute()}async init(){if(this.peersQueried)return;if(this.peersQueriedPromise){await this.peersQueriedPromise;return}this.peersQueriedPromise=(async()=>{const e=await P.convertBuffer(this.query.key);this.peersQueried=new Ti(e,this.query.dht.kBucketSize)})(),await this.peersQueriedPromise,delete this.peersQueriedPromise}async continueQuerying(e){if(this.peersQueried.length<this.peersQueried.capacity)return!0;const t=e.queue.workersList().map(n=>n.data),r=await this.peersQueried.anyCloser(t);return!!r}}var oo=io;const so=se.multihash;class ao{constructor(e,t,r){this.dht=e,this.key=t,this.makePath=r,this._log=P.logger(this.dht.peerId,"query:"+so.toB58String(t)),this.running=!1,this._onStart=this._onStart.bind(this),this._onComplete=this._onComplete.bind(this)}async run(e){return this.dht._queryManager.running?e.length===0?(this._log.error("Running query with no peers"),{finalSet:new Set,paths:[]}):(this._run=new oo(this),this._log(`query running with K=${this.dht.kBucketSize}, A=${this.dht.concurrency}, D=${Math.min(this.dht.disjointPaths,e.length)}`),this._run.once("start",this._onStart),this._run.once("complete",this._onComplete),this._run.execute(e)):(this._log.error("Attempt to run query after shutdown"),{finalSet:new Set,paths:[]})}_onStart(){this.running=!0,this._startTime=Date.now(),this._log("query:start"),this.dht._queryManager.queryStarted(this)}_onComplete(){this.stop()}stop(){if(this._log(`query:done in ${Date.now()-this._startTime}ms`),this._run&&this._log(`${this._run.errors.length} of ${this._run.peersSeen.size} peers errored (${this._run.errors.length/this._run.peersSeen.size*100}% fail rate)`),!this.running)return;this._run.removeListener("start",this._onStart),this._run.removeListener("complete",this._onComplete),this.running=!1,this._run&&this._run.stop(),this.dht._queryManager.queryCompleted(this)}}var Re=ao;const uo=F.Record;var lo=e=>{const t=async(i,o)=>e.datastore.put(P.bufferToKey(i),o),r=async i=>{e._log("getLocal %b",i);const o=await e.datastore.get(P.bufferToKey(i));e._log("found %b in local datastore",i);const s=uo.deserialize(o);return await e._verifyRecordLocally(s),s},n=async(i,o,s)=>{const a=await P.createPutRecord(i,s);return Promise.all(o.map(async l=>{if(oe(l.val,s))return;if(e._isSelf(l.from)){try{await e._putLocal(i,a)}catch(u){e._log.error("Failed error correcting self",u)}return}try{await e._putValueToPeer(i,a,l.from)}catch(u){e._log.error("Failed error correcting entry",u)}}))};return{async _putLocal(i,o){return t(i,o)},async put(i,o,s={}){e._log("PutValue %b",i);const a=await P.createPutRecord(i,o);await t(i,a);let l=0,u=0;await P.mapParallel(e.getClosestPeers(i,{shallow:!0}),async c=>{try{l+=1,await e._putValueToPeer(i,a,c),u+=1}catch(f){e._log.error("Failed to put to peer (%b): %s",c.id,f)}});const d=s.minPeers||l;if(d>u){const c=T(new Error(`Failed to put value to enough peers: ${u}/${d}`),"ERR_NOT_ENOUGH_PUT_PEERS");throw e._log.error(c),c}},async get(i,o={}){o.timeout=o.timeout||C.minute,e._log("_get %b",i);const s=await e.getMany(i,C.GET_MANY_RECORD_COUNT,o),a=s.map(d=>d.val);let l=0;try{l=F.selection.bestRecord(e.selectors,i,a)}catch(d){if(d.code!=="ERR_NO_SELECTOR_FUNCTION_FOR_RECORD_KEY")throw d}const u=a[l];if(e._log("GetValue %b %s",i,u),!u)throw T(new Error("best value was not found"),"ERR_NOT_FOUND");return await n(i,s,u),u},async getMany(i,o,s={}){s.timeout=s.timeout||C.minute,e._log("getMany %b (%s)",i,o);let a=[],l;try{l=await r(i)}catch(w){if(o===0)throw w}if(l&&a.push({val:l.value,from:e.peerId}),a.length>=o)return a;const u=[],d=await P.convertBuffer(i),c=e.routingTable.closestPeers(d,this.kBucketSize);if(e._log("peers in rt: %d",c.length),c.length===0){const w="Failed to lookup key! No peers from routing table!";if(e._log.error(w),a.length===0)throw T(new Error(w),"ERR_NO_PEERS_IN_ROUTING_TABLE");return a}const f=new Re(e,i,(w,b)=>{const p=P.pathSize(o-a.length,b),h=[];return u.push(h),async y=>{let m,_,v;try{const k=await e._getValueOrPeers(y,i);m=k.record,_=k.peers}catch(k){if(k.code!=="ERR_INVALID_RECORD")throw k;v=k}const I={closerPeers:_};return(m&&m.value||v)&&h.push({val:m&&m.value,from:y}),h.length>=p&&(I.pathComplete=!0),I}});let g;try{await K(f.run(c),s.timeout)}catch(w){g=w}if(f.stop(),a=[].concat.apply(a,u).slice(0,o),g&&a.length===0)throw g;return a}}};class co{constructor(){this.list=[]}push(e){return this.has(e.id)?!1:(this.list.push(e),!0)}has(e){const t=this.list.find(r=>r.id.isEqual(e));return Boolean(t)}toArray(){return this.list.slice()}pop(){return this.list.pop()}get length(){return this.list.length}}var ho=co;class po extends ho{constructor(e){super();this.limit=e}push(e){return this.length<this.limit?super.push(e):!1}}var dr=po,fo=e=>{const t=async(r,n)=>{const i=new D(D.TYPES.GET_PROVIDERS,n.bytes,0);return e.network.sendRequest(r,i)};return{async provide(r){e._log("provide: %s",r.toBaseEncodedString());const n=[];await e.providers.addProvider(r,e.peerId);const i=e.libp2p?e.libp2p.multiaddrs:[],o=new D(D.TYPES.ADD_PROVIDER,r.bytes,0);if(o.providerPeers=[{id:e.peerId,multiaddrs:i}],await P.mapParallel(e.getClosestPeers(r.bytes),async s=>{e._log("putProvider %s to %s",r.toBaseEncodedString(),s.toB58String());try{await e.network.sendMessage(s,o)}catch(a){n.push(a)}}),n.length)throw T(new Error(`Failed to provide to ${n.length} of ${e.kBucketSize} peers`,"ERR_SOME_PROVIDES_FAILED"),{errors:n})},async*findProviders(r,n={}){const i=n.timeout||C.minute,o=n.maxNumProviders||C.K;e._log("findProviders %s",r.toBaseEncodedString());const s=new dr(o),a=await e.providers.getProviders(r);if(a.forEach(c=>{const f=e.peerStore.get(c)||{};s.push({id:f.id||c,multiaddrs:(f.addresses||[]).map(g=>g.multiaddr)})}),s.length>=o){for(const c of s.toArray())yield c;return}const l=[],u=new Re(e,r.bytes,(c,f)=>{const g=P.pathSize(o-s.length,f),w=new dr(g);return l.push(w),async b=>{const p=await t(b,r),h=p.providerPeers;return e._log("(%s) found %s provider entries",e.peerId.toB58String(),h.length),h.forEach(y=>{w.push({id:y.id})}),w.length>=g?{pathComplete:!0}:{closerPeers:p.closerPeers}}}),d=e.routingTable.closestPeers(r.bytes,e.kBucketSize);try{await K(u.run(d),i)}catch(c){if(c.name!==K.TimeoutError.name)throw c}finally{u.stop()}if(l.forEach(c=>{c.toArray().forEach(f=>{s.push(f)})}),s.length===0)throw T(new Error("no providers found"),"ERR_NOT_FOUND");for(const c of s.toArray())yield c}}},mo=e=>{const t=async o=>{e._log("findPeerLocal %s",o.toB58String());const s=await e.routingTable.find(o),a=s&&e.peerStore.get(s);if(a)return{id:a.id,multiaddrs:a.addresses.map(l=>l.multiaddr)}},r=async(o,s)=>{const a=new D(D.TYPES.GET_VALUE,s,0);return e.network.sendRequest(o,a)},n=async(o,s)=>{e._log("closerPeersSingle %b from %s",o,s.toB58String());const a=await e.peerRouting._findPeerSingle(s,new G(o));return a.closerPeers.filter(l=>!e._isSelf(l.id)).map(l=>(e.peerStore.addressBook.add(l.id,l.multiaddrs),l))},i=async o=>{const s=P.keyForPublicKey(o),a=await r(o,s);if(!a.record||!a.record.value)throw T(`Node not responding with its public key: ${o.toB58String()}`,"ERR_INVALID_RECORD");const l=G.createFromPubKey(a.record.value);if(!l.isEqual(o))throw T("public key does not match id","ERR_PUBLIC_KEY_DOES_NOT_MATCH_ID");return l.pubKey};return{async _findPeerSingle(o,s){e._log("findPeerSingle %s",o.toB58String());const a=new D(D.TYPES.FIND_NODE,s.id,0);return e.network.sendRequest(o,a)},async findPeer(o,s={}){s.timeout=s.timeout||C.minute,e._log("findPeer %s",o.toB58String());const a=await t(o);if(a!=null)return e._log("found local"),a;const l=await P.convertPeerId(o),u=e.routingTable.closestPeers(l,e.kBucketSize);if(u.length===0)throw T(new Error("Peer lookup failed"),"ERR_LOOKUP_FAILED");const d=u.find(p=>p.isEqual(o));if(d){const p=e.peerStore.get(o);if(p)return e._log("found in peerStore"),{id:p.id,multiaddrs:p.addresses.map(h=>h.multiaddr)}}const c=new Re(e,o.id,()=>async p=>{const h=await this._findPeerSingle(p,o),y=h.closerPeers.find(m=>m.id.isEqual(o));return y?{peer:y,queryComplete:!0}:{closerPeers:h.closerPeers}});let f,g;try{g=await K(c.run(u),s.timeout)}catch(p){f=p}if(c.stop(),f)throw f;let w=!1;if(g.paths.forEach(p=>{p.success&&(w=!0,e.peerStore.addressBook.add(p.peer.id,p.peer.multiaddrs))}),e._log("findPeer %s: %s",o.toB58String(),w),!w)throw T(new Error("No peer found"),"ERR_NOT_FOUND");const b=e.peerStore.get(o);return{id:b.id,multiaddrs:b.addresses.map(p=>p.multiaddr)}},async*getClosestPeers(o,s={shallow:!1}){e._log("getClosestPeers to %b",o);const a=await P.convertBuffer(o),l=e.routingTable.closestPeers(a,e.kBucketSize),u=new Re(e,o,()=>async f=>{const g=await n(o,f);return{closerPeers:g,pathComplete:s.shallow?!0:void 0}}),d=await u.run(l);if(!d||!d.finalSet)return[];const c=await P.sortClosestPeers(Array.from(d.finalSet),a);for(const f of c.slice(0,e.kBucketSize))yield f},async getPublicKey(o){e._log("getPublicKey %s",o.toB58String());const s=e.peerStore.get(o);if(s&&s.id.pubKey)return e._log("getPublicKey: found local copy"),s.id.pubKey;let a;try{a=await i(o)}catch(u){const d=P.keyForPublicKey(o),c=await e.get(d);a=Ye.keys.unmarshalPublicKey(c)}s.id=new G(o.id,null,a);const l=s.addresses.map(u=>u.multiaddr);return e.peerStore.addressBook.add(s.id,l),e.peerStore.keyBook.set(s.id,a),a}}},yo=x(function(e){var t=Object.prototype.hasOwnProperty,r="~";function n(){}Object.create&&(n.prototype=Object.create(null),new n().__proto__||(r=!1));function i(l,u,d){this.fn=l,this.context=u,this.once=d||!1}function o(l,u,d,c,f){if(typeof d!="function")throw new TypeError("The listener must be a function");var g=new i(d,c||l,f),w=r?r+u:u;return l._events[w]?l._events[w].fn?l._events[w]=[l._events[w],g]:l._events[w].push(g):(l._events[w]=g,l._eventsCount++),l}function s(l,u){--l._eventsCount===0?l._events=new n:delete l._events[u]}function a(){this._events=new n,this._eventsCount=0}a.prototype.eventNames=function(){var u=[],d,c;if(this._eventsCount===0)return u;for(c in d=this._events)t.call(d,c)&&u.push(r?c.slice(1):c);return Object.getOwnPropertySymbols?u.concat(Object.getOwnPropertySymbols(d)):u},a.prototype.listeners=function(u){var d=r?r+u:u,c=this._events[d];if(!c)return[];if(c.fn)return[c.fn];for(var f=0,g=c.length,w=new Array(g);f<g;f++)w[f]=c[f].fn;return w},a.prototype.listenerCount=function(u){var d=r?r+u:u,c=this._events[d];return c?c.fn?1:c.length:0},a.prototype.emit=function(u,d,c,f,g,w){var b=r?r+u:u;if(!this._events[b])return!1;var p=this._events[b],h=arguments.length,y,m;if(p.fn){p.once&&this.removeListener(u,p.fn,void 0,!0);switch(h){case 1:return p.fn.call(p.context),!0;case 2:return p.fn.call(p.context,d),!0;case 3:return p.fn.call(p.context,d,c),!0;case 4:return p.fn.call(p.context,d,c,f),!0;case 5:return p.fn.call(p.context,d,c,f,g),!0;case 6:return p.fn.call(p.context,d,c,f,g,w),!0}for(m=1,y=new Array(h-1);m<h;m++)y[m-1]=arguments[m];p.fn.apply(p.context,y)}else{var _=p.length,v;for(m=0;m<_;m++){p[m].once&&this.removeListener(u,p[m].fn,void 0,!0);switch(h){case 1:p[m].fn.call(p[m].context);break;case 2:p[m].fn.call(p[m].context,d);break;case 3:p[m].fn.call(p[m].context,d,c);break;case 4:p[m].fn.call(p[m].context,d,c,f);break;default:if(!y)for(v=1,y=new Array(h-1);v<h;v++)y[v-1]=arguments[v];p[m].fn.apply(p[m].context,y)}}}return!0},a.prototype.on=function(u,d,c){return o(this,u,d,c,!1)},a.prototype.once=function(u,d,c){return o(this,u,d,c,!0)},a.prototype.removeListener=function(u,d,c,f){var g=r?r+u:u;if(!this._events[g])return this;if(!d)return s(this,g),this;var w=this._events[g];if(w.fn)w.fn===d&&(!f||w.once)&&(!c||w.context===c)&&s(this,g);else{for(var b=0,p=[],h=w.length;b<h;b++)(w[b].fn!==d||f&&!w[b].once||c&&w[b].context!==c)&&p.push(w[b]);p.length?this._events[g]=p.length===1?p[0]:p:s(this,g)}return this},a.prototype.removeAllListeners=function(u){var d;return u?(d=r?r+u:u,this._events[d]&&s(this,d)):(this._events=new n,this._eventsCount=0),this},a.prototype.off=a.prototype.removeListener,a.prototype.addListener=a.prototype.on,a.prefixed=r,a.EventEmitter=a,e.exports=a}),go=x(function(e,t){Object.defineProperty(t,"__esModule",{value:!0});function r(n,i,o){let s=0,a=n.length;for(;a>0;){const l=a/2|0;let u=s+l;o(n[u],i)<=0?(s=++u,a-=l+1):a=l}return s}t.default=r}),vo=x(function(e,t){Object.defineProperty(t,"__esModule",{value:!0});class r{constructor(){this._queue=[]}enqueue(n,i){i=Object.assign({priority:0},i);const o={priority:i.priority,run:n};if(this.size&&this._queue[this.size-1].priority>=i.priority){this._queue.push(o);return}const s=go.default(this._queue,o,(a,l)=>l.priority-a.priority);this._queue.splice(s,0,o)}dequeue(){const n=this._queue.shift();return n==null?void 0:n.run}filter(n){return this._queue.filter(i=>i.priority===n.priority).map(i=>i.run)}get size(){return this._queue.length}}t.default=r}),wo=x(function(e,t){Object.defineProperty(t,"__esModule",{value:!0});const r=()=>{},n=new K.TimeoutError;class i extends yo{constructor(o){var s,a,l,u;super();if(this._intervalCount=0,this._intervalEnd=0,this._pendingCount=0,this._resolveEmpty=r,this._resolveIdle=r,o=Object.assign({carryoverConcurrencyCount:!1,intervalCap:Infinity,interval:0,concurrency:Infinity,autoStart:!0,queueClass:vo.default},o),!(typeof o.intervalCap=="number"&&o.intervalCap>=1))throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${(a=(s=o.intervalCap)===null||s===void 0?void 0:s.toString())!==null&&a!==void 0?a:""}\` (${typeof o.intervalCap})`);if(o.interval===void 0||!(Number.isFinite(o.interval)&&o.interval>=0))throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${(u=(l=o.interval)===null||l===void 0?void 0:l.toString())!==null&&u!==void 0?u:""}\` (${typeof o.interval})`);this._carryoverConcurrencyCount=o.carryoverConcurrencyCount,this._isIntervalIgnored=o.intervalCap===Infinity||o.interval===0,this._intervalCap=o.intervalCap,this._interval=o.interval,this._queue=new o.queueClass,this._queueClass=o.queueClass,this.concurrency=o.concurrency,this._timeout=o.timeout,this._throwOnTimeout=o.throwOnTimeout===!0,this._isPaused=o.autoStart===!1}get _doesIntervalAllowAnother(){return this._isIntervalIgnored||this._intervalCount<this._intervalCap}get _doesConcurrentAllowAnother(){return this._pendingCount<this._concurrency}_next(){this._pendingCount--,this._tryToStartAnother(),this.emit("next")}_resolvePromises(){this._resolveEmpty(),this._resolveEmpty=r,this._pendingCount===0&&(this._resolveIdle(),this._resolveIdle=r,this.emit("idle"))}_onResumeInterval(){this._onInterval(),this._initializeIntervalIfNeeded(),this._timeoutId=void 0}_isIntervalPaused(){const o=Date.now();if(this._intervalId===void 0){const s=this._intervalEnd-o;if(s<0)this._intervalCount=this._carryoverConcurrencyCount?this._pendingCount:0;else return this._timeoutId===void 0&&(this._timeoutId=setTimeout(()=>{this._onResumeInterval()},s)),!0}return!1}_tryToStartAnother(){if(this._queue.size===0)return this._intervalId&&clearInterval(this._intervalId),this._intervalId=void 0,this._resolvePromises(),!1;if(!this._isPaused){const o=!this._isIntervalPaused();if(this._doesIntervalAllowAnother&&this._doesConcurrentAllowAnother){const s=this._queue.dequeue();return s?(this.emit("active"),s(),o&&this._initializeIntervalIfNeeded(),!0):!1}}return!1}_initializeIntervalIfNeeded(){if(this._isIntervalIgnored||this._intervalId!==void 0)return;this._intervalId=setInterval(()=>{this._onInterval()},this._interval),this._intervalEnd=Date.now()+this._interval}_onInterval(){this._intervalCount===0&&this._pendingCount===0&&this._intervalId&&(clearInterval(this._intervalId),this._intervalId=void 0),this._intervalCount=this._carryoverConcurrencyCount?this._pendingCount:0,this._processQueue()}_processQueue(){for(;this._tryToStartAnother(););}get concurrency(){return this._concurrency}set concurrency(o){if(!(typeof o=="number"&&o>=1))throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${o}\` (${typeof o})`);this._concurrency=o,this._processQueue()}async add(o,s={}){return new Promise((a,l)=>{const u=async()=>{this._pendingCount++,this._intervalCount++;try{const d=this._timeout===void 0&&s.timeout===void 0?o():K.default(Promise.resolve(o()),s.timeout===void 0?this._timeout:s.timeout,()=>{(s.throwOnTimeout===void 0?this._throwOnTimeout:s.throwOnTimeout)&&l(n);return});a(await d)}catch(d){l(d)}this._next()};this._queue.enqueue(u,s),this._tryToStartAnother(),this.emit("add")})}async addAll(o,s){return Promise.all(o.map(async a=>this.add(a,s)))}start(){return this._isPaused?(this._isPaused=!1,this._processQueue(),this):this}pause(){this._isPaused=!0}clear(){this._queue=new this._queueClass}async onEmpty(){return this._queue.size===0?void 0:new Promise(o=>{const s=this._resolveEmpty;this._resolveEmpty=()=>{s(),o()}})}async onIdle(){return this._pendingCount===0&&this._queue.size===0?void 0:new Promise(o=>{const s=this._resolveIdle;this._resolveIdle=()=>{s(),o()}})}get size(){return this._queue.size}sizeBy(o){return this._queue.filter(o).length}get pending(){return this._pendingCount}get isPaused(){return this._isPaused}get timeout(){return this._timeout}set timeout(o){this._timeout=o}}t.default=i});const{Key:bo}=Ne,{default:_o}=wo;class Po{constructor(e,t,r){this.datastore=e,this._log=P.logger(t,"providers"),this.cleanupInterval=C.PROVIDERS_CLEANUP_INTERVAL,this.provideValidity=C.PROVIDERS_VALIDITY,this.lruCacheSize=r||C.PROVIDERS_LRU_CACHE_SIZE,this.providers=Xt(this.lruCacheSize),this.syncQueue=new _o({concurrency:1})}start(){this._cleaner=setInterval(()=>this._cleanup(),this.cleanupInterval)}stop(){clearInterval(this._cleaner),this._cleaner=null}_cleanup(){return this.syncQueue.add(async()=>{this._log("start cleanup");const e=Date.now();let t=0,r=0;const n=new Map,i=this.datastore.batch(),o=this.datastore.query({prefix:C.PROVIDERS_KEY_PREFIX});for await(const s of o)try{const{cid:a,peerId:l}=hr(s.key),u=pr(s.value),d=Date.now(),c=d-u,f=c>this.provideValidity;if(this._log("comparing: %d - %d = %d > %d %s",d,u,c,this.provideValidity,f?"(expired)":""),f){r++,i.delete(s.key);const g=n.get(a)||new Set;g.add(l),n.set(a,g)}t++}catch(a){this._log.error(a.message)}this._log("deleting %d / %d entries",r,t),n.size&&await i.commit();for(const[s,a]of n){const l=he(s),u=this.providers.get(l);if(u){for(const d of a)u.delete(d);u.size===0?this.providers.remove(l):this.providers.set(l,u)}}this._log("Cleanup successful (%dms)",Date.now()-e)})}async _getProvidersMap(e){const t=he(e);let r=this.providers.get(t);return r||(r=await ko(this.datastore,e),this.providers.set(t,r)),r}async addProvider(e,t){return this.syncQueue.add(async()=>{this._log("addProvider %s",e.toBaseEncodedString());const r=await this._getProvidersMap(e);this._log("loaded %s provs",r.size);const n=Date.now();r.set(P.encodeBase32(t.id),n);const i=he(e);return this.providers.set(i,r),Io(this.datastore,e,t,n)})}async getProviders(e){return this.syncQueue.add(async()=>{this._log("getProviders %s",e.toBaseEncodedString());const t=await this._getProvidersMap(e);return[...t.keys()].map(r=>new G(P.decodeBase32(r)))})}}function he(e){return e=typeof e=="string"?e:P.encodeBase32(e.bytes),C.PROVIDERS_KEY_PREFIX+e}async function Io(e,t,r,n){const i=[he(t),"/",P.encodeBase32(r.id)].join(""),o=new bo(i),s=Uint8Array.from(R.encode(n));return e.put(o,s)}function hr(e){const t=e.toString().split("/");if(t.length!==4)throw new Error("incorrectly formatted provider entry key in datastore: "+e);return{cid:t[2],peerId:t[3]}}async function ko(e,t){const r=new Map,n=e.query({prefix:he(t)});for await(const i of n){const{peerId:o}=hr(i.key);r.set(o,pr(i.value))}return r}function pr(e){return R.decode(e)}var Eo=Po,To=async(e,t,{concurrency:r=Infinity,stopOnError:n=!0}={})=>new Promise((i,o)=>{if(typeof t!="function")throw new TypeError("Mapper function is required");if(!((Number.isSafeInteger(r)||r===Infinity)&&r>=1))throw new TypeError(`Expected \`concurrency\` to be an integer from 1 and up or \`Infinity\`, got \`${r}\` (${typeof r})`);const s=[],a=[],l=e[Symbol.iterator]();let u=!1,d=!1,c=0,f=0;const g=()=>{if(u)return;const w=l.next(),b=f;if(f++,w.done){d=!0,c===0&&(!n&&a.length!==0?o(new Be(a)):i(s));return}c++,(async()=>{try{const p=await w.value;s[b]=await t(p,b),c--,g()}catch(p){n?(u=!0,o(p)):(a.push(p),c--,g())}})()};for(let w=0;w<r&&!(g(),d);w++);});const fr=async(e,t,r)=>To(new Array(e).fill(),(n,i)=>t(i),r);var mr=fr,Ao=fr;mr.default=Ao;const{logger:So}=P;class qo{constructor(e,t){if(!e)throw new Error("Random Walk needs an instance of the Kademlia DHT");this._kadDHT=e,this._options={...C.defaultRandomWalk,...t},this.log=So(e.peerId,"random-walk"),this._timeoutId=void 0}start(){if(this._timeoutId||!this._options.enabled)return;this._timeoutId=setTimeout(()=>{this._runPeriodically()},this._options.delay)}stop(){this._timeoutId&&(clearTimeout(this._timeoutId),this._timeoutId=void 0),this._controller&&this._controller.abort()}async _runPeriodically(){for(;this._timeoutId;){try{await this._walk(this._options.queriesPerPeriod,this._options.timeout)}catch(e){this._kadDHT._log.error("random-walk:error",e)}await new Promise(e=>{this._timeoutId=setTimeout(e,this._options.interval)})}}async _walk(e,t){this.log("start"),this._controller=new be;try{await mr(e,async r=>{this.log("running query %d",r);try{const n=await this._randomPeerId();if(!this._controller)return;await this._query(n,{timeout:t,signal:this._controller.signal})}catch(n){if(n&&n.code!=="ETIMEDOUT")throw this.log.error("query %d finished with error",r,n),n}this.log("finished query %d",r)})}finally{this._controller=null,this.log("finished queries")}}async _query(e,t){this.log("query:%s",e.toB58String());let r;try{r=await this._kadDHT.findPeer(e,t)}catch(n){if(n&&n.code==="ERR_NOT_FOUND")return;throw n}throw this.log("query:found",r),T(`random-walk: ACTUALLY FOUND PEER: ${r}, ${e.toB58String()}`,"ERR_FOUND_RANDOM_PEER")}async _randomPeerId(){const e=await se(Ye.randomBytes(16),"sha2-256");return new G(e)}}var Ro=qo;class Do{constructor(){this.queries=new Set,this.running=!1}queryStarted(e){this.queries.add(e)}queryCompleted(e){this.queries.delete(e)}start(){this.running=!0}stop(){this.running=!1;for(const e of this.queries)e.stop();this.queries.clear()}}var Oo=Do;const{EventEmitter:Co}=Ce,{MemoryDatastore:xo}=Ne,yr=F.Record;class Mo extends Co{constructor({libp2p:e,dialer:t,peerId:r,peerStore:n,registrar:i,protocolPrefix:o="/ipfs",forceProtocolLegacy:s=!1,datastore:a=new xo,kBucketSize:l=C.K,clientMode:u=!1,concurrency:d=C.ALPHA,validators:c={},selectors:f={},randomWalk:g={},onPut:w=()=>{},onRemove:b=()=>{}}){super();if(!t)throw new Error("libp2p-kad-dht requires an instance of Dialer");this.libp2p=e,this.dialer=t,this.peerId=r,this.peerStore=n,this.registrar=i,this.protocol=o+(s?"":C.PROTOCOL_DHT),this.kBucketSize=l,this._clientMode=u,this.concurrency=d,this.disjointPaths=Math.ceil(this.kBucketSize/2),this.routingTable=new ii(this.peerId,this.kBucketSize),this.datastore=a,this.providers=new Eo(this.datastore,this.peerId),this.validators={pk:F.validator.validators.pk,...c},this.selectors={pk:F.selection.selectors.pk,...f},this.network=new ki(this),this._log=P.logger(this.peerId),this.randomWalk=new Ro(this,g),this._queryManager=new Oo,this._running=!1,this.contentFetching=lo(this),this.contentRouting=fo(this),this.peerRouting=mo(this),this.onPut=w,this.onRemove=b}get isStarted(){return this._running}async start(){this._running=!0,this.providers.start(),this._queryManager.start(),await this.network.start(),this.randomWalk.start()}stop(){return this._running=!1,this.randomWalk.stop(),this.providers.stop(),this._queryManager.stop(),this.network.stop()}async put(e,t,r={}){return this.contentFetching.put(e,t,r)}async get(e,t={}){return this.contentFetching.get(e,t)}async getMany(e,t,r={}){return this.contentFetching.getMany(e,t,r)}async provide(e){return this.contentRouting.provide(e)}async*findProviders(e,t={}){for await(const r of this.contentRouting.findProviders(e,t))yield r}async findPeer(e,t={}){return this.peerRouting.findPeer(e,t)}async*getClosestPeers(e,t={shallow:!1}){for await(const r of this.peerRouting.getClosestPeers(e,t))yield r}async getPublicKey(e){return this.peerRouting.getPublicKey(e)}_peerDiscovered(e,t){this.emit("peer",{id:e,multiaddrs:t})}async _nearestPeersToQuery(e){const t=await P.convertBuffer(e.key),r=this.routingTable.closestPeers(t,this.kBucketSize);return r.map(n=>{const i=this.peerStore.get(n);return{id:n,multiaddrs:i?i.addresses.map(o=>o.multiaddr):[]}})}async _betterPeersToQuery(e,t){this._log("betterPeersToQuery");const r=await this._nearestPeersToQuery(e);return r.filter(n=>this._isSelf(n.id)?(this._log.error("trying to return self as closer"),!1):!n.id.isEqual(t))}async _checkLocalDatastore(e){this._log("checkLocalDatastore: %b",e);const t=P.bufferToKey(e);let r;try{r=await this.datastore.get(t)}catch(i){if(i.code==="ERR_NOT_FOUND")return;throw i}const n=yr.deserialize(r);if(!n)throw T("Invalid record","ERR_INVALID_RECORD");if(n.timeReceived==null||P.now()-n.timeReceived>C.MAX_RECORD_AGE){await this.datastore.delete(t),this.onRemove(n);return}return n}async _add(e){await this.routingTable.add(e)}async _verifyRecordLocally(e){this._log("verifyRecordLocally"),await F.validator.verifyRecord(this.validators,e)}_isSelf(e){return e&&oe(this.peerId.id,e.id)}async _putValueToPeer(e,t,r){const n=new D(D.TYPES.PUT_VALUE,e,0);n.record=t;const i=await this.network.sendRequest(r,n);if(!i.record.value.equals(yr.deserialize(t).value))throw T(new Error("value not put correctly"),"ERR_PUT_VALUE_INVALID")}async _getValueOrPeers(e,t){const r=await this._getValueSingle(e,t),n=r.closerPeers,i=r.record;if(i){try{await this._verifyRecordOnline(i)}catch(o){const s="invalid record received, discarded";throw this._log(s),T(new Error(s),"ERR_INVALID_RECORD")}return{record:i,peers:n}}if(n.length>0)return{peers:n};throw T(new Error("Not found"),"ERR_NOT_FOUND")}async _getValueSingle(e,t){const r=new D(D.TYPES.GET_VALUE,t,0);return this.network.sendRequest(e,r)}async _verifyRecordOnline(e){await F.validator.verifyRecord(this.validators,e)}}var De=Mo,gr="/ipfs"+C.PROTOCOL_DHT;De.multicodec=gr;var No=Object.freeze(Object.assign(Object.create(null),De,{default:De,multicodec:gr}));export{te as B,Be as a,ge as b,re as c,be as d,Ye as e,De as f,Xt as h,No as i,K as p,Jt as r,It as s};
