class r{constructor(e,s,t,i,n){this.x=e,this.y=s,this.w=t,this.h=i,this.data=n}contains(e){return e.x>=this.x&&e.x<=this.x+this.w&&e.y>=this.y&&e.y<=this.y+this.h}intersects(e){return!(e.x>this.x+this.w||e.x+e.w<this.x||e.y>this.y+this.h||e.y+e.h<this.y)}}const c={capacity:4,removeEmptyNodes:!1,maximumDepth:-1,arePointsEqual:(e,s)=>e.x===s.x&&e.y===s.y};class o{constructor(e,s,t=[]){this.container=e,this.config=Object.assign({},c,s),this.isDivided=!1,this.points=[];for(const i of t)this.insertRecursive(i)}getTree(){let e;return e=this.isDivided?{ne:this.ne.getTree(),nw:this.nw.getTree(),se:this.se.getTree(),sw:this.sw.getTree()}:this.getNodePointAmount(),e}getAllPoints(){const e=[];return this.getAllPointsRecursive(e),e}getAllPointsRecursive(e){this.isDivided?(this.ne.getAllPointsRecursive(e),this.nw.getAllPointsRecursive(e),this.se.getAllPointsRecursive(e),this.sw.getAllPointsRecursive(e)):Array.prototype.push.apply(e,this.points.slice())}getNodePointAmount(){return this.points.length}divide(){const e=this.config.maximumDepth===-1?-1:this.config.maximumDepth-1,s=Object.assign({},this.config,{maximumDepth:e});this.isDivided=!0;const t=this.container.x,i=this.container.y,n=this.container.w/2,h=this.container.h/2;this.ne=new o(new r(t+n,i,n,h),s),this.nw=new o(new r(t,i,n,h),s),this.se=new o(new r(t+n,i+h,n,h),s),this.sw=new o(new r(t,i+h,n,h),s),this.insert(this.points.slice()),this.points.length=0,this.points=[]}remove(e){if(Array.isArray(e))for(const s of e)this.removeRecursive(s);else this.removeRecursive(e)}removeRecursive(e){if(this.container.contains(e))if(this.isDivided)this.ne.removeRecursive(e),this.nw.removeRecursive(e),this.se.removeRecursive(e),this.sw.removeRecursive(e),this.config.removeEmptyNodes&&(this.ne.getNodePointAmount()!==0||this.ne.isDivided||this.nw.getNodePointAmount()!==0||this.nw.isDivided||this.se.getNodePointAmount()!==0||this.se.isDivided||this.sw.getNodePointAmount()!==0||this.sw.isDivided||(this.isDivided=!1,delete this.ne,delete this.nw,delete this.se,delete this.sw));else for(let s=this.points.length-1;s>=0;s--)this.config.arePointsEqual(e,this.points[s])&&this.points.splice(s,1)}insert(e){if(Array.isArray(e)){let s=!0;for(const t of e)s=s&&this.insertRecursive(t);return s}return this.insertRecursive(e)}insertRecursive(e){if(!this.container.contains(e))return!1;if(!this.isDivided){if(this.getNodePointAmount()<this.config.capacity||this.config.maximumDepth===0)return this.points.push(e),!0;(this.config.maximumDepth===-1||this.config.maximumDepth>0)&&this.divide()}return!!this.isDivided&&(this.ne.insertRecursive(e)||this.nw.insertRecursive(e)||this.se.insertRecursive(e)||this.sw.insertRecursive(e))}query(e){const s=[];return this.queryRecursive(e,s),s}queryRecursive(e,s){if(e.intersects(this.container))if(this.isDivided)this.ne.queryRecursive(e,s),this.nw.queryRecursive(e,s),this.se.queryRecursive(e,s),this.sw.queryRecursive(e,s);else{const t=this.points.filter(i=>e.contains(i));Array.prototype.push.apply(s,t)}}clear(){this.points=[],this.isDivided=!1,delete this.ne,delete this.nw,delete this.se,delete this.sw}}export{r as Box,o as QuadTree};
