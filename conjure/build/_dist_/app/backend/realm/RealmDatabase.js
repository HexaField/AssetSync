import c from"../../../../web_modules/events.js";import{NETWORKING_OPCODES as r}from"../Constants.js";import{REALM_WORLD_GENERATORS as h}from"./RealmData.js";import d from"./datastores/RealmDatabaseBasic.js";import"./datastores/RealmDatabaseProcedural.js";import"../../../../web_modules/@AssetSync/common.js";import l from"./RealmPhysics.js";export default class u extends c{constructor(s,t,e){super();this.eventHooks=new c,this.realmHandler=s,this.assetSync=s.assetSync,this.realmData=t,this.dhtProtocol=e+this.realmData.id,this.objects={},this._stopDatastores=async()=>{console.warn("ERROR! Database",t.id,"has no _stopDatastores implemented")},this._get=async a=>{console.warn("ERROR! Database",t.id,"has no _get implemented")},this._put=async(a,i)=>{console.warn("ERROR! Database",t.id,"has no _put implemented")},this._getAllLocal=async()=>{console.warn("ERROR! Database",t.id,"has no _getAllLocal implemented")},this._removeLocal=async a=>{console.warn("ERROR! Database",t.id,"has no _removeLocal implemented")},this.onObjectCreate=(a,i,o)=>{},this.onObjectUpdate=(a,i,o)=>{},this.onObjectGroup=(a,i)=>{},this.onObjectMove=(a,i)=>{},this.onObjectDestroy=(a,i)=>{},this.hasPhysics=typeof PhysX!="undefined"&&t.hasPhysics===!0}async start(s=()=>{},t){s("Opening database for realm",this.realmData.id),this.network=await this.assetSync.networkPlugin.joinNetwork(this.realmData.id),this.network.on("message",e=>{this.eventHooks.emit("message",e);try{const{opcode:a,content:i}=JSON.parse(e.data);this.emit(a,i,e.from)}catch(a){console.log("hmm bad message",a,e)}}),this.network.on("onPeerJoin",e=>{this.eventHooks.emit("onPeerJoin",e)}),this.network.on("onPeerLeave",e=>{this.eventHooks.emit("onPeerLeave",e)}),this.on(r.OBJECT.CREATE,async(e,a)=>{const{uuid:i,data:o}=e;await this._put(i,JSON.stringify(o));const n=this.realmHandler.objectLoader.parse(o);this.physics&&this.physics.loadObject(n),this.onObjectCreate(n,a)}),this.on(r.OBJECT.UPDATE_PROPERTIES,async(e,a)=>{const{uuid:i,data:o}=e;await this._put(i,JSON.stringify(o))}),this.on(r.OBJECT.DESTROY,async(e,a)=>{const{uuid:i,data:o}=e;await this._put(i,""),this.onObjectDestroy(i,a)}),this.on(r.OBJECT.MOVE,async(e,a)=>{const{uuid:i,data:o}=JSON.parse(e);await this._put(i,o)}),this.on(r.OBJECT.GROUP,async(e,a)=>{}),this.realmData.worldSettings.worldGeneratorType===h.NONE&&await d(this,s,t),this.hasPhysics&&(this.physics=new l(this),await this.physics.initialise(s))}async stop(){this.eventHooks.removeAllListeners(),await this.network.leave(),await this._stopDatastores()}sendToAll(s,t){this.network.broadcast(JSON.stringify({opcode:s,content:t}))}sendTo(s,t,e){this.network.sendTo(s,JSON.stringify({opcode:t,content:e}))}async joinNetwork(){this.network.getPeers().length||await new Promise(s=>{this.network.on("onPeerJoin",()=>{s()})})}async createObject(s){try{const t=s.uuid,e=s.toJSON();return await this._put(t,JSON.stringify(e)),this.physics&&this.physics.loadObject(s),this.sendToAll(r.OBJECT.CREATE,{uuid:t,data:e}),!0}catch(t){return console.log(t),!1}}async getObjects(){const s=[];return s.push(...await this._getAllLocal()),s.map(t=>{try{return this.realmHandler.objectLoader.parse(JSON.parse(t.value))}catch(e){return}}).filter(t=>t!==void 0)}async updateObject(s){try{const t=s.uuid,e=s.toJSON();return await this._put(t,JSON.stringify(e)),this.physics&&this.physics.updateObject(s),this.sendToAll(r.OBJECT.UPDATE_PROPERTIES,{uuid:t,data:e}),!0}catch(t){return console.log(t),!1}}async removeObject(s){try{const t=s.uuid,e=s.toJSON();return await this._put(t,""),this.physics&&this.physics.removeObject(s),this.sendToAll(r.OBJECT.DESTROY,{uuid:t}),!0}catch(t){return console.log(t),!1}}async transactObject({uuid:s,data:t}){}}
