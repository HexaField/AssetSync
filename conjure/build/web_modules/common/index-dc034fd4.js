import{b as W,e as f}from"./index-b1567acb.js";import{b as K}from"./buffer-es6-e6024076.js";import{i as J,t as $,a as B}from"./index-71e9481e.js";const U=(e,t)=>t.some(r=>e instanceof r);let _,I;function V(){return _||(_=[IDBDatabase,IDBObjectStore,IDBIndex,IDBCursor,IDBTransaction])}function z(){return I||(I=[IDBCursor.prototype.advance,IDBCursor.prototype.continue,IDBCursor.prototype.continuePrimaryKey])}const S=new WeakMap,w=new WeakMap,R=new WeakMap,g=new WeakMap,v=new WeakMap;function G(e){const t=new Promise((r,n)=>{const s=()=>{e.removeEventListener("success",a),e.removeEventListener("error",o)},a=()=>{r(i(e.result)),s()},o=()=>{n(e.error),s()};e.addEventListener("success",a),e.addEventListener("error",o)});return t.then(r=>{r instanceof IDBCursor&&S.set(r,e)}).catch(()=>{}),v.set(t,e),t}function q(e){if(w.has(e))return;const t=new Promise((r,n)=>{const s=()=>{e.removeEventListener("complete",a),e.removeEventListener("error",o),e.removeEventListener("abort",o)},a=()=>{r(),s()},o=()=>{n(e.error||new DOMException("AbortError","AbortError")),s()};e.addEventListener("complete",a),e.addEventListener("error",o),e.addEventListener("abort",o)});w.set(e,t)}let A={get(e,t,r){if(e instanceof IDBTransaction){if(t==="done")return w.get(e);if(t==="objectStoreNames")return e.objectStoreNames||R.get(e);if(t==="store")return r.objectStoreNames[1]?void 0:r.objectStore(r.objectStoreNames[0])}return i(e[t])},set(e,t,r){return e[t]=r,!0},has(e,t){return e instanceof IDBTransaction&&(t==="done"||t==="store")?!0:t in e}};function H(e){A=e(A)}function Q(e){return e===IDBDatabase.prototype.transaction&&!("objectStoreNames"in IDBTransaction.prototype)?function(t,...r){const n=e.call(p(this),t,...r);return R.set(n,t.sort?t.sort():[t]),i(n)}:z().includes(e)?function(...t){return e.apply(p(this),t),i(S.get(this))}:function(...t){return i(e.apply(p(this),t))}}function Y(e){return typeof e=="function"?Q(e):(e instanceof IDBTransaction&&q(e),U(e,V())?new Proxy(e,A):e)}function i(e){if(e instanceof IDBRequest)return G(e);if(g.has(e))return g.get(e);const t=Y(e);return t!==e&&(g.set(e,t),v.set(t,e)),t}const p=e=>v.get(e);function X(e,t,{blocked:r,upgrade:n,blocking:s,terminated:a}={}){const o=indexedDB.open(e,t),h=i(o);return n&&o.addEventListener("upgradeneeded",l=>{n(i(o.result),l.oldVersion,l.newVersion,i(o.transaction))}),r&&o.addEventListener("blocked",()=>r()),h.then(l=>{a&&l.addEventListener("close",()=>a()),s&&l.addEventListener("versionchange",()=>s())}).catch(()=>{}),h}function Z(e,{blocked:t}={}){const r=indexedDB.deleteDatabase(e);return t&&r.addEventListener("blocked",()=>t()),i(r).then(()=>{})}const ee=["get","getKey","getAll","getAllKeys","count"],te=["put","add","delete","clear"],E=new Map;function x(e,t){if(!(e instanceof IDBDatabase&&!(t in e)&&typeof t=="string"))return;if(E.get(t))return E.get(t);const r=t.replace(/FromIndex$/,""),n=t!==r,s=te.includes(r);if(!(r in(n?IDBIndex:IDBObjectStore).prototype)||!(s||ee.includes(r)))return;const a=async function(o,...h){const l=this.transaction(o,s?"readwrite":"readonly");let b=l.store;n&&(b=b.index(h.shift()));const N=await b[r](...h);return s&&await l.done,N};return E.set(t,a),a}H(e=>({...e,get:(t,r,n)=>x(t,r)||e.get(t,r,n),has:(t,r)=>!!x(t,r)||e.has(t,r)}));var re=Object.freeze({__proto__:null,deleteDB:Z,openDB:X,unwrap:p,wrap:i});const{Buffer:y}=K,{nanoid:ne}=J,c="/",M=y.from(c),D=M[0];class k{constructor(e,t){if(typeof e=="string"?this._buf=y.from(e):y.isBuffer(e)&&(this._buf=e),t==null&&(t=!0),t&&this.clean(),this._buf.length===0||this._buf[0]!==D)throw new Error("Invalid key")}toString(e){return this._buf.toString(e||"utf8")}toBuffer(){return this._buf}get[Symbol.toStringTag](){return`Key(${this.toString()})`}static withNamespaces(e){return new u(e.join(c))}static random(){return new u(ne().replace(/-/g,""))}clean(){for((!this._buf||this._buf.length===0)&&(this._buf=y.from(c)),this._buf[0]!==D&&(this._buf=y.concat([M,this._buf]));this._buf.length>1&&this._buf[this._buf.length-1]===D;)this._buf=this._buf.slice(0,-1)}less(e){const t=this.list(),r=e.list();for(let n=0;n<t.length;n++){if(r.length<n+1)return!1;const s=t[n],a=r[n];if(s<a)return!0;if(s>a)return!1}return t.length<r.length}reverse(){return k.withNamespaces(this.list().slice().reverse())}namespaces(){return this.list()}baseNamespace(){const e=this.namespaces();return e[e.length-1]}list(){return this.toString().split(c).slice(1)}type(){return se(this.baseNamespace())}name(){return oe(this.baseNamespace())}instance(e){return new u(this.toString()+":"+e)}path(){let e=this.parent().toString();return e.endsWith(c)||(e+=c),e+=this.type(),new u(e)}parent(){const e=this.list();return e.length===1?new u(c):new u(e.slice(0,-1).join(c))}child(e){return this.toString()===c?e:e.toString()===c?this:new u(this.toString()+e.toString(),!1)}isAncestorOf(e){return e.toString()===this.toString()?!1:e.toString().startsWith(this.toString())}isDecendantOf(e){return e.toString()===this.toString()?!1:this.toString().startsWith(e.toString())}isTopLevel(){return this.list().length===1}concat(...e){return k.withNamespaces([...this.namespaces(),...ae(e.map(t=>t.namespaces()))])}}function se(e){const t=e.split(":");return t.length<2?"":t.slice(0,-1).join(":")}function oe(e){const t=e.split(":");return t[t.length-1]}function ae(e){return[].concat(...e)}const u=W(k,{className:"Key",symbolName:"@ipfs/interface-datastore/key"});var O=u,ie=(e,t)=>async function*(){for await(const r of e){const n=await t(r);if(!n)continue;yield r}}(),ce=(e,t)=>async function*(){let r=[];for await(const n of e)r.push(n);r=await t(r);for(const n of r)yield n}(),le=(e,t)=>async function*(){if(t<=0)return;let r=0;for await(const n of e)if(yield n,r++,r>=t)return}(),ue=(e,t)=>async function*(){for await(const r of e)yield t(r)}(),he=function(e,t){const r=new RegExp("^"+t);return e.replace(r,"")},fe=$,j={filter:ie,sortAll:ce,take:le,map:ue,replaceStartWith:he,tmpdir:fe};const{filter:C,sortAll:ye,take:de,map:pe}=j;class me{async open(){}async close(){}async put(e,t,r={}){}async*putMany(e,t={}){for await(const{key:r,value:n}of e)await this.put(r,n,t),yield{key:r,value:n}}async get(e,t={}){}async*getMany(e,t={}){for await(const r of e)yield this.get(r,t)}async has(e){}async delete(e,t={}){}async*deleteMany(e,t={}){for await(const r of e)await this.delete(r,t),yield r}batch(){let e=[],t=[];return{put(r,n){e.push({key:r,value:n})},delete(r){t.push(r)},commit:async r=>{await B(this.putMany(e,r)),e=[],await B(this.deleteMany(t,r)),t=[]}}}async*_all(e,t){}async*query(e,t){let r=this._all(e,t);if(e.prefix!=null&&(r=C(r,n=>n.key.toString().startsWith(e.prefix))),Array.isArray(e.filters)&&(r=e.filters.reduce((n,s)=>C(n,s),r)),Array.isArray(e.orders)&&(r=e.orders.reduce((n,s)=>ye(n,s),r)),e.offset!=null){let n=0;r=C(r,()=>n++>=e.offset)}e.limit!=null&&(r=de(r,e.limit)),e.keysOnly===!0&&(r=pe(r,n=>({key:n.key}))),yield*r}}var P=me,be=e=>(e=e||new Error("Cannot open database"),f(e,"ERR_DB_OPEN_FAILED")),we=e=>(e=e||new Error("Delete failed"),f(e,"ERR_DB_DELETE_FAILED")),ge=e=>(e=e||new Error("Write failed"),f(e,"ERR_DB_WRITE_FAILED")),ve=e=>(e=e||new Error("Not Found"),f(e,"ERR_NOT_FOUND")),Ae=e=>(e=e||new Error("Aborted"),f(e,"ERR_ABORTED")),T={dbOpenFailedError:be,dbDeleteFailedError:we,dbWriteFailedError:ge,notFoundError:ve,abortedError:Ae};class Ee extends P{constructor(){super();this.data={}}async put(e,t){this.data[e.toString()]=t}async get(e){const t=await this.has(e);if(!t)throw T.notFoundError();return this.data[e.toString()]}async has(e){return this.data[e.toString()]!==void 0}async delete(e){delete this.data[e.toString()]}*_all(){yield*Object.entries(this.data).map(([e,t])=>({key:new O(e),value:t}))}}var De=Ee,ke=O,Ce=De,Ke=j,Be=T,_e=P,Ie={Key:ke,MemoryDatastore:Ce,utils:Ke,Errors:Be,Adapter:_e};const{Buffer:m}=K,{openDB:Se,deleteDB:Re}=re,{Key:xe,Errors:d,utils:Me,Adapter:Oe}=Ie,{filter:je,sortAll:Pe}=Me,Te=e=>e instanceof Int8Array||e instanceof Int16Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray||e instanceof Uint16Array||e instanceof Uint32Array||e instanceof Float32Array||e instanceof Float64Array,Fe=e=>{if(Te(e)){let t=m.from(e.buffer);return e.byteLength!==e.buffer.byteLength&&(t=t.slice(e.byteOffset,e.byteOffset+e.byteLength)),t}else return m.from(e)},F=e=>{const t=new ArrayBuffer(e.length),r=new Uint8Array(t);for(let n=0,s=e.length;n<s;n++)r[n]=e.charCodeAt(n);return t},Le=async function*(e,t,r){const n=e.prefix?self.IDBKeyRange.bound(F(e.prefix),F(e.prefix+"\xFF"),!1,!0):void 0;let s=await t.transaction(r).store.openCursor(n),a=0;for(s&&e.offset&&e.offset>0&&(s=await s.advance(e.offset));s;){if(e.limit!==void 0&&e.limit===a)return;a++;const o=new xe(m.from(s.key));if(e.keysOnly)yield{key:o};else{const h=m.from(s.value);yield{key:o,value:h}}s=await s.continue()}};class Ne extends Oe{constructor(e,t={}){super();this.store=null,this.options=t,this.location=t.prefix+e,this.version=t.version||1}async open(){if(this.store!==null)return;const e=this.location;try{this.store=await Se(this.location,this.version,{upgrade(t){t.createObjectStore(e)}})}catch(t){throw d.dbOpenFailedError(t)}}async put(e,t){if(this.store===null)throw new Error("Datastore needs to be opened.");try{await this.store.put(this.location,t,e.toBuffer())}catch(r){throw d.dbWriteFailedError(r)}}async get(e){if(this.store===null)throw new Error("Datastore needs to be opened.");let t;try{t=await this.store.get(this.location,e.toBuffer())}catch(r){throw d.dbWriteFailedError(r)}if(!t)throw d.notFoundError();return Fe(t)}async has(e){if(this.store===null)throw new Error("Datastore needs to be opened.");try{await this.get(e)}catch(t){if(t.code==="ERR_NOT_FOUND")return!1;throw t}return!0}async delete(e){if(this.store===null)throw new Error("Datastore needs to be opened.");try{await this.store.delete(this.location,e.toBuffer())}catch(t){throw d.dbDeleteFailedError(t)}}batch(){const e=[],t=[];return{put(r,n){e.push([r.toBuffer(),n])},delete(r){t.push(r.toBuffer())},commit:async()=>{if(this.store===null)throw new Error("Datastore needs to be opened.");const r=this.store.transaction(this.location,"readwrite"),n=r.store;await Promise.all(e.map(s=>n.put(s[1],s[0]))),await Promise.all(t.map(s=>n.delete(s))),await r.done}}}query(e){if(this.store===null)throw new Error("Datastore needs to be opened.");let t=Le(e,this.store,this.location);return Array.isArray(e.filters)&&(t=e.filters.reduce((r,n)=>je(r,n),t)),Array.isArray(e.orders)&&(t=e.orders.reduce((r,n)=>Pe(r,n),t)),t}close(){if(this.store===null)throw new Error("Datastore needs to be opened.");this.store.close(),this.store=null}destroy(){return Re(this.location)}}var L=Ne,We=Object.freeze(Object.assign(Object.create(null),L,{default:L}));export{We as i};
