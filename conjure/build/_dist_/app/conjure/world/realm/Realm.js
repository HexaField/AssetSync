import*as o from"https://cdn.skypack.dev/pin/three@v0.117.1-NetLzdTnw9ga3y6o633U/min/three.js";import u from"./Terrain.js";import l from"../features/FeatureArtGallery.js";import d from"../features/FeatureLobby.js";import{REALM_WORLD_GENERATORS as i}from"./RealmData.js";import c from"../Platform.js";import g from"./ObjectManager.js";import O from"../features/FeatureDiscord.js";import j from"../../../../../web_modules/events.js";import{NETWORKING_OPCODES as n}from"./NetworkingSchemas.js";export const GLOBAL_REALMS={LOBBY:{id:"Lobby",name:"Lobby",timestamp:0,worldSettings:{features:["Lobby"],worldGeneratorType:i.NONE}},GALLERY:{id:"Gallery",name:"Art Gallery",timestamp:0,worldData:{playsAudio:!0},worldSettings:{features:["Gallery"],worldGeneratorType:i.NONE}},CAMPFIRE:{id:"Campfire",name:"Campfire",timestamp:0,worldData:{playsAudio:!0},worldSettings:{features:["Campfire"],worldGeneratorType:i.NONE}}};export default class b extends j{constructor(e,t){super();this.world=e,this.conjure=this.world.conjure,this.group=new o.Group,this.world.group.add(this.group),this.objectLoader=new o.ObjectLoader,this.objectManager=new g(this),this.realmData=t,this.realmID=t.getID(),this.onObjectCreate=this.onObjectCreate.bind(this),this.onObjectUpdate=this.onObjectUpdate.bind(this),this.onObjectGroup=this.onObjectGroup.bind(this),this.onObjectMove=this.onObjectMove.bind(this),this.onObjectDestroy=this.onObjectDestroy.bind(this),this.vec3=new o.Vector3,this.quat=new o.Quaternion,this.features=[],this.loading=!0,this.networkProtocolCallbacks={}}sendData(e,t){this.conjure.assetSync.connectionPlugin.sendToAll(this.conjure.networkingSchemas.toBuffer(e,t))}sendTo(e,t,a){this.conjure.assetSync.connectionPlugin.sendToPeer(this.conjure.networkingSchemas.toBuffer(e,t),a)}async preload(){this.network=await this.conjure.assetSync.networkPlugin.joinNetwork(this.realmID),this.network.on("onMessage",(e,t,a)=>{this.emit(e,t,a)}),this.network.on("onPeerJoin",async e=>{console.log("User ",e," has join the realm");const t=this.conjure.assetSync.networkPlugin.getPeerID()>e,a=await this.conjure.assetSync.connectionPlugin.createConnection(e,t);console.log("isInitiator",t),a.on("ready",()=>{console.log("Direct connection establish to",e),this.sendData(n.USER.JOIN,{username:this.conjure.getProfile().getUsername()})}),t&&this.network.sendToPeer("connection.signal."+this.conjure.assetSync.networkPlugin.getPeerID(),a.peerData,e),this.on("connection.signal."+e,async(r,s)=>{if(s!==e)return;a.signal(r),t||a.on("signal",()=>{this.network.sendToPeer("connection.signal."+this.conjure.assetSync.networkPlugin.getPeerID(),a.peerData,e)})}),a.on("message",r=>{const{opcode:s,content:h}=this.conjure.networkingSchemas.fromBuffer(r);this.emit(s,h,e)})}),this.network.on("onPeerLeave",e=>{console.log("User ",e," has left the realm"),this.world.onUserLeave(e)}),this.realmData.getData().worldSettings.worldGeneratorType===i.INFINITE_WORLD&&(this.terrain=new u(this.conjure,this.world.group,this.realmData.getWorldSettings())),this.realmData.getData().worldData.playsAudio&&await this.conjure.getAudioManager().create(!0),await this.preloadFeatures()}async preloadFeatures(){for(let e of this.realmData.getData().worldSettings.features)switch(e){case"Gallery":{let t=new l(this);await t.preload(),this.features.push(t);break}case"Lobby":{let t=new d(this);this.terrain=new c(this.conjure,this.world.group),await t.preload(),this.features.push(t);break}case"Discord":{let t=new O(this);this.terrain=new c(this.conjure,this.world.group),await t.preload(),this.features.push(t);break}default:break}}async load(){for(let e of this.features)await e.load();this.loading=!1}async leave(){this.getObjectManager().destroyAllObjects(),await this.conjure.assetSync.networkPlugin.leaveNetwork(this.realmID),this.terrain&&this.terrain.destroy();for(let e of this.features)await e.unload();this.world.group.remove(this.group),console.log("successfully left realm")}getData(){return this.realmData.getData()}update(e){for(let t of this.features)t.update(e)}getObjectManager(){return this.objectManager}onObjectCreate(e){this.loadObjectFromPeer(e.uuid,e.data)}onObjectUpdate(e,t){console.log("onObjectUpdate",e)}onObjectGroup(e,t){this.objectManager.groupObjects(this.objectManager.getObjectByUUID(e.newParentUUID),this.objectManager.getObjectByUUID(e.newChildUUID),!0)}onObjectMove(e,t){for(let a of e.objects)this.objectManager.updateObjectFromClient(a.uuid,a.data)}async onObjectDestroy(e,t){await this.conjure.getDataHandler(SERVER_PROTOCOLS.DESTROY_OBJECT,{realmID:this.realmID,uuid:e}),this.objectManager.destroyObjectByHash(e)}async loadObjectFromPeer(e,t){try{await this.conjure.getDataHandler(SERVER_PROTOCOLS.CREATE_OBJECT,{realmID:this.realmID,uuid:e,data:t}),await this.loadObject(t)}catch(a){console.log("REALM: could not load object",object.hash,"with error",a)}}async createObject(e){e.userData.originatorID=this.conjure.getProfile().getID(),e.position.copy(this.world.user.previewMeshPoint.getWorldPosition(this.vec3)),e.quaternion.copy(this.world.user.previewMeshPoint.getWorldQuaternion(this.quat)),e.updateMatrixWorld(),this.restorePhysics(e);let t=await this.objectToJSON(e);this.conjure.screenManager.hideScreen();let a=await this.conjure.getDataHandler(SERVER_PROTOCOLS.CREATE_OBJECT,{realmID:this.realmID,uuid:e.uuid,data:t});a&&(this.objectManager.addObject(e),t=await this.objectToJSON(e),this.sendData(n.OBJECT.CREATE,{uuid:a.uuid,data:t}))}async objectToJSON(e){let t=e.toJSON();return t;if(t.images)for(let a=0;a<t.images.length;a++){if(t.images[a].url===this.conjure.assetManager.missingTextureData)continue;t.images[a].hash=await this.conjure.assetManager.createAsset(ASSET_TYPE.TEXTURE,t.images[a].url,t.images[a].uuid);let r=this.conjure.assetManager.getByIPFSHash(ASSET_TYPE.TEXTURE,t.images[a].hash).data.uuid;if(r!==t.images[a].uuid){if(t.textures)for(let s=0;s<t.textures.length;s++)t.textures[s].image===t.images[a].uuid&&(t.textures[s].image=r);t.images[a].uuid=r}t.images[a].url=""}}async loadObject(e){try{let t=this.loadObjectAssets(e);return await this.conjure.assetManager.saveAssets(t),this.restorePhysics(t),this.objectManager.addObject(t),e.object.userData.lastUpdate&&this.objectManager.updateObjectFromClient(t.uuid,e.object.userData.lastUpdate),!0}catch(t){return console.log(t,e),!1}}loadObjectAssets(e){return this.objectLoader.parse(e)}restorePhysics(e){e.userData.physics&&!e.body&&this.objectManager.getPhysicsType(e.userData.physics.type)>=0&&(this.conjure.physics.add.existing(e,{shape:this.objectManager.getPhysicsShape(e.userData.physics.shape),collisionFlags:this.objectManager.getPhysicsType(e.userData.physics.type),mass:e.userData.physics.mass}),e.body.setGravity(0,e.userData.physics.gravity*this.gravity,0),e.body.setBounciness(e.userData.physics.bounciness))}async updateObjectPosition(e){await this.updateObject(e)}async updateObject(e){if(!e)return;if(!e.uuid){console.log("Tried to update object without a hash! Are you sure this object is a top parent?");return}let t=await this.objectToJSON(e);await this.conjure.getDataHandler(SERVER_PROTOCOLS.UPDATE_OBJECT,{realmID:this.realmID,uuid:object.uuid,data:t})}async destroyObject(e){if(e.userData.markedDestroyed=!0,this.objectManager.getObject(e)){let t=await this.conjure.getDataHandler(SERVER_PROTOCOLS.DESTROY_OBJECT,{realmID:this.realmID,uuid:object.uuid});t?(this.objectManager.destroyObject(e),this.sendData(n.OBJECT.DESTROY,e.uuid,!0)):(e.userData.markedDestroyed=!1,console.log("failed to remove object",e.uuid))}else{let t=this.objectManager.getTopGroupObject(e);this.sendData(n.OBJECT.UPDATE,t,!0),this.objectManager.destroyObject(e,{isChild:!0}),await this.updateObject(t)}}}
