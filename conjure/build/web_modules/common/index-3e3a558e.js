import{c as dn,a as Eo}from"./_commonjsHelpers-c99fd594.js";var mi=dn(function(an,fe){Object.defineProperty(fe,"__esModule",{value:!0});const rt=h=>{console.error(`%c [enable3d] ${h} `,"background: #222; color: #bada55")};fe.default=rt}),Aa=dn(function(an){var fe=Object.prototype.hasOwnProperty,rt="~";function h(){}Object.create&&(h.prototype=Object.create(null),new h().__proto__||(rt=!1));function l(I,E,U){this.fn=I,this.context=E,this.once=U||!1}function f(I,E,U,G,Y){if(typeof U!="function")throw new TypeError("The listener must be a function");var we=new l(U,G||I,Y),Se=rt?rt+E:E;return I._events[Se]?I._events[Se].fn?I._events[Se]=[I._events[Se],we]:I._events[Se].push(we):(I._events[Se]=we,I._eventsCount++),I}function A(I,E){--I._eventsCount===0?I._events=new h:delete I._events[E]}function P(){this._events=new h,this._eventsCount=0}P.prototype.eventNames=function(){var E=[],U,G;if(this._eventsCount===0)return E;for(G in U=this._events)fe.call(U,G)&&E.push(rt?G.slice(1):G);return Object.getOwnPropertySymbols?E.concat(Object.getOwnPropertySymbols(U)):E},P.prototype.listeners=function(E){var U=rt?rt+E:E,G=this._events[U];if(!G)return[];if(G.fn)return[G.fn];for(var Y=0,we=G.length,Se=new Array(we);Y<we;Y++)Se[Y]=G[Y].fn;return Se},P.prototype.listenerCount=function(E){var U=rt?rt+E:E,G=this._events[U];return G?G.fn?1:G.length:0},P.prototype.emit=function(E,U,G,Y,we,Se){var Me=rt?rt+E:E;if(!this._events[Me])return!1;var T=this._events[Me],Z=arguments.length,J,L;if(T.fn){T.once&&this.removeListener(E,T.fn,void 0,!0);switch(Z){case 1:return T.fn.call(T.context),!0;case 2:return T.fn.call(T.context,U),!0;case 3:return T.fn.call(T.context,U,G),!0;case 4:return T.fn.call(T.context,U,G,Y),!0;case 5:return T.fn.call(T.context,U,G,Y,we),!0;case 6:return T.fn.call(T.context,U,G,Y,we,Se),!0}for(L=1,J=new Array(Z-1);L<Z;L++)J[L-1]=arguments[L];T.fn.apply(T.context,J)}else{var N=T.length,X;for(L=0;L<N;L++){T[L].once&&this.removeListener(E,T[L].fn,void 0,!0);switch(Z){case 1:T[L].fn.call(T[L].context);break;case 2:T[L].fn.call(T[L].context,U);break;case 3:T[L].fn.call(T[L].context,U,G);break;case 4:T[L].fn.call(T[L].context,U,G,Y);break;default:if(!J)for(X=1,J=new Array(Z-1);X<Z;X++)J[X-1]=arguments[X];T[L].fn.apply(T[L].context,J)}}}return!0},P.prototype.on=function(E,U,G){return f(this,E,U,G,!1)},P.prototype.once=function(E,U,G){return f(this,E,U,G,!0)},P.prototype.removeListener=function(E,U,G,Y){var we=rt?rt+E:E;if(!this._events[we])return this;if(!U)return A(this,we),this;var Se=this._events[we];if(Se.fn)Se.fn===U&&(!Y||Se.once)&&(!G||Se.context===G)&&A(this,we);else{for(var Me=0,T=[],Z=Se.length;Me<Z;Me++)(Se[Me].fn!==U||Y&&!Se[Me].once||G&&Se[Me].context!==G)&&T.push(Se[Me]);T.length?this._events[we]=T.length===1?T[0]:T:A(this,we)}return this},P.prototype.removeAllListeners=function(E){var U;return E?(U=rt?rt+E:E,this._events[U]&&A(this,U)):(this._events=new h,this._eventsCount=0),this},P.prototype.off=P.prototype.removeListener,P.prototype.addListener=P.prototype.on,P.prefixed=rt,P.EventEmitter=P,an.exports=P}),We=dn(function(an,fe){!function(rt,h){for(var l in h)rt[l]=h[l]}(fe,function(rt){var h={};function l(f){if(h[f])return h[f].exports;var A=h[f]={i:f,l:!1,exports:{}};return rt[f].call(A.exports,A,A.exports,l),A.l=!0,A.exports}return l.m=rt,l.c=h,l.d=function(f,A,P){l.o(f,A)||Object.defineProperty(f,A,{enumerable:!0,get:P})},l.r=function(f){typeof Symbol!="undefined"&&Symbol.toStringTag&&Object.defineProperty(f,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(f,"__esModule",{value:!0})},l.t=function(f,A){if(1&A&&(f=l(f)),8&A)return f;if(4&A&&typeof f=="object"&&f&&f.__esModule)return f;var P=Object.create(null);if(l.r(P),Object.defineProperty(P,"default",{enumerable:!0,value:f}),2&A&&typeof f!="string")for(var I in f)l.d(P,I,function(E){return f[E]}.bind(null,I));return P},l.n=function(f){var A=f&&f.__esModule?function(){return f.default}:function(){return f};return l.d(A,"a",A),A},l.o=function(f,A){return Object.prototype.hasOwnProperty.call(f,A)},l.p="",l(l.s=4)}([function(rt,h,l){l.r(h),l.d(h,"ACESFilmicToneMapping",function(){return B}),l.d(h,"AddEquation",function(){return Re}),l.d(h,"AddOperation",function(){return O}),l.d(h,"AdditiveAnimationBlendMode",function(){return sc}),l.d(h,"AdditiveBlending",function(){return oe}),l.d(h,"AlphaFormat",function(){return Jn}),l.d(h,"AlwaysDepth",function(){return Kt}),l.d(h,"AlwaysStencilFunc",function(){return Uu}),l.d(h,"AmbientLight",function(){return Is}),l.d(h,"AmbientLightProbe",function(){return Cl}),l.d(h,"AnimationClip",function(){return rr}),l.d(h,"AnimationLoader",function(){return dl}),l.d(h,"AnimationMixer",function(){return Ol}),l.d(h,"AnimationObjectGroup",function(){return vd}),l.d(h,"AnimationUtils",function(){return fn}),l.d(h,"ArcCurve",function(){return _o}),l.d(h,"ArrayCamera",function(){return Ka}),l.d(h,"ArrowHelper",function(){return Zm}),l.d(h,"Audio",function(){return Pl}),l.d(h,"AudioAnalyser",function(){return md}),l.d(h,"AudioContext",function(){return Al}),l.d(h,"AudioListener",function(){return Em}),l.d(h,"AudioLoader",function(){return ks}),l.d(h,"AxesHelper",function(){return Od}),l.d(h,"AxisHelper",function(){return Eg}),l.d(h,"BackSide",function(){return Z}),l.d(h,"BasicDepthPacking",function(){return Nu}),l.d(h,"BasicShadowMap",function(){return Y}),l.d(h,"BinaryTextureLoader",function(){return Rg}),l.d(h,"Bone",function(){return oa}),l.d(h,"BooleanKeyframeTrack",function(){return _s}),l.d(h,"BoundingBoxHelper",function(){return Ag}),l.d(h,"Box2",function(){return bd}),l.d(h,"Box3",function(){return Tr}),l.d(h,"Box3Helper",function(){return qm}),l.d(h,"BoxBufferGeometry",function(){return qo}),l.d(h,"BoxGeometry",function(){return Wc}),l.d(h,"BoxHelper",function(){return Pd}),l.d(h,"BufferAttribute",function(){return Rt}),l.d(h,"BufferGeometry",function(){return Ct}),l.d(h,"BufferGeometryLoader",function(){return Us}),l.d(h,"ByteType",function(){return on}),l.d(h,"Cache",function(){return Bi}),l.d(h,"Camera",function(){return Lr}),l.d(h,"CameraHelper",function(){return Xm}),l.d(h,"CanvasRenderer",function(){return Ig}),l.d(h,"CanvasTexture",function(){return ca}),l.d(h,"CatmullRomCurve3",function(){return Un}),l.d(h,"CineonToneMapping",function(){return H}),l.d(h,"CircleBufferGeometry",function(){return Xc}),l.d(h,"CircleGeometry",function(){return Nh}),l.d(h,"ClampToEdgeWrapping",function(){return v}),l.d(h,"Clock",function(){return hd}),l.d(h,"ClosedSplineCurve3",function(){return Hd}),l.d(h,"Color",function(){return _t}),l.d(h,"ColorKeyframeTrack",function(){return Ms}),l.d(h,"CompressedTexture",function(){return go}),l.d(h,"CompressedTextureLoader",function(){return pl}),l.d(h,"ConeBufferGeometry",function(){return Fh}),l.d(h,"ConeGeometry",function(){return Bh}),l.d(h,"CubeCamera",function(){return Ai}),l.d(h,"CubeGeometry",function(){return Wc}),l.d(h,"CubeReflectionMapping",function(){return ye}),l.d(h,"CubeRefractionMapping",function(){return _e}),l.d(h,"CubeTexture",function(){return Cr}),l.d(h,"CubeTextureLoader",function(){return Es}),l.d(h,"CubeUVReflectionMapping",function(){return pe}),l.d(h,"CubeUVRefractionMapping",function(){return Fe}),l.d(h,"CubicBezierCurve",function(){return xr}),l.d(h,"CubicBezierCurve3",function(){return Or}),l.d(h,"CubicInterpolant",function(){return bs}),l.d(h,"CullFaceBack",function(){return E}),l.d(h,"CullFaceFront",function(){return U}),l.d(h,"CullFaceFrontBack",function(){return G}),l.d(h,"CullFaceNone",function(){return I}),l.d(h,"Curve",function(){return Lt}),l.d(h,"CurvePath",function(){return Xr}),l.d(h,"CustomBlending",function(){return Pe}),l.d(h,"CustomToneMapping",function(){return w}),l.d(h,"CylinderBufferGeometry",function(){return ua}),l.d(h,"CylinderGeometry",function(){return qc}),l.d(h,"Cylindrical",function(){return zm}),l.d(h,"DataTexture",function(){return Vr}),l.d(h,"DataTexture2DArray",function(){return so}),l.d(h,"DataTexture3D",function(){return co}),l.d(h,"DataTextureLoader",function(){return As}),l.d(h,"DataUtils",function(){return Km}),l.d(h,"DecrementStencilOp",function(){return hp}),l.d(h,"DecrementWrapStencilOp",function(){return pp}),l.d(h,"DefaultLoadingManager",function(){return rd}),l.d(h,"DepthFormat",function(){return gi}),l.d(h,"DepthStencilFormat",function(){return Wi}),l.d(h,"DepthTexture",function(){return la}),l.d(h,"DirectionalLight",function(){return Ds}),l.d(h,"DirectionalLightHelper",function(){return Wm}),l.d(h,"DiscreteInterpolant",function(){return ws}),l.d(h,"DodecahedronBufferGeometry",function(){return Yc}),l.d(h,"DodecahedronGeometry",function(){return Uh}),l.d(h,"DoubleSide",function(){return J}),l.d(h,"DstAlphaFactor",function(){return Ot}),l.d(h,"DstColorFactor",function(){return Bt}),l.d(h,"DynamicBufferAttribute",function(){return gg}),l.d(h,"DynamicCopyUsage",function(){return Ap}),l.d(h,"DynamicDrawUsage",function(){return bi}),l.d(h,"DynamicReadUsage",function(){return Sp}),l.d(h,"EdgesGeometry",function(){return Jc}),l.d(h,"EdgesHelper",function(){return Lg}),l.d(h,"EllipseCurve",function(){return ir}),l.d(h,"EqualDepth",function(){return de}),l.d(h,"EqualStencilFunc",function(){return vp}),l.d(h,"EquirectangularReflectionMapping",function(){return W}),l.d(h,"EquirectangularRefractionMapping",function(){return ae}),l.d(h,"Euler",function(){return Io}),l.d(h,"EventDispatcher",function(){return Sr}),l.d(h,"ExtrudeBufferGeometry",function(){return fa}),l.d(h,"ExtrudeGeometry",function(){return $c}),l.d(h,"Face3",function(){return Bo}),l.d(h,"Face4",function(){return tg}),l.d(h,"FaceColors",function(){return og}),l.d(h,"FileLoader",function(){return ur}),l.d(h,"FlatShading",function(){return L}),l.d(h,"Float16BufferAttribute",function(){return Go}),l.d(h,"Float32Attribute",function(){return Sg}),l.d(h,"Float32BufferAttribute",function(){return yt}),l.d(h,"Float64Attribute",function(){return Tg}),l.d(h,"Float64BufferAttribute",function(){return Vo}),l.d(h,"FloatType",function(){return sn}),l.d(h,"Fog",function(){return Uc}),l.d(h,"FogExp2",function(){return Fc}),l.d(h,"Font",function(){return Tl}),l.d(h,"FontLoader",function(){return El}),l.d(h,"FrontSide",function(){return T}),l.d(h,"Frustum",function(){return Yo}),l.d(h,"GLBufferAttribute",function(){return Nl}),l.d(h,"GLSL1",function(){return Cp}),l.d(h,"GLSL3",function(){return hc}),l.d(h,"GammaEncoding",function(){return Oa}),l.d(h,"Geometry",function(){return rn}),l.d(h,"GeometryUtils",function(){return Dg}),l.d(h,"GreaterDepth",function(){return q}),l.d(h,"GreaterEqualDepth",function(){return re}),l.d(h,"GreaterEqualStencilFunc",function(){return wp}),l.d(h,"GreaterStencilFunc",function(){return xp}),l.d(h,"GridHelper",function(){return Ad}),l.d(h,"Group",function(){return ai}),l.d(h,"HalfFloatType",function(){return On}),l.d(h,"HemisphereLight",function(){return Ps}),l.d(h,"HemisphereLightHelper",function(){return Vm}),l.d(h,"HemisphereLightProbe",function(){return Ll}),l.d(h,"IcosahedronBufferGeometry",function(){return el}),l.d(h,"IcosahedronGeometry",function(){return Wh}),l.d(h,"ImageBitmapLoader",function(){return Ml}),l.d(h,"ImageLoader",function(){return wo}),l.d(h,"ImageUtils",function(){return wi}),l.d(h,"ImmediateRenderObject",function(){return wa}),l.d(h,"IncrementStencilOp",function(){return up}),l.d(h,"IncrementWrapStencilOp",function(){return dp}),l.d(h,"InstancedBufferAttribute",function(){return Fs}),l.d(h,"InstancedBufferGeometry",function(){return ba}),l.d(h,"InstancedInterleavedBuffer",function(){return Il}),l.d(h,"InstancedMesh",function(){return rs}),l.d(h,"Int16Attribute",function(){return bg}),l.d(h,"Int16BufferAttribute",function(){return ko}),l.d(h,"Int32Attribute",function(){return _g}),l.d(h,"Int32BufferAttribute",function(){return Ho}),l.d(h,"Int8Attribute",function(){return vg}),l.d(h,"Int8BufferAttribute",function(){return Fo}),l.d(h,"IntType",function(){return wn}),l.d(h,"InterleavedBuffer",function(){return tr}),l.d(h,"InterleavedBufferAttribute",function(){return si}),l.d(h,"Interpolant",function(){return nr}),l.d(h,"InterpolateDiscrete",function(){return Ao}),l.d(h,"InterpolateLinear",function(){return Lo}),l.d(h,"InterpolateSmooth",function(){return Pa}),l.d(h,"InvertStencilOp",function(){return fp}),l.d(h,"JSONLoader",function(){return Ng}),l.d(h,"KeepStencilOp",function(){return Ia}),l.d(h,"KeyframeTrack",function(){return Rn}),l.d(h,"LOD",function(){return ra}),l.d(h,"LatheBufferGeometry",function(){return tl}),l.d(h,"LatheGeometry",function(){return Xh}),l.d(h,"Layers",function(){return bc}),l.d(h,"LensFlare",function(){return Fg}),l.d(h,"LessDepth",function(){return Zt}),l.d(h,"LessEqualDepth",function(){return be}),l.d(h,"LessEqualStencilFunc",function(){return yp}),l.d(h,"LessStencilFunc",function(){return gp}),l.d(h,"Light",function(){return ln}),l.d(h,"LightProbe",function(){return hr}),l.d(h,"Line",function(){return lr}),l.d(h,"Line3",function(){return _d}),l.d(h,"LineBasicMaterial",function(){return mn}),l.d(h,"LineCurve",function(){return qn}),l.d(h,"LineCurve3",function(){return br}),l.d(h,"LineDashedMaterial",function(){return Ni}),l.d(h,"LineLoop",function(){return cs}),l.d(h,"LinePieces",function(){return rg}),l.d(h,"LineSegments",function(){return Wn}),l.d(h,"LineStrip",function(){return ng}),l.d(h,"LinearEncoding",function(){return Gn}),l.d(h,"LinearFilter",function(){return se}),l.d(h,"LinearInterpolant",function(){return ga}),l.d(h,"LinearMipMapLinearFilter",function(){return Et}),l.d(h,"LinearMipMapNearestFilter",function(){return it}),l.d(h,"LinearMipmapLinearFilter",function(){return Be}),l.d(h,"LinearMipmapNearestFilter",function(){return Ue}),l.d(h,"LinearToneMapping",function(){return V}),l.d(h,"Loader",function(){return en}),l.d(h,"LoaderUtils",function(){return _l}),l.d(h,"LoadingManager",function(){return hl}),l.d(h,"LogLuvEncoding",function(){return Iu}),l.d(h,"LoopOnce",function(){return Pu}),l.d(h,"LoopPingPong",function(){return Ou}),l.d(h,"LoopRepeat",function(){return Ru}),l.d(h,"LuminanceAlphaFormat",function(){return La}),l.d(h,"LuminanceFormat",function(){return ji}),l.d(h,"MOUSE",function(){return A}),l.d(h,"Material",function(){return Nt}),l.d(h,"MaterialLoader",function(){return Bs}),l.d(h,"Math",function(){return Ft}),l.d(h,"MathUtils",function(){return Ft}),l.d(h,"Matrix3",function(){return Vn}),l.d(h,"Matrix4",function(){return Ht}),l.d(h,"MaxEquation",function(){return lt}),l.d(h,"Mesh",function(){return pn}),l.d(h,"MeshBasicMaterial",function(){return sr}),l.d(h,"MeshDepthMaterial",function(){return ii}),l.d(h,"MeshDistanceMaterial",function(){return oi}),l.d(h,"MeshFaceMaterial",function(){return sg}),l.d(h,"MeshLambertMaterial",function(){return Di}),l.d(h,"MeshMatcapMaterial",function(){return Ii}),l.d(h,"MeshNormalMaterial",function(){return Oi}),l.d(h,"MeshPhongMaterial",function(){return hi}),l.d(h,"MeshPhysicalMaterial",function(){return ui}),l.d(h,"MeshStandardMaterial",function(){return Rr}),l.d(h,"MeshToonMaterial",function(){return Ri}),l.d(h,"MinEquation",function(){return Qe}),l.d(h,"MirroredRepeatWrapping",function(){return M}),l.d(h,"MixOperation",function(){return Oe}),l.d(h,"MultiMaterial",function(){return cg}),l.d(h,"MultiplyBlending",function(){return Te}),l.d(h,"MultiplyOperation",function(){return Ze}),l.d(h,"NearestFilter",function(){return y}),l.d(h,"NearestMipMapLinearFilter",function(){return ue}),l.d(h,"NearestMipMapNearestFilter",function(){return D}),l.d(h,"NearestMipmapLinearFilter",function(){return ie}),l.d(h,"NearestMipmapNearestFilter",function(){return _}),l.d(h,"NeverDepth",function(){return Yt}),l.d(h,"NeverStencilFunc",function(){return mp}),l.d(h,"NoBlending",function(){return X}),l.d(h,"NoColors",function(){return ig}),l.d(h,"NoToneMapping",function(){return C}),l.d(h,"NormalAnimationBlendMode",function(){return Ra}),l.d(h,"NormalBlending",function(){return Q}),l.d(h,"NotEqualDepth",function(){return he}),l.d(h,"NotEqualStencilFunc",function(){return bp}),l.d(h,"NumberKeyframeTrack",function(){return xo}),l.d(h,"Object3D",function(){return At}),l.d(h,"ObjectLoader",function(){return _m}),l.d(h,"ObjectSpaceNormalMap",function(){return Fu}),l.d(h,"OctahedronBufferGeometry",function(){return ys}),l.d(h,"OctahedronGeometry",function(){return qh}),l.d(h,"OneFactor",function(){return Ne}),l.d(h,"OneMinusDstAlphaFactor",function(){return It}),l.d(h,"OneMinusDstColorFactor",function(){return Wt}),l.d(h,"OneMinusSrcAlphaFactor",function(){return pt}),l.d(h,"OneMinusSrcColorFactor",function(){return $e}),l.d(h,"OrthographicCamera",function(){return Mo}),l.d(h,"PCFShadowMap",function(){return we}),l.d(h,"PCFSoftShadowMap",function(){return Se}),l.d(h,"PMREMGenerator",function(){return Qm}),l.d(h,"ParametricBufferGeometry",function(){return yo}),l.d(h,"ParametricGeometry",function(){return ma}),l.d(h,"Particle",function(){return ug}),l.d(h,"ParticleBasicMaterial",function(){return pg}),l.d(h,"ParticleSystem",function(){return hg}),l.d(h,"ParticleSystemMaterial",function(){return fg}),l.d(h,"Path",function(){return Mr}),l.d(h,"PerspectiveCamera",function(){return _n}),l.d(h,"Plane",function(){return Er}),l.d(h,"PlaneBufferGeometry",function(){return Ja}),l.d(h,"PlaneGeometry",function(){return Yh}),l.d(h,"PlaneHelper",function(){return Ym}),l.d(h,"PointCloud",function(){return lg}),l.d(h,"PointCloudMaterial",function(){return dg}),l.d(h,"PointLight",function(){return Os}),l.d(h,"PointLightHelper",function(){return Hm}),l.d(h,"Points",function(){return mo}),l.d(h,"PointsMaterial",function(){return vr}),l.d(h,"PolarGridHelper",function(){return jm}),l.d(h,"PolyhedronBufferGeometry",function(){return Ci}),l.d(h,"PolyhedronGeometry",function(){return Zh}),l.d(h,"PositionalAudio",function(){return Lm}),l.d(h,"PropertyBinding",function(){return zn}),l.d(h,"PropertyMixer",function(){return Rl}),l.d(h,"QuadraticBezierCurve",function(){return wr}),l.d(h,"QuadraticBezierCurve3",function(){return Dr}),l.d(h,"Quaternion",function(){return Nn}),l.d(h,"QuaternionKeyframeTrack",function(){return va}),l.d(h,"QuaternionLinearInterpolant",function(){return Ss}),l.d(h,"REVISION",function(){return f}),l.d(h,"RGBADepthPacking",function(){return Bu}),l.d(h,"RGBAFormat",function(){return In}),l.d(h,"RGBAIntegerFormat",function(){return $l}),l.d(h,"RGBA_ASTC_10x10_Format",function(){return du}),l.d(h,"RGBA_ASTC_10x5_Format",function(){return lu}),l.d(h,"RGBA_ASTC_10x6_Format",function(){return uu}),l.d(h,"RGBA_ASTC_10x8_Format",function(){return hu}),l.d(h,"RGBA_ASTC_12x10_Format",function(){return pu}),l.d(h,"RGBA_ASTC_12x12_Format",function(){return fu}),l.d(h,"RGBA_ASTC_4x4_Format",function(){return tu}),l.d(h,"RGBA_ASTC_5x4_Format",function(){return nu}),l.d(h,"RGBA_ASTC_5x5_Format",function(){return ru}),l.d(h,"RGBA_ASTC_6x5_Format",function(){return iu}),l.d(h,"RGBA_ASTC_6x6_Format",function(){return ou}),l.d(h,"RGBA_ASTC_8x5_Format",function(){return au}),l.d(h,"RGBA_ASTC_8x6_Format",function(){return su}),l.d(h,"RGBA_ASTC_8x8_Format",function(){return cu}),l.d(h,"RGBA_BPTC_Format",function(){return mu}),l.d(h,"RGBA_ETC2_EAC_Format",function(){return ac}),l.d(h,"RGBA_PVRTC_2BPPV1_Format",function(){return ic}),l.d(h,"RGBA_PVRTC_4BPPV1_Format",function(){return rc}),l.d(h,"RGBA_S3TC_DXT1_Format",function(){return Qs}),l.d(h,"RGBA_S3TC_DXT3_Format",function(){return $s}),l.d(h,"RGBA_S3TC_DXT5_Format",function(){return ec}),l.d(h,"RGBDEncoding",function(){return uc}),l.d(h,"RGBEEncoding",function(){return Da}),l.d(h,"RGBEFormat",function(){return Ca}),l.d(h,"RGBFormat",function(){return En}),l.d(h,"RGBIntegerFormat",function(){return Ql}),l.d(h,"RGBM16Encoding",function(){return lc}),l.d(h,"RGBM7Encoding",function(){return cc}),l.d(h,"RGB_ETC1_Format",function(){return eu}),l.d(h,"RGB_ETC2_Format",function(){return oc}),l.d(h,"RGB_PVRTC_2BPPV1_Format",function(){return nc}),l.d(h,"RGB_PVRTC_4BPPV1_Format",function(){return tc}),l.d(h,"RGB_S3TC_DXT1_Format",function(){return Ks}),l.d(h,"RGFormat",function(){return Jl}),l.d(h,"RGIntegerFormat",function(){return Kl}),l.d(h,"RawShaderMaterial",function(){return Wr}),l.d(h,"Ray",function(){return Ji}),l.d(h,"Raycaster",function(){return Bl}),l.d(h,"RectAreaLight",function(){return Ns}),l.d(h,"RedFormat",function(){return Yl}),l.d(h,"RedIntegerFormat",function(){return Zl}),l.d(h,"ReinhardToneMapping",function(){return j}),l.d(h,"RepeatWrapping",function(){return Ce}),l.d(h,"ReplaceStencilOp",function(){return lp}),l.d(h,"ReverseSubtractEquation",function(){return Ye}),l.d(h,"RingBufferGeometry",function(){return nl}),l.d(h,"RingGeometry",function(){return Jh}),l.d(h,"SRGB8_ALPHA8_ASTC_10x10_Format",function(){return Au}),l.d(h,"SRGB8_ALPHA8_ASTC_10x5_Format",function(){return Su}),l.d(h,"SRGB8_ALPHA8_ASTC_10x6_Format",function(){return Tu}),l.d(h,"SRGB8_ALPHA8_ASTC_10x8_Format",function(){return Eu}),l.d(h,"SRGB8_ALPHA8_ASTC_12x10_Format",function(){return Lu}),l.d(h,"SRGB8_ALPHA8_ASTC_12x12_Format",function(){return Cu}),l.d(h,"SRGB8_ALPHA8_ASTC_4x4_Format",function(){return gu}),l.d(h,"SRGB8_ALPHA8_ASTC_5x4_Format",function(){return vu}),l.d(h,"SRGB8_ALPHA8_ASTC_5x5_Format",function(){return yu}),l.d(h,"SRGB8_ALPHA8_ASTC_6x5_Format",function(){return xu}),l.d(h,"SRGB8_ALPHA8_ASTC_6x6_Format",function(){return bu}),l.d(h,"SRGB8_ALPHA8_ASTC_8x5_Format",function(){return wu}),l.d(h,"SRGB8_ALPHA8_ASTC_8x6_Format",function(){return _u}),l.d(h,"SRGB8_ALPHA8_ASTC_8x8_Format",function(){return Mu}),l.d(h,"Scene",function(){return zc}),l.d(h,"SceneUtils",function(){return Bg}),l.d(h,"ShaderChunk",function(){return Vt}),l.d(h,"ShaderLib",function(){return gr}),l.d(h,"ShaderMaterial",function(){return jn}),l.d(h,"ShadowMaterial",function(){return Pi}),l.d(h,"Shape",function(){return di}),l.d(h,"ShapeBufferGeometry",function(){return rl}),l.d(h,"ShapeGeometry",function(){return il}),l.d(h,"ShapePath",function(){return Sl}),l.d(h,"ShapeUtils",function(){return jr}),l.d(h,"ShortType",function(){return Qt}),l.d(h,"Skeleton",function(){return aa}),l.d(h,"SkeletonHelper",function(){return Sd}),l.d(h,"SkinnedMesh",function(){return ia}),l.d(h,"SmoothShading",function(){return N}),l.d(h,"Sphere",function(){return Fr}),l.d(h,"SphereBufferGeometry",function(){return xs}),l.d(h,"SphereGeometry",function(){return Kh}),l.d(h,"Spherical",function(){return Um}),l.d(h,"SphericalHarmonics3",function(){return od}),l.d(h,"Spline",function(){return jl}),l.d(h,"SplineCurve",function(){return _r}),l.d(h,"SplineCurve3",function(){return Gd}),l.d(h,"SpotLight",function(){return Rs}),l.d(h,"SpotLightHelper",function(){return km}),l.d(h,"Sprite",function(){return na}),l.d(h,"SpriteMaterial",function(){return ci}),l.d(h,"SrcAlphaFactor",function(){return ut}),l.d(h,"SrcAlphaSaturateFactor",function(){return Tt}),l.d(h,"SrcColorFactor",function(){return at}),l.d(h,"StaticCopyUsage",function(){return Ep}),l.d(h,"StaticDrawUsage",function(){return Ro}),l.d(h,"StaticReadUsage",function(){return Mp}),l.d(h,"StereoCamera",function(){return ud}),l.d(h,"StreamCopyUsage",function(){return Lp}),l.d(h,"StreamDrawUsage",function(){return _p}),l.d(h,"StreamReadUsage",function(){return Tp}),l.d(h,"StringKeyframeTrack",function(){return Ts}),l.d(h,"SubtractEquation",function(){return Ee}),l.d(h,"SubtractiveBlending",function(){return me}),l.d(h,"TOUCH",function(){return P}),l.d(h,"TangentSpaceNormalMap",function(){return xi}),l.d(h,"TetrahedronBufferGeometry",function(){return ol}),l.d(h,"TetrahedronGeometry",function(){return Qh}),l.d(h,"TextBufferGeometry",function(){return al}),l.d(h,"TextGeometry",function(){return $h}),l.d(h,"Texture",function(){return tn}),l.d(h,"TextureLoader",function(){return Ls}),l.d(h,"TorusBufferGeometry",function(){return sl}),l.d(h,"TorusGeometry",function(){return ed}),l.d(h,"TorusKnotBufferGeometry",function(){return cl}),l.d(h,"TorusKnotGeometry",function(){return td}),l.d(h,"Triangle",function(){return Bn}),l.d(h,"TriangleFanDrawMode",function(){return sp}),l.d(h,"TriangleStripDrawMode",function(){return ap}),l.d(h,"TrianglesDrawMode",function(){return Du}),l.d(h,"TubeBufferGeometry",function(){return ll}),l.d(h,"TubeGeometry",function(){return nd}),l.d(h,"UVMapping",function(){return $}),l.d(h,"Uint16Attribute",function(){return wg}),l.d(h,"Uint16BufferAttribute",function(){return Si}),l.d(h,"Uint32Attribute",function(){return Mg}),l.d(h,"Uint32BufferAttribute",function(){return Ti}),l.d(h,"Uint8Attribute",function(){return yg}),l.d(h,"Uint8BufferAttribute",function(){return Uo}),l.d(h,"Uint8ClampedAttribute",function(){return xg}),l.d(h,"Uint8ClampedBufferAttribute",function(){return zo}),l.d(h,"Uniform",function(){return Dl}),l.d(h,"UniformsLib",function(){return mt}),l.d(h,"UniformsUtils",function(){return Qu}),l.d(h,"UnsignedByteType",function(){return bt}),l.d(h,"UnsignedInt248Type",function(){return Tn}),l.d(h,"UnsignedIntType",function(){return gn}),l.d(h,"UnsignedShort4444Type",function(){return Zn}),l.d(h,"UnsignedShort5551Type",function(){return Dn}),l.d(h,"UnsignedShort565Type",function(){return Cn}),l.d(h,"UnsignedShortType",function(){return Xt}),l.d(h,"VSMShadowMap",function(){return Me}),l.d(h,"Vector2",function(){return Je}),l.d(h,"Vector3",function(){return z}),l.d(h,"Vector4",function(){return nn}),l.d(h,"VectorKeyframeTrack",function(){return bo}),l.d(h,"Vertex",function(){return mg}),l.d(h,"VertexColors",function(){return ag}),l.d(h,"VideoTexture",function(){return Vc}),l.d(h,"WebGL1Renderer",function(){return Bc}),l.d(h,"WebGLCubeRenderTarget",function(){return Gr}),l.d(h,"WebGLMultisampleRenderTarget",function(){return pc}),l.d(h,"WebGLRenderTarget",function(){return Kn}),l.d(h,"WebGLRenderTargetCube",function(){return Og}),l.d(h,"WebGLRenderer",function(){return Qo}),l.d(h,"WebGLUtils",function(){return _h}),l.d(h,"WireframeGeometry",function(){return ul}),l.d(h,"WireframeHelper",function(){return Cg}),l.d(h,"WrapAroundEnding",function(){return Co}),l.d(h,"XHRLoader",function(){return Pg}),l.d(h,"ZeroCurvatureEnding",function(){return vi}),l.d(h,"ZeroFactor",function(){return ot}),l.d(h,"ZeroSlopeEnding",function(){return yi}),l.d(h,"ZeroStencilOp",function(){return cp}),l.d(h,"sRGBEncoding",function(){return Po});const f="123",A={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2},P={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},I=0,E=1,U=2,G=3,Y=0,we=1,Se=2,Me=3,T=0,Z=1,J=2,L=1,N=2,X=0,Q=1,oe=2,me=3,Te=4,Pe=5,Re=100,Ee=101,Ye=102,Qe=103,lt=104,ot=200,Ne=201,at=202,$e=203,ut=204,pt=205,Ot=206,It=207,Bt=208,Wt=209,Tt=210,Yt=0,Kt=1,Zt=2,be=3,de=4,re=5,q=6,he=7,Ze=0,Oe=1,O=2,C=0,V=1,j=2,H=3,B=4,w=5,$=300,ye=301,_e=302,W=303,ae=304,pe=306,Fe=307,Ce=1e3,v=1001,M=1002,y=1003,_=1004,D=1004,ie=1005,ue=1005,se=1006,Ue=1007,it=1007,Be=1008,Et=1008,bt=1009,on=1010,Qt=1011,Xt=1012,wn=1013,gn=1014,sn=1015,On=1016,Zn=1017,Dn=1018,Cn=1019,Tn=1020,Jn=1021,En=1022,In=1023,ji=1024,La=1025,Ca=In,gi=1026,Wi=1027,Yl=1028,Zl=1029,Jl=1030,Kl=1031,Ql=1032,$l=1033,Ks=33776,Qs=33777,$s=33778,ec=33779,tc=35840,nc=35841,rc=35842,ic=35843,eu=36196,oc=37492,ac=37496,tu=37808,nu=37809,ru=37810,iu=37811,ou=37812,au=37813,su=37814,cu=37815,lu=37816,uu=37817,hu=37818,du=37819,pu=37820,fu=37821,mu=36492,gu=37840,vu=37841,yu=37842,xu=37843,bu=37844,wu=37845,_u=37846,Mu=37847,Su=37848,Tu=37849,Eu=37850,Au=37851,Lu=37852,Cu=37853,Pu=2200,Ru=2201,Ou=2202,Ao=2300,Lo=2301,Pa=2302,vi=2400,yi=2401,Co=2402,Ra=2500,sc=2501,Du=0,ap=1,sp=2,Gn=3e3,Po=3001,Oa=3007,Da=3002,Iu=3003,cc=3004,lc=3005,uc=3006,Nu=3200,Bu=3201,xi=0,Fu=1,cp=0,Ia=7680,lp=7681,up=7682,hp=7683,dp=34055,pp=34056,fp=5386,mp=512,gp=513,vp=514,yp=515,xp=516,bp=517,wp=518,Uu=519,Ro=35044,bi=35048,_p=35040,Mp=35045,Sp=35049,Tp=35041,Ep=35046,Ap=35050,Lp=35042,Cp="100",hc="300 es";function Sr(){}Object.assign(Sr.prototype,{addEventListener:function(e,t){this._listeners===void 0&&(this._listeners={});const n=this._listeners;n[e]===void 0&&(n[e]=[]),n[e].indexOf(t)===-1&&n[e].push(t)},hasEventListener:function(e,t){if(this._listeners===void 0)return!1;const n=this._listeners;return n[e]!==void 0&&n[e].indexOf(t)!==-1},removeEventListener:function(e,t){if(this._listeners===void 0)return;const n=this._listeners[e];if(n!==void 0){const r=n.indexOf(t);r!==-1&&n.splice(r,1)}},dispatchEvent:function(e){if(this._listeners===void 0)return;const t=this._listeners[e.type];if(t!==void 0){e.target=this;const n=t.slice(0);for(let r=0,i=n.length;r<i;r++)n[r].call(this,e)}}});const Pn=[];for(let e=0;e<256;e++)Pn[e]=(e<16?"0":"")+e.toString(16);let Na=1234567;const Ft={DEG2RAD:Math.PI/180,RAD2DEG:180/Math.PI,generateUUID:function(){const e=4294967295*Math.random()|0,t=4294967295*Math.random()|0,n=4294967295*Math.random()|0,r=4294967295*Math.random()|0;return(Pn[255&e]+Pn[e>>8&255]+Pn[e>>16&255]+Pn[e>>24&255]+"-"+Pn[255&t]+Pn[t>>8&255]+"-"+Pn[t>>16&15|64]+Pn[t>>24&255]+"-"+Pn[63&n|128]+Pn[n>>8&255]+"-"+Pn[n>>16&255]+Pn[n>>24&255]+Pn[255&r]+Pn[r>>8&255]+Pn[r>>16&255]+Pn[r>>24&255]).toUpperCase()},clamp:function(e,t,n){return Math.max(t,Math.min(n,e))},euclideanModulo:function(e,t){return(e%t+t)%t},mapLinear:function(e,t,n,r,i){return r+(e-t)*(i-r)/(n-t)},lerp:function(e,t,n){return(1-n)*e+n*t},smoothstep:function(e,t,n){return e<=t?0:e>=n?1:(e=(e-t)/(n-t))*e*(3-2*e)},smootherstep:function(e,t,n){return e<=t?0:e>=n?1:(e=(e-t)/(n-t))*e*e*(e*(6*e-15)+10)},randInt:function(e,t){return e+Math.floor(Math.random()*(t-e+1))},randFloat:function(e,t){return e+Math.random()*(t-e)},randFloatSpread:function(e){return e*(.5-Math.random())},seededRandom:function(e){return e!==void 0&&(Na=e%2147483647),Na=16807*Na%2147483647,(Na-1)/2147483646},degToRad:function(e){return e*Ft.DEG2RAD},radToDeg:function(e){return e*Ft.RAD2DEG},isPowerOfTwo:function(e){return(e&e-1)==0&&e!==0},ceilPowerOfTwo:function(e){return Math.pow(2,Math.ceil(Math.log(e)/Math.LN2))},floorPowerOfTwo:function(e){return Math.pow(2,Math.floor(Math.log(e)/Math.LN2))},setQuaternionFromProperEuler:function(e,t,n,r,i){const o=Math.cos,a=Math.sin,s=o(n/2),c=a(n/2),u=o((t+r)/2),p=a((t+r)/2),d=o((t-r)/2),g=a((t-r)/2),m=o((r-t)/2),x=a((r-t)/2);switch(i){case"XYX":e.set(s*p,c*d,c*g,s*u);break;case"YZY":e.set(c*g,s*p,c*d,s*u);break;case"ZXZ":e.set(c*d,c*g,s*p,s*u);break;case"XZX":e.set(s*p,c*x,c*m,s*u);break;case"YXY":e.set(c*m,s*p,c*x,s*u);break;case"ZYZ":e.set(c*x,c*m,s*p,s*u);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+i)}}};class Je{constructor(e=0,t=0){Object.defineProperty(this,"isVector2",{value:!0}),this.x=e,this.y=t}get width(){return this.x}set width(e){this.x=e}get height(){return this.y}set height(e){this.y=e}set(e,t){return this.x=e,this.y=t,this}setScalar(e){return this.x=e,this.y=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y)}copy(e){return this.x=e.x,this.y=e.y,this}add(e,t){return t!==void 0?(console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this)}addScalar(e){return this.x+=e,this.y+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this}sub(e,t){return t!==void 0?(console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this)}subScalar(e){return this.x-=e,this.y-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this}multiply(e){return this.x*=e.x,this.y*=e.y,this}multiplyScalar(e){return this.x*=e,this.y*=e,this}divide(e){return this.x/=e.x,this.y/=e.y,this}divideScalar(e){return this.multiplyScalar(1/e)}applyMatrix3(e){const t=this.x,n=this.y,r=e.elements;return this.x=r[0]*t+r[3]*n+r[6],this.y=r[1]*t+r[4]*n+r[7],this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this}clampLength(e,t){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(e,Math.min(t,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(e){return this.x*e.x+this.y*e.y}cross(e){return this.x*e.y-this.y*e.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,n=this.y-e.y;return t*t+n*n}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this}lerpVectors(e,t,n){return this.x=e.x+(t.x-e.x)*n,this.y=e.y+(t.y-e.y)*n,this}equals(e){return e.x===this.x&&e.y===this.y}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e}fromBufferAttribute(e,t,n){return n!==void 0&&console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this}rotateAround(e,t){const n=Math.cos(t),r=Math.sin(t),i=this.x-e.x,o=this.y-e.y;return this.x=i*n-o*r+e.x,this.y=i*r+o*n+e.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}}class Vn{constructor(){Object.defineProperty(this,"isMatrix3",{value:!0}),this.elements=[1,0,0,0,1,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")}set(e,t,n,r,i,o,a,s,c){const u=this.elements;return u[0]=e,u[1]=r,u[2]=a,u[3]=t,u[4]=i,u[5]=s,u[6]=n,u[7]=o,u[8]=c,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}clone(){return new this.constructor().fromArray(this.elements)}copy(e){const t=this.elements,n=e.elements;return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],this}extractBasis(e,t,n){return e.setFromMatrix3Column(this,0),t.setFromMatrix3Column(this,1),n.setFromMatrix3Column(this,2),this}setFromMatrix4(e){const t=e.elements;return this.set(t[0],t[4],t[8],t[1],t[5],t[9],t[2],t[6],t[10]),this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const n=e.elements,r=t.elements,i=this.elements,o=n[0],a=n[3],s=n[6],c=n[1],u=n[4],p=n[7],d=n[2],g=n[5],m=n[8],x=r[0],S=r[3],b=r[6],R=r[1],F=r[4],ee=r[7],k=r[2],K=r[5],le=r[8];return i[0]=o*x+a*R+s*k,i[3]=o*S+a*F+s*K,i[6]=o*b+a*ee+s*le,i[1]=c*x+u*R+p*k,i[4]=c*S+u*F+p*K,i[7]=c*b+u*ee+p*le,i[2]=d*x+g*R+m*k,i[5]=d*S+g*F+m*K,i[8]=d*b+g*ee+m*le,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[3]*=e,t[6]*=e,t[1]*=e,t[4]*=e,t[7]*=e,t[2]*=e,t[5]*=e,t[8]*=e,this}determinant(){const e=this.elements,t=e[0],n=e[1],r=e[2],i=e[3],o=e[4],a=e[5],s=e[6],c=e[7],u=e[8];return t*o*u-t*a*c-n*i*u+n*a*s+r*i*c-r*o*s}invert(){const e=this.elements,t=e[0],n=e[1],r=e[2],i=e[3],o=e[4],a=e[5],s=e[6],c=e[7],u=e[8],p=u*o-a*c,d=a*s-u*i,g=c*i-o*s,m=t*p+n*d+r*g;if(m===0)return this.set(0,0,0,0,0,0,0,0,0);const x=1/m;return e[0]=p*x,e[1]=(r*c-u*n)*x,e[2]=(a*n-r*o)*x,e[3]=d*x,e[4]=(u*t-r*s)*x,e[5]=(r*i-a*t)*x,e[6]=g*x,e[7]=(n*s-c*t)*x,e[8]=(o*t-n*i)*x,this}transpose(){let e;const t=this.elements;return e=t[1],t[1]=t[3],t[3]=e,e=t[2],t[2]=t[6],t[6]=e,e=t[5],t[5]=t[7],t[7]=e,this}getNormalMatrix(e){return this.setFromMatrix4(e).copy(this).invert().transpose()}transposeIntoArray(e){const t=this.elements;return e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8],this}setUvTransform(e,t,n,r,i,o,a){const s=Math.cos(i),c=Math.sin(i);this.set(n*s,n*c,-n*(s*o+c*a)+o+e,-r*c,r*s,-r*(-c*o+s*a)+a+t,0,0,1)}scale(e,t){const n=this.elements;return n[0]*=e,n[3]*=e,n[6]*=e,n[1]*=t,n[4]*=t,n[7]*=t,this}rotate(e){const t=Math.cos(e),n=Math.sin(e),r=this.elements,i=r[0],o=r[3],a=r[6],s=r[1],c=r[4],u=r[7];return r[0]=t*i+n*s,r[3]=t*o+n*c,r[6]=t*a+n*u,r[1]=-n*i+t*s,r[4]=-n*o+t*c,r[7]=-n*a+t*u,this}translate(e,t){const n=this.elements;return n[0]+=e*n[2],n[3]+=e*n[5],n[6]+=e*n[8],n[1]+=t*n[2],n[4]+=t*n[5],n[7]+=t*n[8],this}equals(e){const t=this.elements,n=e.elements;for(let r=0;r<9;r++)if(t[r]!==n[r])return!1;return!0}fromArray(e,t=0){for(let n=0;n<9;n++)this.elements[n]=e[n+t];return this}toArray(e=[],t=0){const n=this.elements;return e[t]=n[0],e[t+1]=n[1],e[t+2]=n[2],e[t+3]=n[3],e[t+4]=n[4],e[t+5]=n[5],e[t+6]=n[6],e[t+7]=n[7],e[t+8]=n[8],e}}let Xi;const wi={getDataURL:function(e){if(/^data:/i.test(e.src))return e.src;if(typeof HTMLCanvasElement=="undefined")return e.src;let t;if(e instanceof HTMLCanvasElement)t=e;else{Xi===void 0&&(Xi=document.createElementNS("http://www.w3.org/1999/xhtml","canvas")),Xi.width=e.width,Xi.height=e.height;const n=Xi.getContext("2d");e instanceof ImageData?n.putImageData(e,0,0):n.drawImage(e,0,0,e.width,e.height),t=Xi}return t.width>2048||t.height>2048?t.toDataURL("image/jpeg",.6):t.toDataURL("image/png")}};let Pp=0;function tn(e=tn.DEFAULT_IMAGE,t=tn.DEFAULT_MAPPING,n=v,r=v,i=se,o=Be,a=In,s=bt,c=1,u=Gn){Object.defineProperty(this,"id",{value:Pp++}),this.uuid=Ft.generateUUID(),this.name="",this.image=e,this.mipmaps=[],this.mapping=t,this.wrapS=n,this.wrapT=r,this.magFilter=i,this.minFilter=o,this.anisotropy=c,this.format=a,this.internalFormat=null,this.type=s,this.offset=new Je(0,0),this.repeat=new Je(1,1),this.center=new Je(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new Vn,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.encoding=u,this.version=0,this.onUpdate=null}function dc(e){return typeof HTMLImageElement!="undefined"&&e instanceof HTMLImageElement||typeof HTMLCanvasElement!="undefined"&&e instanceof HTMLCanvasElement||typeof ImageBitmap!="undefined"&&e instanceof ImageBitmap?wi.getDataURL(e):e.data?{data:Array.prototype.slice.call(e.data),width:e.width,height:e.height,type:e.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}tn.DEFAULT_IMAGE=void 0,tn.DEFAULT_MAPPING=$,tn.prototype=Object.assign(Object.create(Sr.prototype),{constructor:tn,isTexture:!0,updateMatrix:function(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)},clone:function(){return new this.constructor().copy(this)},copy:function(e){return this.name=e.name,this.image=e.image,this.mipmaps=e.mipmaps.slice(0),this.mapping=e.mapping,this.wrapS=e.wrapS,this.wrapT=e.wrapT,this.magFilter=e.magFilter,this.minFilter=e.minFilter,this.anisotropy=e.anisotropy,this.format=e.format,this.internalFormat=e.internalFormat,this.type=e.type,this.offset.copy(e.offset),this.repeat.copy(e.repeat),this.center.copy(e.center),this.rotation=e.rotation,this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrix.copy(e.matrix),this.generateMipmaps=e.generateMipmaps,this.premultiplyAlpha=e.premultiplyAlpha,this.flipY=e.flipY,this.unpackAlignment=e.unpackAlignment,this.encoding=e.encoding,this},toJSON:function(e){const t=e===void 0||typeof e=="string";if(!t&&e.textures[this.uuid]!==void 0)return e.textures[this.uuid];const n={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};if(this.image!==void 0){const r=this.image;if(r.uuid===void 0&&(r.uuid=Ft.generateUUID()),!t&&e.images[r.uuid]===void 0){let i;if(Array.isArray(r)){i=[];for(let o=0,a=r.length;o<a;o++)r[o].isDataTexture?i.push(dc(r[o].image)):i.push(dc(r[o]))}else i=dc(r);e.images[r.uuid]={uuid:r.uuid,url:i}}n.image=r.uuid}return t||(e.textures[this.uuid]=n),n},dispose:function(){this.dispatchEvent({type:"dispose"})},transformUv:function(e){if(this.mapping!==$)return e;if(e.applyMatrix3(this.matrix),e.x<0||e.x>1)switch(this.wrapS){case Ce:e.x=e.x-Math.floor(e.x);break;case v:e.x=e.x<0?0:1;break;case M:Math.abs(Math.floor(e.x)%2)===1?e.x=Math.ceil(e.x)-e.x:e.x=e.x-Math.floor(e.x)}if(e.y<0||e.y>1)switch(this.wrapT){case Ce:e.y=e.y-Math.floor(e.y);break;case v:e.y=e.y<0?0:1;break;case M:Math.abs(Math.floor(e.y)%2)===1?e.y=Math.ceil(e.y)-e.y:e.y=e.y-Math.floor(e.y)}return this.flipY&&(e.y=1-e.y),e}}),Object.defineProperty(tn.prototype,"needsUpdate",{set:function(e){e===!0&&this.version++}});class nn{constructor(e=0,t=0,n=0,r=1){Object.defineProperty(this,"isVector4",{value:!0}),this.x=e,this.y=t,this.z=n,this.w=r}get width(){return this.z}set width(e){this.z=e}get height(){return this.w}set height(e){this.w=e}set(e,t,n,r){return this.x=e,this.y=t,this.z=n,this.w=r,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this.w=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setW(e){return this.w=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;case 3:this.w=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w!==void 0?e.w:1,this}add(e,t){return t!==void 0?(console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this.z+=e.z,this.w+=e.w,this)}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this.w+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this.w=e.w+t.w,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this.w+=e.w*t,this}sub(e,t){return t!==void 0?(console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this.z-=e.z,this.w-=e.w,this)}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this.w-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this.w=e.w-t.w,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this.w*=e,this}applyMatrix4(e){const t=this.x,n=this.y,r=this.z,i=this.w,o=e.elements;return this.x=o[0]*t+o[4]*n+o[8]*r+o[12]*i,this.y=o[1]*t+o[5]*n+o[9]*r+o[13]*i,this.z=o[2]*t+o[6]*n+o[10]*r+o[14]*i,this.w=o[3]*t+o[7]*n+o[11]*r+o[15]*i,this}divideScalar(e){return this.multiplyScalar(1/e)}setAxisAngleFromQuaternion(e){this.w=2*Math.acos(e.w);const t=Math.sqrt(1-e.w*e.w);return t<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=e.x/t,this.y=e.y/t,this.z=e.z/t),this}setAxisAngleFromRotationMatrix(e){let t,n,r,i;const o=e.elements,a=o[0],s=o[4],c=o[8],u=o[1],p=o[5],d=o[9],g=o[2],m=o[6],x=o[10];if(Math.abs(s-u)<.01&&Math.abs(c-g)<.01&&Math.abs(d-m)<.01){if(Math.abs(s+u)<.1&&Math.abs(c+g)<.1&&Math.abs(d+m)<.1&&Math.abs(a+p+x-3)<.1)return this.set(1,0,0,0),this;t=Math.PI;const b=(a+1)/2,R=(p+1)/2,F=(x+1)/2,ee=(s+u)/4,k=(c+g)/4,K=(d+m)/4;return b>R&&b>F?b<.01?(n=0,r=.707106781,i=.707106781):(n=Math.sqrt(b),r=ee/n,i=k/n):R>F?R<.01?(n=.707106781,r=0,i=.707106781):(r=Math.sqrt(R),n=ee/r,i=K/r):F<.01?(n=.707106781,r=.707106781,i=0):(i=Math.sqrt(F),n=k/i,r=K/i),this.set(n,r,i,t),this}let S=Math.sqrt((m-d)*(m-d)+(c-g)*(c-g)+(u-s)*(u-s));return Math.abs(S)<.001&&(S=1),this.x=(m-d)/S,this.y=(c-g)/S,this.z=(u-s)/S,this.w=Math.acos((a+p+x-1)/2),this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this.w=Math.min(this.w,e.w),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this.w=Math.max(this.w,e.w),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this.w=Math.max(e.w,Math.min(t.w,this.w)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this.w=Math.max(e,Math.min(t,this.w)),this}clampLength(e,t){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(e,Math.min(t,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z+this.w*e.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this.w+=(e.w-this.w)*t,this}lerpVectors(e,t,n){return this.x=e.x+(t.x-e.x)*n,this.y=e.y+(t.y-e.y)*n,this.z=e.z+(t.z-e.z)*n,this.w=e.w+(t.w-e.w)*n,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z&&e.w===this.w}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this.w=e[t+3],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e[t+3]=this.w,e}fromBufferAttribute(e,t,n){return n!==void 0&&console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this.w=e.getW(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}}function Kn(e,t,n){this.width=e,this.height=t,this.scissor=new nn(0,0,e,t),this.scissorTest=!1,this.viewport=new nn(0,0,e,t),n=n||{},this.texture=new tn(void 0,n.mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.encoding),this.texture.image={},this.texture.image.width=e,this.texture.image.height=t,this.texture.generateMipmaps=n.generateMipmaps!==void 0&&n.generateMipmaps,this.texture.minFilter=n.minFilter!==void 0?n.minFilter:se,this.depthBuffer=n.depthBuffer===void 0||n.depthBuffer,this.stencilBuffer=n.stencilBuffer!==void 0&&n.stencilBuffer,this.depthTexture=n.depthTexture!==void 0?n.depthTexture:null}function pc(e,t,n){Kn.call(this,e,t,n),this.samples=4}Kn.prototype=Object.assign(Object.create(Sr.prototype),{constructor:Kn,isWebGLRenderTarget:!0,setSize:function(e,t){this.width===e&&this.height===t||(this.width=e,this.height=t,this.texture.image.width=e,this.texture.image.height=t,this.dispose()),this.viewport.set(0,0,e,t),this.scissor.set(0,0,e,t)},clone:function(){return new this.constructor().copy(this)},copy:function(e){return this.width=e.width,this.height=e.height,this.viewport.copy(e.viewport),this.texture=e.texture.clone(),this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,this.depthTexture=e.depthTexture,this},dispose:function(){this.dispatchEvent({type:"dispose"})}}),pc.prototype=Object.assign(Object.create(Kn.prototype),{constructor:pc,isWebGLMultisampleRenderTarget:!0,copy:function(e){return Kn.prototype.copy.call(this,e),this.samples=e.samples,this}});class Nn{constructor(e=0,t=0,n=0,r=1){Object.defineProperty(this,"isQuaternion",{value:!0}),this._x=e,this._y=t,this._z=n,this._w=r}static slerp(e,t,n,r){return n.copy(e).slerp(t,r)}static slerpFlat(e,t,n,r,i,o,a){let s=n[r+0],c=n[r+1],u=n[r+2],p=n[r+3];const d=i[o+0],g=i[o+1],m=i[o+2],x=i[o+3];if(p!==x||s!==d||c!==g||u!==m){let S=1-a;const b=s*d+c*g+u*m+p*x,R=b>=0?1:-1,F=1-b*b;if(F>Number.EPSILON){const k=Math.sqrt(F),K=Math.atan2(k,b*R);S=Math.sin(S*K)/k,a=Math.sin(a*K)/k}const ee=a*R;if(s=s*S+d*ee,c=c*S+g*ee,u=u*S+m*ee,p=p*S+x*ee,S===1-a){const k=1/Math.sqrt(s*s+c*c+u*u+p*p);s*=k,c*=k,u*=k,p*=k}}e[t]=s,e[t+1]=c,e[t+2]=u,e[t+3]=p}static multiplyQuaternionsFlat(e,t,n,r,i,o){const a=n[r],s=n[r+1],c=n[r+2],u=n[r+3],p=i[o],d=i[o+1],g=i[o+2],m=i[o+3];return e[t]=a*m+u*p+s*g-c*d,e[t+1]=s*m+u*d+c*p-a*g,e[t+2]=c*m+u*g+a*d-s*p,e[t+3]=u*m-a*p-s*d-c*g,e}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get w(){return this._w}set w(e){this._w=e,this._onChangeCallback()}set(e,t,n,r){return this._x=e,this._y=t,this._z=n,this._w=r,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(e){return this._x=e.x,this._y=e.y,this._z=e.z,this._w=e.w,this._onChangeCallback(),this}setFromEuler(e,t){if(!e||!e.isEuler)throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");const n=e._x,r=e._y,i=e._z,o=e._order,a=Math.cos,s=Math.sin,c=a(n/2),u=a(r/2),p=a(i/2),d=s(n/2),g=s(r/2),m=s(i/2);switch(o){case"XYZ":this._x=d*u*p+c*g*m,this._y=c*g*p-d*u*m,this._z=c*u*m+d*g*p,this._w=c*u*p-d*g*m;break;case"YXZ":this._x=d*u*p+c*g*m,this._y=c*g*p-d*u*m,this._z=c*u*m-d*g*p,this._w=c*u*p+d*g*m;break;case"ZXY":this._x=d*u*p-c*g*m,this._y=c*g*p+d*u*m,this._z=c*u*m+d*g*p,this._w=c*u*p-d*g*m;break;case"ZYX":this._x=d*u*p-c*g*m,this._y=c*g*p+d*u*m,this._z=c*u*m-d*g*p,this._w=c*u*p+d*g*m;break;case"YZX":this._x=d*u*p+c*g*m,this._y=c*g*p+d*u*m,this._z=c*u*m-d*g*p,this._w=c*u*p-d*g*m;break;case"XZY":this._x=d*u*p-c*g*m,this._y=c*g*p-d*u*m,this._z=c*u*m+d*g*p,this._w=c*u*p+d*g*m;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+o)}return t!==!1&&this._onChangeCallback(),this}setFromAxisAngle(e,t){const n=t/2,r=Math.sin(n);return this._x=e.x*r,this._y=e.y*r,this._z=e.z*r,this._w=Math.cos(n),this._onChangeCallback(),this}setFromRotationMatrix(e){const t=e.elements,n=t[0],r=t[4],i=t[8],o=t[1],a=t[5],s=t[9],c=t[2],u=t[6],p=t[10],d=n+a+p;if(d>0){const g=.5/Math.sqrt(d+1);this._w=.25/g,this._x=(u-s)*g,this._y=(i-c)*g,this._z=(o-r)*g}else if(n>a&&n>p){const g=2*Math.sqrt(1+n-a-p);this._w=(u-s)/g,this._x=.25*g,this._y=(r+o)/g,this._z=(i+c)/g}else if(a>p){const g=2*Math.sqrt(1+a-n-p);this._w=(i-c)/g,this._x=(r+o)/g,this._y=.25*g,this._z=(s+u)/g}else{const g=2*Math.sqrt(1+p-n-a);this._w=(o-r)/g,this._x=(i+c)/g,this._y=(s+u)/g,this._z=.25*g}return this._onChangeCallback(),this}setFromUnitVectors(e,t){let n=e.dot(t)+1;return n<1e-6?(n=0,Math.abs(e.x)>Math.abs(e.z)?(this._x=-e.y,this._y=e.x,this._z=0,this._w=n):(this._x=0,this._y=-e.z,this._z=e.y,this._w=n)):(this._x=e.y*t.z-e.z*t.y,this._y=e.z*t.x-e.x*t.z,this._z=e.x*t.y-e.y*t.x,this._w=n),this.normalize()}angleTo(e){return 2*Math.acos(Math.abs(Ft.clamp(this.dot(e),-1,1)))}rotateTowards(e,t){const n=this.angleTo(e);if(n===0)return this;const r=Math.min(1,t/n);return this.slerp(e,r),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(e){return this._x*e._x+this._y*e._y+this._z*e._z+this._w*e._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let e=this.length();return e===0?(this._x=0,this._y=0,this._z=0,this._w=1):(e=1/e,this._x=this._x*e,this._y=this._y*e,this._z=this._z*e,this._w=this._w*e),this._onChangeCallback(),this}multiply(e,t){return t!==void 0?(console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),this.multiplyQuaternions(e,t)):this.multiplyQuaternions(this,e)}premultiply(e){return this.multiplyQuaternions(e,this)}multiplyQuaternions(e,t){const n=e._x,r=e._y,i=e._z,o=e._w,a=t._x,s=t._y,c=t._z,u=t._w;return this._x=n*u+o*a+r*c-i*s,this._y=r*u+o*s+i*a-n*c,this._z=i*u+o*c+n*s-r*a,this._w=o*u-n*a-r*s-i*c,this._onChangeCallback(),this}slerp(e,t){if(t===0)return this;if(t===1)return this.copy(e);const n=this._x,r=this._y,i=this._z,o=this._w;let a=o*e._w+n*e._x+r*e._y+i*e._z;if(a<0?(this._w=-e._w,this._x=-e._x,this._y=-e._y,this._z=-e._z,a=-a):this.copy(e),a>=1)return this._w=o,this._x=n,this._y=r,this._z=i,this;const s=1-a*a;if(s<=Number.EPSILON){const g=1-t;return this._w=g*o+t*this._w,this._x=g*n+t*this._x,this._y=g*r+t*this._y,this._z=g*i+t*this._z,this.normalize(),this._onChangeCallback(),this}const c=Math.sqrt(s),u=Math.atan2(c,a),p=Math.sin((1-t)*u)/c,d=Math.sin(t*u)/c;return this._w=o*p+this._w*d,this._x=n*p+this._x*d,this._y=r*p+this._y*d,this._z=i*p+this._z*d,this._onChangeCallback(),this}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._w===this._w}fromArray(e,t=0){return this._x=e[t],this._y=e[t+1],this._z=e[t+2],this._w=e[t+3],this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._w,e}fromBufferAttribute(e,t){return this._x=e.getX(t),this._y=e.getY(t),this._z=e.getZ(t),this._w=e.getW(t),this}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}}class z{constructor(e=0,t=0,n=0){Object.defineProperty(this,"isVector3",{value:!0}),this.x=e,this.y=t,this.z=n}set(e,t,n){return n===void 0&&(n=this.z),this.x=e,this.y=t,this.z=n,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this}add(e,t){return t!==void 0?(console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this.z+=e.z,this)}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this}sub(e,t){return t!==void 0?(console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this.z-=e.z,this)}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this}multiply(e,t){return t!==void 0?(console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(e,t)):(this.x*=e.x,this.y*=e.y,this.z*=e.z,this)}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this}multiplyVectors(e,t){return this.x=e.x*t.x,this.y=e.y*t.y,this.z=e.z*t.z,this}applyEuler(e){return e&&e.isEuler||console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),this.applyQuaternion(zu.setFromEuler(e))}applyAxisAngle(e,t){return this.applyQuaternion(zu.setFromAxisAngle(e,t))}applyMatrix3(e){const t=this.x,n=this.y,r=this.z,i=e.elements;return this.x=i[0]*t+i[3]*n+i[6]*r,this.y=i[1]*t+i[4]*n+i[7]*r,this.z=i[2]*t+i[5]*n+i[8]*r,this}applyNormalMatrix(e){return this.applyMatrix3(e).normalize()}applyMatrix4(e){const t=this.x,n=this.y,r=this.z,i=e.elements,o=1/(i[3]*t+i[7]*n+i[11]*r+i[15]);return this.x=(i[0]*t+i[4]*n+i[8]*r+i[12])*o,this.y=(i[1]*t+i[5]*n+i[9]*r+i[13])*o,this.z=(i[2]*t+i[6]*n+i[10]*r+i[14])*o,this}applyQuaternion(e){const t=this.x,n=this.y,r=this.z,i=e.x,o=e.y,a=e.z,s=e.w,c=s*t+o*r-a*n,u=s*n+a*t-i*r,p=s*r+i*n-o*t,d=-i*t-o*n-a*r;return this.x=c*s+d*-i+u*-a-p*-o,this.y=u*s+d*-o+p*-i-c*-a,this.z=p*s+d*-a+c*-o-u*-i,this}project(e){return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)}unproject(e){return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)}transformDirection(e){const t=this.x,n=this.y,r=this.z,i=e.elements;return this.x=i[0]*t+i[4]*n+i[8]*r,this.y=i[1]*t+i[5]*n+i[9]*r,this.z=i[2]*t+i[6]*n+i[10]*r,this.normalize()}divide(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this}divideScalar(e){return this.multiplyScalar(1/e)}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this}clampLength(e,t){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(e,Math.min(t,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this}lerpVectors(e,t,n){return this.x=e.x+(t.x-e.x)*n,this.y=e.y+(t.y-e.y)*n,this.z=e.z+(t.z-e.z)*n,this}cross(e,t){return t!==void 0?(console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(e,t)):this.crossVectors(this,e)}crossVectors(e,t){const n=e.x,r=e.y,i=e.z,o=t.x,a=t.y,s=t.z;return this.x=r*s-i*a,this.y=i*o-n*s,this.z=n*a-r*o,this}projectOnVector(e){const t=e.lengthSq();if(t===0)return this.set(0,0,0);const n=e.dot(this)/t;return this.copy(e).multiplyScalar(n)}projectOnPlane(e){return fc.copy(this).projectOnVector(e),this.sub(fc)}reflect(e){return this.sub(fc.copy(e).multiplyScalar(2*this.dot(e)))}angleTo(e){const t=Math.sqrt(this.lengthSq()*e.lengthSq());if(t===0)return Math.PI/2;const n=this.dot(e)/t;return Math.acos(Ft.clamp(n,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,n=this.y-e.y,r=this.z-e.z;return t*t+n*n+r*r}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)+Math.abs(this.z-e.z)}setFromSpherical(e){return this.setFromSphericalCoords(e.radius,e.phi,e.theta)}setFromSphericalCoords(e,t,n){const r=Math.sin(t)*e;return this.x=r*Math.sin(n),this.y=Math.cos(t)*e,this.z=r*Math.cos(n),this}setFromCylindrical(e){return this.setFromCylindricalCoords(e.radius,e.theta,e.y)}setFromCylindricalCoords(e,t,n){return this.x=e*Math.sin(t),this.y=n,this.z=e*Math.cos(t),this}setFromMatrixPosition(e){const t=e.elements;return this.x=t[12],this.y=t[13],this.z=t[14],this}setFromMatrixScale(e){const t=this.setFromMatrixColumn(e,0).length(),n=this.setFromMatrixColumn(e,1).length(),r=this.setFromMatrixColumn(e,2).length();return this.x=t,this.y=n,this.z=r,this}setFromMatrixColumn(e,t){return this.fromArray(e.elements,4*t)}setFromMatrix3Column(e,t){return this.fromArray(e.elements,3*t)}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e}fromBufferAttribute(e,t,n){return n!==void 0&&console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}}const fc=new z,zu=new Nn;class Tr{constructor(e,t){Object.defineProperty(this,"isBox3",{value:!0}),this.min=e!==void 0?e:new z(1/0,1/0,1/0),this.max=t!==void 0?t:new z(-1/0,-1/0,-1/0)}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromArray(e){let t=1/0,n=1/0,r=1/0,i=-1/0,o=-1/0,a=-1/0;for(let s=0,c=e.length;s<c;s+=3){const u=e[s],p=e[s+1],d=e[s+2];u<t&&(t=u),p<n&&(n=p),d<r&&(r=d),u>i&&(i=u),p>o&&(o=p),d>a&&(a=d)}return this.min.set(t,n,r),this.max.set(i,o,a),this}setFromBufferAttribute(e){let t=1/0,n=1/0,r=1/0,i=-1/0,o=-1/0,a=-1/0;for(let s=0,c=e.count;s<c;s++){const u=e.getX(s),p=e.getY(s),d=e.getZ(s);u<t&&(t=u),p<n&&(n=p),d<r&&(r=d),u>i&&(i=u),p>o&&(o=p),d>a&&(a=d)}return this.min.set(t,n,r),this.max.set(i,o,a),this}setFromPoints(e){this.makeEmpty();for(let t=0,n=e.length;t<n;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){const n=Oo.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(n),this.max.copy(e).add(n),this}setFromObject(e){return this.makeEmpty(),this.expandByObject(e)}clone(){return new this.constructor().copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(e){return e===void 0&&(console.warn("THREE.Box3: .getCenter() target is now required"),e=new z),this.isEmpty()?e.set(0,0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return e===void 0&&(console.warn("THREE.Box3: .getSize() target is now required"),e=new z),this.isEmpty()?e.set(0,0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}expandByObject(e){e.updateWorldMatrix(!1,!1);const t=e.geometry;t!==void 0&&(t.boundingBox===null&&t.computeBoundingBox(),gc.copy(t.boundingBox),gc.applyMatrix4(e.matrixWorld),this.union(gc));const n=e.children;for(let r=0,i=n.length;r<i;r++)this.expandByObject(n[r]);return this}containsPoint(e){return!(e.x<this.min.x||e.x>this.max.x||e.y<this.min.y||e.y>this.max.y||e.z<this.min.z||e.z>this.max.z)}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y&&this.min.z<=e.min.z&&e.max.z<=this.max.z}getParameter(e,t){return t===void 0&&(console.warn("THREE.Box3: .getParameter() target is now required"),t=new z),t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y),(e.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y||e.max.z<this.min.z||e.min.z>this.max.z)}intersectsSphere(e){return this.clampPoint(e.center,Oo),Oo.distanceToSquared(e.center)<=e.radius*e.radius}intersectsPlane(e){let t,n;return e.normal.x>0?(t=e.normal.x*this.min.x,n=e.normal.x*this.max.x):(t=e.normal.x*this.max.x,n=e.normal.x*this.min.x),e.normal.y>0?(t+=e.normal.y*this.min.y,n+=e.normal.y*this.max.y):(t+=e.normal.y*this.max.y,n+=e.normal.y*this.min.y),e.normal.z>0?(t+=e.normal.z*this.min.z,n+=e.normal.z*this.max.z):(t+=e.normal.z*this.max.z,n+=e.normal.z*this.min.z),t<=-e.constant&&n>=-e.constant}intersectsTriangle(e){if(this.isEmpty())return!1;this.getCenter(Do),Ba.subVectors(this.max,Do),qi.subVectors(e.a,Do),Yi.subVectors(e.b,Do),Zi.subVectors(e.c,Do),Jr.subVectors(Yi,qi),Kr.subVectors(Zi,Yi),_i.subVectors(qi,Zi);let t=[0,-Jr.z,Jr.y,0,-Kr.z,Kr.y,0,-_i.z,_i.y,Jr.z,0,-Jr.x,Kr.z,0,-Kr.x,_i.z,0,-_i.x,-Jr.y,Jr.x,0,-Kr.y,Kr.x,0,-_i.y,_i.x,0];return!!mc(t,qi,Yi,Zi,Ba)&&(t=[1,0,0,0,1,0,0,0,1],!!mc(t,qi,Yi,Zi,Ba)&&(Fa.crossVectors(Jr,Kr),t=[Fa.x,Fa.y,Fa.z],mc(t,qi,Yi,Zi,Ba)))}clampPoint(e,t){return t===void 0&&(console.warn("THREE.Box3: .clampPoint() target is now required"),t=new z),t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return Oo.copy(e).clamp(this.min,this.max).sub(e).length()}getBoundingSphere(e){return e===void 0&&console.error("THREE.Box3: .getBoundingSphere() target is now required"),this.getCenter(e.center),e.radius=.5*this.getSize(Oo).length(),e}intersect(e){return this.min.max(e.min),this.max.min(e.max),this.isEmpty()&&this.makeEmpty(),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}applyMatrix4(e){return this.isEmpty()||(Br[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(e),Br[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(e),Br[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(e),Br[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(e),Br[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(e),Br[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(e),Br[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(e),Br[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(e),this.setFromPoints(Br)),this}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}function mc(e,t,n,r,i){for(let o=0,a=e.length-3;o<=a;o+=3){Mi.fromArray(e,o);const s=i.x*Math.abs(Mi.x)+i.y*Math.abs(Mi.y)+i.z*Math.abs(Mi.z),c=t.dot(Mi),u=n.dot(Mi),p=r.dot(Mi);if(Math.max(-Math.max(c,u,p),Math.min(c,u,p))>s)return!1}return!0}const Br=[new z,new z,new z,new z,new z,new z,new z,new z],Oo=new z,gc=new Tr,qi=new z,Yi=new z,Zi=new z,Jr=new z,Kr=new z,_i=new z,Do=new z,Ba=new z,Fa=new z,Mi=new z,Rp=new Tr;class Fr{constructor(e,t){this.center=e!==void 0?e:new z,this.radius=t!==void 0?t:-1}set(e,t){return this.center.copy(e),this.radius=t,this}setFromPoints(e,t){const n=this.center;t!==void 0?n.copy(t):Rp.setFromPoints(e).getCenter(n);let r=0;for(let i=0,o=e.length;i<o;i++)r=Math.max(r,n.distanceToSquared(e[i]));return this.radius=Math.sqrt(r),this}clone(){return new this.constructor().copy(this)}copy(e){return this.center.copy(e.center),this.radius=e.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(e){return e.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(e){return e.distanceTo(this.center)-this.radius}intersectsSphere(e){const t=this.radius+e.radius;return e.center.distanceToSquared(this.center)<=t*t}intersectsBox(e){return e.intersectsSphere(this)}intersectsPlane(e){return Math.abs(e.distanceToPoint(this.center))<=this.radius}clampPoint(e,t){const n=this.center.distanceToSquared(e);return t===void 0&&(console.warn("THREE.Sphere: .clampPoint() target is now required"),t=new z),t.copy(e),n>this.radius*this.radius&&(t.sub(this.center).normalize(),t.multiplyScalar(this.radius).add(this.center)),t}getBoundingBox(e){return e===void 0&&(console.warn("THREE.Sphere: .getBoundingBox() target is now required"),e=new Tr),this.isEmpty()?(e.makeEmpty(),e):(e.set(this.center,this.center),e.expandByScalar(this.radius),e)}applyMatrix4(e){return this.center.applyMatrix4(e),this.radius=this.radius*e.getMaxScaleOnAxis(),this}translate(e){return this.center.add(e),this}equals(e){return e.center.equals(this.center)&&e.radius===this.radius}}const Ur=new z,vc=new z,Ua=new z,Qr=new z,yc=new z,za=new z,xc=new z;class Ji{constructor(e,t){this.origin=e!==void 0?e:new z,this.direction=t!==void 0?t:new z(0,0,-1)}set(e,t){return this.origin.copy(e),this.direction.copy(t),this}clone(){return new this.constructor().copy(this)}copy(e){return this.origin.copy(e.origin),this.direction.copy(e.direction),this}at(e,t){return t===void 0&&(console.warn("THREE.Ray: .at() target is now required"),t=new z),t.copy(this.direction).multiplyScalar(e).add(this.origin)}lookAt(e){return this.direction.copy(e).sub(this.origin).normalize(),this}recast(e){return this.origin.copy(this.at(e,Ur)),this}closestPointToPoint(e,t){t===void 0&&(console.warn("THREE.Ray: .closestPointToPoint() target is now required"),t=new z),t.subVectors(e,this.origin);const n=t.dot(this.direction);return n<0?t.copy(this.origin):t.copy(this.direction).multiplyScalar(n).add(this.origin)}distanceToPoint(e){return Math.sqrt(this.distanceSqToPoint(e))}distanceSqToPoint(e){const t=Ur.subVectors(e,this.origin).dot(this.direction);return t<0?this.origin.distanceToSquared(e):(Ur.copy(this.direction).multiplyScalar(t).add(this.origin),Ur.distanceToSquared(e))}distanceSqToSegment(e,t,n,r){vc.copy(e).add(t).multiplyScalar(.5),Ua.copy(t).sub(e).normalize(),Qr.copy(this.origin).sub(vc);const i=.5*e.distanceTo(t),o=-this.direction.dot(Ua),a=Qr.dot(this.direction),s=-Qr.dot(Ua),c=Qr.lengthSq(),u=Math.abs(1-o*o);let p,d,g,m;if(u>0)if(p=o*s-a,d=o*a-s,m=i*u,p>=0)if(d>=-m)if(d<=m){const x=1/u;p*=x,d*=x,g=p*(p+o*d+2*a)+d*(o*p+d+2*s)+c}else d=i,p=Math.max(0,-(o*d+a)),g=-p*p+d*(d+2*s)+c;else d=-i,p=Math.max(0,-(o*d+a)),g=-p*p+d*(d+2*s)+c;else d<=-m?(p=Math.max(0,-(-o*i+a)),d=p>0?-i:Math.min(Math.max(-i,-s),i),g=-p*p+d*(d+2*s)+c):d<=m?(p=0,d=Math.min(Math.max(-i,-s),i),g=d*(d+2*s)+c):(p=Math.max(0,-(o*i+a)),d=p>0?i:Math.min(Math.max(-i,-s),i),g=-p*p+d*(d+2*s)+c);else d=o>0?-i:i,p=Math.max(0,-(o*d+a)),g=-p*p+d*(d+2*s)+c;return n&&n.copy(this.direction).multiplyScalar(p).add(this.origin),r&&r.copy(Ua).multiplyScalar(d).add(vc),g}intersectSphere(e,t){Ur.subVectors(e.center,this.origin);const n=Ur.dot(this.direction),r=Ur.dot(Ur)-n*n,i=e.radius*e.radius;if(r>i)return null;const o=Math.sqrt(i-r),a=n-o,s=n+o;return a<0&&s<0?null:a<0?this.at(s,t):this.at(a,t)}intersectsSphere(e){return this.distanceSqToPoint(e.center)<=e.radius*e.radius}distanceToPlane(e){const t=e.normal.dot(this.direction);if(t===0)return e.distanceToPoint(this.origin)===0?0:null;const n=-(this.origin.dot(e.normal)+e.constant)/t;return n>=0?n:null}intersectPlane(e,t){const n=this.distanceToPlane(e);return n===null?null:this.at(n,t)}intersectsPlane(e){const t=e.distanceToPoint(this.origin);return t===0?!0:e.normal.dot(this.direction)*t<0}intersectBox(e,t){let n,r,i,o,a,s;const c=1/this.direction.x,u=1/this.direction.y,p=1/this.direction.z,d=this.origin;return c>=0?(n=(e.min.x-d.x)*c,r=(e.max.x-d.x)*c):(n=(e.max.x-d.x)*c,r=(e.min.x-d.x)*c),u>=0?(i=(e.min.y-d.y)*u,o=(e.max.y-d.y)*u):(i=(e.max.y-d.y)*u,o=(e.min.y-d.y)*u),n>o||i>r?null:((i>n||n!=n)&&(n=i),(o<r||r!=r)&&(r=o),p>=0?(a=(e.min.z-d.z)*p,s=(e.max.z-d.z)*p):(a=(e.max.z-d.z)*p,s=(e.min.z-d.z)*p),n>s||a>r?null:((a>n||n!=n)&&(n=a),(s<r||r!=r)&&(r=s),r<0?null:this.at(n>=0?n:r,t)))}intersectsBox(e){return this.intersectBox(e,Ur)!==null}intersectTriangle(e,t,n,r,i){yc.subVectors(t,e),za.subVectors(n,e),xc.crossVectors(yc,za);let o,a=this.direction.dot(xc);if(a>0){if(r)return null;o=1}else{if(!(a<0))return null;o=-1,a=-a}Qr.subVectors(this.origin,e);const s=o*this.direction.dot(za.crossVectors(Qr,za));if(s<0)return null;const c=o*this.direction.dot(yc.cross(Qr));if(c<0)return null;if(s+c>a)return null;const u=-o*Qr.dot(xc);return u<0?null:this.at(u/a,i)}applyMatrix4(e){return this.origin.applyMatrix4(e),this.direction.transformDirection(e),this}equals(e){return e.origin.equals(this.origin)&&e.direction.equals(this.direction)}}class Ht{constructor(){Object.defineProperty(this,"isMatrix4",{value:!0}),this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")}set(e,t,n,r,i,o,a,s,c,u,p,d,g,m,x,S){const b=this.elements;return b[0]=e,b[4]=t,b[8]=n,b[12]=r,b[1]=i,b[5]=o,b[9]=a,b[13]=s,b[2]=c,b[6]=u,b[10]=p,b[14]=d,b[3]=g,b[7]=m,b[11]=x,b[15]=S,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new Ht().fromArray(this.elements)}copy(e){const t=this.elements,n=e.elements;return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],t[9]=n[9],t[10]=n[10],t[11]=n[11],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15],this}copyPosition(e){const t=this.elements,n=e.elements;return t[12]=n[12],t[13]=n[13],t[14]=n[14],this}extractBasis(e,t,n){return e.setFromMatrixColumn(this,0),t.setFromMatrixColumn(this,1),n.setFromMatrixColumn(this,2),this}makeBasis(e,t,n){return this.set(e.x,t.x,n.x,0,e.y,t.y,n.y,0,e.z,t.z,n.z,0,0,0,0,1),this}extractRotation(e){const t=this.elements,n=e.elements,r=1/Ki.setFromMatrixColumn(e,0).length(),i=1/Ki.setFromMatrixColumn(e,1).length(),o=1/Ki.setFromMatrixColumn(e,2).length();return t[0]=n[0]*r,t[1]=n[1]*r,t[2]=n[2]*r,t[3]=0,t[4]=n[4]*i,t[5]=n[5]*i,t[6]=n[6]*i,t[7]=0,t[8]=n[8]*o,t[9]=n[9]*o,t[10]=n[10]*o,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromEuler(e){e&&e.isEuler||console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");const t=this.elements,n=e.x,r=e.y,i=e.z,o=Math.cos(n),a=Math.sin(n),s=Math.cos(r),c=Math.sin(r),u=Math.cos(i),p=Math.sin(i);if(e.order==="XYZ"){const d=o*u,g=o*p,m=a*u,x=a*p;t[0]=s*u,t[4]=-s*p,t[8]=c,t[1]=g+m*c,t[5]=d-x*c,t[9]=-a*s,t[2]=x-d*c,t[6]=m+g*c,t[10]=o*s}else if(e.order==="YXZ"){const d=s*u,g=s*p,m=c*u,x=c*p;t[0]=d+x*a,t[4]=m*a-g,t[8]=o*c,t[1]=o*p,t[5]=o*u,t[9]=-a,t[2]=g*a-m,t[6]=x+d*a,t[10]=o*s}else if(e.order==="ZXY"){const d=s*u,g=s*p,m=c*u,x=c*p;t[0]=d-x*a,t[4]=-o*p,t[8]=m+g*a,t[1]=g+m*a,t[5]=o*u,t[9]=x-d*a,t[2]=-o*c,t[6]=a,t[10]=o*s}else if(e.order==="ZYX"){const d=o*u,g=o*p,m=a*u,x=a*p;t[0]=s*u,t[4]=m*c-g,t[8]=d*c+x,t[1]=s*p,t[5]=x*c+d,t[9]=g*c-m,t[2]=-c,t[6]=a*s,t[10]=o*s}else if(e.order==="YZX"){const d=o*s,g=o*c,m=a*s,x=a*c;t[0]=s*u,t[4]=x-d*p,t[8]=m*p+g,t[1]=p,t[5]=o*u,t[9]=-a*u,t[2]=-c*u,t[6]=g*p+m,t[10]=d-x*p}else if(e.order==="XZY"){const d=o*s,g=o*c,m=a*s,x=a*c;t[0]=s*u,t[4]=-p,t[8]=c*u,t[1]=d*p+x,t[5]=o*u,t[9]=g*p-m,t[2]=m*p-g,t[6]=a*u,t[10]=x*p+d}return t[3]=0,t[7]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromQuaternion(e){return this.compose(Op,e,Dp)}lookAt(e,t,n){const r=this.elements;return Qn.subVectors(e,t),Qn.lengthSq()===0&&(Qn.z=1),Qn.normalize(),$r.crossVectors(n,Qn),$r.lengthSq()===0&&(Math.abs(n.z)===1?Qn.x+=1e-4:Qn.z+=1e-4,Qn.normalize(),$r.crossVectors(n,Qn)),$r.normalize(),ka.crossVectors(Qn,$r),r[0]=$r.x,r[4]=ka.x,r[8]=Qn.x,r[1]=$r.y,r[5]=ka.y,r[9]=Qn.y,r[2]=$r.z,r[6]=ka.z,r[10]=Qn.z,this}multiply(e,t){return t!==void 0?(console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),this.multiplyMatrices(e,t)):this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const n=e.elements,r=t.elements,i=this.elements,o=n[0],a=n[4],s=n[8],c=n[12],u=n[1],p=n[5],d=n[9],g=n[13],m=n[2],x=n[6],S=n[10],b=n[14],R=n[3],F=n[7],ee=n[11],k=n[15],K=r[0],le=r[4],ge=r[8],Le=r[12],Ae=r[1],xe=r[5],Xe=r[9],He=r[13],tt=r[2],ft=r[6],ke=r[10],dt=r[14],et=r[3],st=r[7],Mt=r[11],Dt=r[15];return i[0]=o*K+a*Ae+s*tt+c*et,i[4]=o*le+a*xe+s*ft+c*st,i[8]=o*ge+a*Xe+s*ke+c*Mt,i[12]=o*Le+a*He+s*dt+c*Dt,i[1]=u*K+p*Ae+d*tt+g*et,i[5]=u*le+p*xe+d*ft+g*st,i[9]=u*ge+p*Xe+d*ke+g*Mt,i[13]=u*Le+p*He+d*dt+g*Dt,i[2]=m*K+x*Ae+S*tt+b*et,i[6]=m*le+x*xe+S*ft+b*st,i[10]=m*ge+x*Xe+S*ke+b*Mt,i[14]=m*Le+x*He+S*dt+b*Dt,i[3]=R*K+F*Ae+ee*tt+k*et,i[7]=R*le+F*xe+ee*ft+k*st,i[11]=R*ge+F*Xe+ee*ke+k*Mt,i[15]=R*Le+F*He+ee*dt+k*Dt,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[4]*=e,t[8]*=e,t[12]*=e,t[1]*=e,t[5]*=e,t[9]*=e,t[13]*=e,t[2]*=e,t[6]*=e,t[10]*=e,t[14]*=e,t[3]*=e,t[7]*=e,t[11]*=e,t[15]*=e,this}determinant(){const e=this.elements,t=e[0],n=e[4],r=e[8],i=e[12],o=e[1],a=e[5],s=e[9],c=e[13],u=e[2],p=e[6],d=e[10],g=e[14];return e[3]*(+i*s*p-r*c*p-i*a*d+n*c*d+r*a*g-n*s*g)+e[7]*(+t*s*g-t*c*d+i*o*d-r*o*g+r*c*u-i*s*u)+e[11]*(+t*c*p-t*a*g-i*o*p+n*o*g+i*a*u-n*c*u)+e[15]*(-r*a*u-t*s*p+t*a*d+r*o*p-n*o*d+n*s*u)}transpose(){const e=this.elements;let t;return t=e[1],e[1]=e[4],e[4]=t,t=e[2],e[2]=e[8],e[8]=t,t=e[6],e[6]=e[9],e[9]=t,t=e[3],e[3]=e[12],e[12]=t,t=e[7],e[7]=e[13],e[13]=t,t=e[11],e[11]=e[14],e[14]=t,this}setPosition(e,t,n){const r=this.elements;return e.isVector3?(r[12]=e.x,r[13]=e.y,r[14]=e.z):(r[12]=e,r[13]=t,r[14]=n),this}invert(){const e=this.elements,t=e[0],n=e[1],r=e[2],i=e[3],o=e[4],a=e[5],s=e[6],c=e[7],u=e[8],p=e[9],d=e[10],g=e[11],m=e[12],x=e[13],S=e[14],b=e[15],R=p*S*c-x*d*c+x*s*g-a*S*g-p*s*b+a*d*b,F=m*d*c-u*S*c-m*s*g+o*S*g+u*s*b-o*d*b,ee=u*x*c-m*p*c+m*a*g-o*x*g-u*a*b+o*p*b,k=m*p*s-u*x*s-m*a*d+o*x*d+u*a*S-o*p*S,K=t*R+n*F+r*ee+i*k;if(K===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const le=1/K;return e[0]=R*le,e[1]=(x*d*i-p*S*i-x*r*g+n*S*g+p*r*b-n*d*b)*le,e[2]=(a*S*i-x*s*i+x*r*c-n*S*c-a*r*b+n*s*b)*le,e[3]=(p*s*i-a*d*i-p*r*c+n*d*c+a*r*g-n*s*g)*le,e[4]=F*le,e[5]=(u*S*i-m*d*i+m*r*g-t*S*g-u*r*b+t*d*b)*le,e[6]=(m*s*i-o*S*i-m*r*c+t*S*c+o*r*b-t*s*b)*le,e[7]=(o*d*i-u*s*i+u*r*c-t*d*c-o*r*g+t*s*g)*le,e[8]=ee*le,e[9]=(m*p*i-u*x*i-m*n*g+t*x*g+u*n*b-t*p*b)*le,e[10]=(o*x*i-m*a*i+m*n*c-t*x*c-o*n*b+t*a*b)*le,e[11]=(u*a*i-o*p*i-u*n*c+t*p*c+o*n*g-t*a*g)*le,e[12]=k*le,e[13]=(u*x*r-m*p*r+m*n*d-t*x*d-u*n*S+t*p*S)*le,e[14]=(m*a*r-o*x*r-m*n*s+t*x*s+o*n*S-t*a*S)*le,e[15]=(o*p*r-u*a*r+u*n*s-t*p*s-o*n*d+t*a*d)*le,this}scale(e){const t=this.elements,n=e.x,r=e.y,i=e.z;return t[0]*=n,t[4]*=r,t[8]*=i,t[1]*=n,t[5]*=r,t[9]*=i,t[2]*=n,t[6]*=r,t[10]*=i,t[3]*=n,t[7]*=r,t[11]*=i,this}getMaxScaleOnAxis(){const e=this.elements,t=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],n=e[4]*e[4]+e[5]*e[5]+e[6]*e[6],r=e[8]*e[8]+e[9]*e[9]+e[10]*e[10];return Math.sqrt(Math.max(t,n,r))}makeTranslation(e,t,n){return this.set(1,0,0,e,0,1,0,t,0,0,1,n,0,0,0,1),this}makeRotationX(e){const t=Math.cos(e),n=Math.sin(e);return this.set(1,0,0,0,0,t,-n,0,0,n,t,0,0,0,0,1),this}makeRotationY(e){const t=Math.cos(e),n=Math.sin(e);return this.set(t,0,n,0,0,1,0,0,-n,0,t,0,0,0,0,1),this}makeRotationZ(e){const t=Math.cos(e),n=Math.sin(e);return this.set(t,-n,0,0,n,t,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(e,t){const n=Math.cos(t),r=Math.sin(t),i=1-n,o=e.x,a=e.y,s=e.z,c=i*o,u=i*a;return this.set(c*o+n,c*a-r*s,c*s+r*a,0,c*a+r*s,u*a+n,u*s-r*o,0,c*s-r*a,u*s+r*o,i*s*s+n,0,0,0,0,1),this}makeScale(e,t,n){return this.set(e,0,0,0,0,t,0,0,0,0,n,0,0,0,0,1),this}makeShear(e,t,n){return this.set(1,t,n,0,e,1,n,0,e,t,1,0,0,0,0,1),this}compose(e,t,n){const r=this.elements,i=t._x,o=t._y,a=t._z,s=t._w,c=i+i,u=o+o,p=a+a,d=i*c,g=i*u,m=i*p,x=o*u,S=o*p,b=a*p,R=s*c,F=s*u,ee=s*p,k=n.x,K=n.y,le=n.z;return r[0]=(1-(x+b))*k,r[1]=(g+ee)*k,r[2]=(m-F)*k,r[3]=0,r[4]=(g-ee)*K,r[5]=(1-(d+b))*K,r[6]=(S+R)*K,r[7]=0,r[8]=(m+F)*le,r[9]=(S-R)*le,r[10]=(1-(d+x))*le,r[11]=0,r[12]=e.x,r[13]=e.y,r[14]=e.z,r[15]=1,this}decompose(e,t,n){const r=this.elements;let i=Ki.set(r[0],r[1],r[2]).length();const o=Ki.set(r[4],r[5],r[6]).length(),a=Ki.set(r[8],r[9],r[10]).length();this.determinant()<0&&(i=-i),e.x=r[12],e.y=r[13],e.z=r[14],pr.copy(this);const s=1/i,c=1/o,u=1/a;return pr.elements[0]*=s,pr.elements[1]*=s,pr.elements[2]*=s,pr.elements[4]*=c,pr.elements[5]*=c,pr.elements[6]*=c,pr.elements[8]*=u,pr.elements[9]*=u,pr.elements[10]*=u,t.setFromRotationMatrix(pr),n.x=i,n.y=o,n.z=a,this}makePerspective(e,t,n,r,i,o){o===void 0&&console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");const a=this.elements,s=2*i/(t-e),c=2*i/(n-r),u=(t+e)/(t-e),p=(n+r)/(n-r),d=-(o+i)/(o-i),g=-2*o*i/(o-i);return a[0]=s,a[4]=0,a[8]=u,a[12]=0,a[1]=0,a[5]=c,a[9]=p,a[13]=0,a[2]=0,a[6]=0,a[10]=d,a[14]=g,a[3]=0,a[7]=0,a[11]=-1,a[15]=0,this}makeOrthographic(e,t,n,r,i,o){const a=this.elements,s=1/(t-e),c=1/(n-r),u=1/(o-i),p=(t+e)*s,d=(n+r)*c,g=(o+i)*u;return a[0]=2*s,a[4]=0,a[8]=0,a[12]=-p,a[1]=0,a[5]=2*c,a[9]=0,a[13]=-d,a[2]=0,a[6]=0,a[10]=-2*u,a[14]=-g,a[3]=0,a[7]=0,a[11]=0,a[15]=1,this}equals(e){const t=this.elements,n=e.elements;for(let r=0;r<16;r++)if(t[r]!==n[r])return!1;return!0}fromArray(e,t=0){for(let n=0;n<16;n++)this.elements[n]=e[n+t];return this}toArray(e=[],t=0){const n=this.elements;return e[t]=n[0],e[t+1]=n[1],e[t+2]=n[2],e[t+3]=n[3],e[t+4]=n[4],e[t+5]=n[5],e[t+6]=n[6],e[t+7]=n[7],e[t+8]=n[8],e[t+9]=n[9],e[t+10]=n[10],e[t+11]=n[11],e[t+12]=n[12],e[t+13]=n[13],e[t+14]=n[14],e[t+15]=n[15],e}}const Ki=new z,pr=new Ht,Op=new z(0,0,0),Dp=new z(1,1,1),$r=new z,ka=new z,Qn=new z;class Io{constructor(e=0,t=0,n=0,r=Io.DefaultOrder){Object.defineProperty(this,"isEuler",{value:!0}),this._x=e,this._y=t,this._z=n,this._order=r}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get order(){return this._order}set order(e){this._order=e,this._onChangeCallback()}set(e,t,n,r){return this._x=e,this._y=t,this._z=n,this._order=r||this._order,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(e){return this._x=e._x,this._y=e._y,this._z=e._z,this._order=e._order,this._onChangeCallback(),this}setFromRotationMatrix(e,t,n){const r=Ft.clamp,i=e.elements,o=i[0],a=i[4],s=i[8],c=i[1],u=i[5],p=i[9],d=i[2],g=i[6],m=i[10];switch(t=t||this._order){case"XYZ":this._y=Math.asin(r(s,-1,1)),Math.abs(s)<.9999999?(this._x=Math.atan2(-p,m),this._z=Math.atan2(-a,o)):(this._x=Math.atan2(g,u),this._z=0);break;case"YXZ":this._x=Math.asin(-r(p,-1,1)),Math.abs(p)<.9999999?(this._y=Math.atan2(s,m),this._z=Math.atan2(c,u)):(this._y=Math.atan2(-d,o),this._z=0);break;case"ZXY":this._x=Math.asin(r(g,-1,1)),Math.abs(g)<.9999999?(this._y=Math.atan2(-d,m),this._z=Math.atan2(-a,u)):(this._y=0,this._z=Math.atan2(c,o));break;case"ZYX":this._y=Math.asin(-r(d,-1,1)),Math.abs(d)<.9999999?(this._x=Math.atan2(g,m),this._z=Math.atan2(c,o)):(this._x=0,this._z=Math.atan2(-a,u));break;case"YZX":this._z=Math.asin(r(c,-1,1)),Math.abs(c)<.9999999?(this._x=Math.atan2(-p,u),this._y=Math.atan2(-d,o)):(this._x=0,this._y=Math.atan2(s,m));break;case"XZY":this._z=Math.asin(-r(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(g,u),this._y=Math.atan2(s,o)):(this._x=Math.atan2(-p,m),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+t)}return this._order=t,n!==!1&&this._onChangeCallback(),this}setFromQuaternion(e,t,n){return ku.makeRotationFromQuaternion(e),this.setFromRotationMatrix(ku,t,n)}setFromVector3(e,t){return this.set(e.x,e.y,e.z,t||this._order)}reorder(e){return Hu.setFromEuler(this),this.setFromQuaternion(Hu,e)}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._order===this._order}fromArray(e){return this._x=e[0],this._y=e[1],this._z=e[2],e[3]!==void 0&&(this._order=e[3]),this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._order,e}toVector3(e){return e?e.set(this._x,this._y,this._z):new z(this._x,this._y,this._z)}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}}Io.DefaultOrder="XYZ",Io.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"];const ku=new Ht,Hu=new Nn;class bc{constructor(){this.mask=1}set(e){this.mask=1<<e|0}enable(e){this.mask|=1<<e|0}enableAll(){this.mask=-1}toggle(e){this.mask^=1<<e|0}disable(e){this.mask&=~(1<<e|0)}disableAll(){this.mask=0}test(e){return(this.mask&e.mask)!=0}}let Ip=0;const Gu=new z,Qi=new Nn,zr=new Ht,Ha=new z,No=new z,Np=new z,Bp=new Nn,Vu=new z(1,0,0),ju=new z(0,1,0),Wu=new z(0,0,1),Fp={type:"added"},Xu={type:"removed"};function At(){Object.defineProperty(this,"id",{value:Ip++}),this.uuid=Ft.generateUUID(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=At.DefaultUp.clone();const e=new z,t=new Io,n=new Nn,r=new z(1,1,1);t._onChange(function(){n.setFromEuler(t,!1)}),n._onChange(function(){t.setFromQuaternion(n,void 0,!1)}),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:e},rotation:{configurable:!0,enumerable:!0,value:t},quaternion:{configurable:!0,enumerable:!0,value:n},scale:{configurable:!0,enumerable:!0,value:r},modelViewMatrix:{value:new Ht},normalMatrix:{value:new Vn}}),this.matrix=new Ht,this.matrixWorld=new Ht,this.matrixAutoUpdate=At.DefaultMatrixAutoUpdate,this.matrixWorldNeedsUpdate=!1,this.layers=new bc,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}At.DefaultUp=new z(0,1,0),At.DefaultMatrixAutoUpdate=!0,At.prototype=Object.assign(Object.create(Sr.prototype),{constructor:At,isObject3D:!0,onBeforeRender:function(){},onAfterRender:function(){},applyMatrix4:function(e){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(e),this.matrix.decompose(this.position,this.quaternion,this.scale)},applyQuaternion:function(e){return this.quaternion.premultiply(e),this},setRotationFromAxisAngle:function(e,t){this.quaternion.setFromAxisAngle(e,t)},setRotationFromEuler:function(e){this.quaternion.setFromEuler(e,!0)},setRotationFromMatrix:function(e){this.quaternion.setFromRotationMatrix(e)},setRotationFromQuaternion:function(e){this.quaternion.copy(e)},rotateOnAxis:function(e,t){return Qi.setFromAxisAngle(e,t),this.quaternion.multiply(Qi),this},rotateOnWorldAxis:function(e,t){return Qi.setFromAxisAngle(e,t),this.quaternion.premultiply(Qi),this},rotateX:function(e){return this.rotateOnAxis(Vu,e)},rotateY:function(e){return this.rotateOnAxis(ju,e)},rotateZ:function(e){return this.rotateOnAxis(Wu,e)},translateOnAxis:function(e,t){return Gu.copy(e).applyQuaternion(this.quaternion),this.position.add(Gu.multiplyScalar(t)),this},translateX:function(e){return this.translateOnAxis(Vu,e)},translateY:function(e){return this.translateOnAxis(ju,e)},translateZ:function(e){return this.translateOnAxis(Wu,e)},localToWorld:function(e){return e.applyMatrix4(this.matrixWorld)},worldToLocal:function(e){return e.applyMatrix4(zr.copy(this.matrixWorld).invert())},lookAt:function(e,t,n){e.isVector3?Ha.copy(e):Ha.set(e,t,n);const r=this.parent;this.updateWorldMatrix(!0,!1),No.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?zr.lookAt(No,Ha,this.up):zr.lookAt(Ha,No,this.up),this.quaternion.setFromRotationMatrix(zr),r&&(zr.extractRotation(r.matrixWorld),Qi.setFromRotationMatrix(zr),this.quaternion.premultiply(Qi.invert()))},add:function(e){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.add(arguments[t]);return this}return e===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",e),this):(e&&e.isObject3D?(e.parent!==null&&e.parent.remove(e),e.parent=this,this.children.push(e),e.dispatchEvent(Fp)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",e),this)},remove:function(e){if(arguments.length>1){for(let n=0;n<arguments.length;n++)this.remove(arguments[n]);return this}const t=this.children.indexOf(e);return t!==-1&&(e.parent=null,this.children.splice(t,1),e.dispatchEvent(Xu)),this},clear:function(){for(let e=0;e<this.children.length;e++){const t=this.children[e];t.parent=null,t.dispatchEvent(Xu)}return this.children.length=0,this},attach:function(e){return this.updateWorldMatrix(!0,!1),zr.copy(this.matrixWorld).invert(),e.parent!==null&&(e.parent.updateWorldMatrix(!0,!1),zr.multiply(e.parent.matrixWorld)),e.applyMatrix4(zr),e.updateWorldMatrix(!1,!1),this.add(e),this},getObjectById:function(e){return this.getObjectByProperty("id",e)},getObjectByName:function(e){return this.getObjectByProperty("name",e)},getObjectByProperty:function(e,t){if(this[e]===t)return this;for(let n=0,r=this.children.length;n<r;n++){const i=this.children[n].getObjectByProperty(e,t);if(i!==void 0)return i}},getWorldPosition:function(e){return e===void 0&&(console.warn("THREE.Object3D: .getWorldPosition() target is now required"),e=new z),this.updateWorldMatrix(!0,!1),e.setFromMatrixPosition(this.matrixWorld)},getWorldQuaternion:function(e){return e===void 0&&(console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"),e=new Nn),this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(No,e,Np),e},getWorldScale:function(e){return e===void 0&&(console.warn("THREE.Object3D: .getWorldScale() target is now required"),e=new z),this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(No,Bp,e),e},getWorldDirection:function(e){e===void 0&&(console.warn("THREE.Object3D: .getWorldDirection() target is now required"),e=new z),this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return e.set(t[8],t[9],t[10]).normalize()},raycast:function(){},traverse:function(e){e(this);const t=this.children;for(let n=0,r=t.length;n<r;n++)t[n].traverse(e)},traverseVisible:function(e){if(this.visible===!1)return;e(this);const t=this.children;for(let n=0,r=t.length;n<r;n++)t[n].traverseVisible(e)},traverseAncestors:function(e){const t=this.parent;t!==null&&(e(t),t.traverseAncestors(e))},updateMatrix:function(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0},updateMatrixWorld:function(e){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||e)&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,e=!0);const t=this.children;for(let n=0,r=t.length;n<r;n++)t[n].updateMatrixWorld(e)},updateWorldMatrix:function(e,t){const n=this.parent;if(e===!0&&n!==null&&n.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),t===!0){const r=this.children;for(let i=0,o=r.length;i<o;i++)r[i].updateWorldMatrix(!1,!0)}},toJSON:function(e){const t=e===void 0||typeof e=="string",n={};t&&(e={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{}},n.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});const r={};function i(a,s){return a[s.uuid]===void 0&&(a[s.uuid]=s.toJSON(e)),s.uuid}if(r.uuid=this.uuid,r.type=this.type,this.name!==""&&(r.name=this.name),this.castShadow===!0&&(r.castShadow=!0),this.receiveShadow===!0&&(r.receiveShadow=!0),this.visible===!1&&(r.visible=!1),this.frustumCulled===!1&&(r.frustumCulled=!1),this.renderOrder!==0&&(r.renderOrder=this.renderOrder),JSON.stringify(this.userData)!=="{}"&&(r.userData=this.userData),r.layers=this.layers.mask,r.matrix=this.matrix.toArray(),this.matrixAutoUpdate===!1&&(r.matrixAutoUpdate=!1),this.isInstancedMesh&&(r.type="InstancedMesh",r.count=this.count,r.instanceMatrix=this.instanceMatrix.toJSON()),this.isMesh||this.isLine||this.isPoints){r.geometry=i(e.geometries,this.geometry);const a=this.geometry.parameters;if(a!==void 0&&a.shapes!==void 0){const s=a.shapes;if(Array.isArray(s))for(let c=0,u=s.length;c<u;c++){const p=s[c];i(e.shapes,p)}else i(e.shapes,s)}}if(this.isSkinnedMesh&&(r.bindMode=this.bindMode,r.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(i(e.skeletons,this.skeleton),r.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const a=[];for(let s=0,c=this.material.length;s<c;s++)a.push(i(e.materials,this.material[s]));r.material=a}else r.material=i(e.materials,this.material);if(this.children.length>0){r.children=[];for(let a=0;a<this.children.length;a++)r.children.push(this.children[a].toJSON(e).object)}if(this.animations.length>0){r.animations=[];for(let a=0;a<this.animations.length;a++){const s=this.animations[a];r.animations.push(i(e.animations,s))}}if(t){const a=o(e.geometries),s=o(e.materials),c=o(e.textures),u=o(e.images),p=o(e.shapes),d=o(e.skeletons),g=o(e.animations);a.length>0&&(n.geometries=a),s.length>0&&(n.materials=s),c.length>0&&(n.textures=c),u.length>0&&(n.images=u),p.length>0&&(n.shapes=p),d.length>0&&(n.skeletons=d),g.length>0&&(n.animations=g)}return n.object=r,n;function o(a){const s=[];for(const c in a){const u=a[c];delete u.metadata,s.push(u)}return s}},clone:function(e){return new this.constructor().copy(this,e)},copy:function(e,t=!0){if(this.name=e.name,this.up.copy(e.up),this.position.copy(e.position),this.rotation.order=e.rotation.order,this.quaternion.copy(e.quaternion),this.scale.copy(e.scale),this.matrix.copy(e.matrix),this.matrixWorld.copy(e.matrixWorld),this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrixWorldNeedsUpdate=e.matrixWorldNeedsUpdate,this.layers.mask=e.layers.mask,this.visible=e.visible,this.castShadow=e.castShadow,this.receiveShadow=e.receiveShadow,this.frustumCulled=e.frustumCulled,this.renderOrder=e.renderOrder,this.userData=JSON.parse(JSON.stringify(e.userData)),t===!0)for(let n=0;n<e.children.length;n++){const r=e.children[n];this.add(r.clone())}return this}});const wc=new z,Up=new z,zp=new Vn;class Er{constructor(e,t){Object.defineProperty(this,"isPlane",{value:!0}),this.normal=e!==void 0?e:new z(1,0,0),this.constant=t!==void 0?t:0}set(e,t){return this.normal.copy(e),this.constant=t,this}setComponents(e,t,n,r){return this.normal.set(e,t,n),this.constant=r,this}setFromNormalAndCoplanarPoint(e,t){return this.normal.copy(e),this.constant=-t.dot(this.normal),this}setFromCoplanarPoints(e,t,n){const r=wc.subVectors(n,t).cross(Up.subVectors(e,t)).normalize();return this.setFromNormalAndCoplanarPoint(r,e),this}clone(){return new this.constructor().copy(this)}copy(e){return this.normal.copy(e.normal),this.constant=e.constant,this}normalize(){const e=1/this.normal.length();return this.normal.multiplyScalar(e),this.constant*=e,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(e){return this.normal.dot(e)+this.constant}distanceToSphere(e){return this.distanceToPoint(e.center)-e.radius}projectPoint(e,t){return t===void 0&&(console.warn("THREE.Plane: .projectPoint() target is now required"),t=new z),t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)}intersectLine(e,t){t===void 0&&(console.warn("THREE.Plane: .intersectLine() target is now required"),t=new z);const n=e.delta(wc),r=this.normal.dot(n);if(r===0)return this.distanceToPoint(e.start)===0?t.copy(e.start):void 0;const i=-(e.start.dot(this.normal)+this.constant)/r;return i<0||i>1?void 0:t.copy(n).multiplyScalar(i).add(e.start)}intersectsLine(e){const t=this.distanceToPoint(e.start),n=this.distanceToPoint(e.end);return t<0&&n>0||n<0&&t>0}intersectsBox(e){return e.intersectsPlane(this)}intersectsSphere(e){return e.intersectsPlane(this)}coplanarPoint(e){return e===void 0&&(console.warn("THREE.Plane: .coplanarPoint() target is now required"),e=new z),e.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(e,t){const n=t||zp.getNormalMatrix(e),r=this.coplanarPoint(wc).applyMatrix4(e),i=this.normal.applyMatrix3(n).normalize();return this.constant=-r.dot(i),this}translate(e){return this.constant-=e.dot(this.normal),this}equals(e){return e.normal.equals(this.normal)&&e.constant===this.constant}}const fr=new z,kr=new z,_c=new z,Hr=new z,$i=new z,eo=new z,qu=new z,Mc=new z,Sc=new z,Tc=new z;class Bn{constructor(e,t,n){this.a=e!==void 0?e:new z,this.b=t!==void 0?t:new z,this.c=n!==void 0?n:new z}static getNormal(e,t,n,r){r===void 0&&(console.warn("THREE.Triangle: .getNormal() target is now required"),r=new z),r.subVectors(n,t),fr.subVectors(e,t),r.cross(fr);const i=r.lengthSq();return i>0?r.multiplyScalar(1/Math.sqrt(i)):r.set(0,0,0)}static getBarycoord(e,t,n,r,i){fr.subVectors(r,t),kr.subVectors(n,t),_c.subVectors(e,t);const o=fr.dot(fr),a=fr.dot(kr),s=fr.dot(_c),c=kr.dot(kr),u=kr.dot(_c),p=o*c-a*a;if(i===void 0&&(console.warn("THREE.Triangle: .getBarycoord() target is now required"),i=new z),p===0)return i.set(-2,-1,-1);const d=1/p,g=(c*s-a*u)*d,m=(o*u-a*s)*d;return i.set(1-g-m,m,g)}static containsPoint(e,t,n,r){return this.getBarycoord(e,t,n,r,Hr),Hr.x>=0&&Hr.y>=0&&Hr.x+Hr.y<=1}static getUV(e,t,n,r,i,o,a,s){return this.getBarycoord(e,t,n,r,Hr),s.set(0,0),s.addScaledVector(i,Hr.x),s.addScaledVector(o,Hr.y),s.addScaledVector(a,Hr.z),s}static isFrontFacing(e,t,n,r){return fr.subVectors(n,t),kr.subVectors(e,t),fr.cross(kr).dot(r)<0}set(e,t,n){return this.a.copy(e),this.b.copy(t),this.c.copy(n),this}setFromPointsAndIndices(e,t,n,r){return this.a.copy(e[t]),this.b.copy(e[n]),this.c.copy(e[r]),this}clone(){return new this.constructor().copy(this)}copy(e){return this.a.copy(e.a),this.b.copy(e.b),this.c.copy(e.c),this}getArea(){return fr.subVectors(this.c,this.b),kr.subVectors(this.a,this.b),.5*fr.cross(kr).length()}getMidpoint(e){return e===void 0&&(console.warn("THREE.Triangle: .getMidpoint() target is now required"),e=new z),e.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(e){return Bn.getNormal(this.a,this.b,this.c,e)}getPlane(e){return e===void 0&&(console.warn("THREE.Triangle: .getPlane() target is now required"),e=new Er),e.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(e,t){return Bn.getBarycoord(e,this.a,this.b,this.c,t)}getUV(e,t,n,r,i){return Bn.getUV(e,this.a,this.b,this.c,t,n,r,i)}containsPoint(e){return Bn.containsPoint(e,this.a,this.b,this.c)}isFrontFacing(e){return Bn.isFrontFacing(this.a,this.b,this.c,e)}intersectsBox(e){return e.intersectsTriangle(this)}closestPointToPoint(e,t){t===void 0&&(console.warn("THREE.Triangle: .closestPointToPoint() target is now required"),t=new z);const n=this.a,r=this.b,i=this.c;let o,a;$i.subVectors(r,n),eo.subVectors(i,n),Mc.subVectors(e,n);const s=$i.dot(Mc),c=eo.dot(Mc);if(s<=0&&c<=0)return t.copy(n);Sc.subVectors(e,r);const u=$i.dot(Sc),p=eo.dot(Sc);if(u>=0&&p<=u)return t.copy(r);const d=s*p-u*c;if(d<=0&&s>=0&&u<=0)return o=s/(s-u),t.copy(n).addScaledVector($i,o);Tc.subVectors(e,i);const g=$i.dot(Tc),m=eo.dot(Tc);if(m>=0&&g<=m)return t.copy(i);const x=g*c-s*m;if(x<=0&&c>=0&&m<=0)return a=c/(c-m),t.copy(n).addScaledVector(eo,a);const S=u*m-g*p;if(S<=0&&p-u>=0&&g-m>=0)return qu.subVectors(i,r),a=(p-u)/(p-u+(g-m)),t.copy(r).addScaledVector(qu,a);const b=1/(S+x+d);return o=x*b,a=d*b,t.copy(n).addScaledVector($i,o).addScaledVector(eo,a)}equals(e){return e.a.equals(this.a)&&e.b.equals(this.b)&&e.c.equals(this.c)}}const Yu={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},mr={h:0,s:0,l:0},Ga={h:0,s:0,l:0};function Ec(e,t,n){return n<0&&(n+=1),n>1&&(n-=1),n<1/6?e+6*(t-e)*n:n<.5?t:n<2/3?e+6*(t-e)*(2/3-n):e}function Ac(e){return e<.04045?.0773993808*e:Math.pow(.9478672986*e+.0521327014,2.4)}function Lc(e){return e<.0031308?12.92*e:1.055*Math.pow(e,.41666)-.055}class _t{constructor(e,t,n){return Object.defineProperty(this,"isColor",{value:!0}),t===void 0&&n===void 0?this.set(e):this.setRGB(e,t,n)}set(e){return e&&e.isColor?this.copy(e):typeof e=="number"?this.setHex(e):typeof e=="string"&&this.setStyle(e),this}setScalar(e){return this.r=e,this.g=e,this.b=e,this}setHex(e){return e=Math.floor(e),this.r=(e>>16&255)/255,this.g=(e>>8&255)/255,this.b=(255&e)/255,this}setRGB(e,t,n){return this.r=e,this.g=t,this.b=n,this}setHSL(e,t,n){if(e=Ft.euclideanModulo(e,1),t=Ft.clamp(t,0,1),n=Ft.clamp(n,0,1),t===0)this.r=this.g=this.b=n;else{const r=n<=.5?n*(1+t):n+t-n*t,i=2*n-r;this.r=Ec(i,r,e+1/3),this.g=Ec(i,r,e),this.b=Ec(i,r,e-1/3)}return this}setStyle(e){function t(r){r!==void 0&&parseFloat(r)<1&&console.warn("THREE.Color: Alpha component of "+e+" will be ignored.")}let n;if(n=/^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(e)){let r;const i=n[1],o=n[2];switch(i){case"rgb":case"rgba":if(r=/^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o))return this.r=Math.min(255,parseInt(r[1],10))/255,this.g=Math.min(255,parseInt(r[2],10))/255,this.b=Math.min(255,parseInt(r[3],10))/255,t(r[5]),this;if(r=/^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o))return this.r=Math.min(100,parseInt(r[1],10))/100,this.g=Math.min(100,parseInt(r[2],10))/100,this.b=Math.min(100,parseInt(r[3],10))/100,t(r[5]),this;break;case"hsl":case"hsla":if(r=/^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o)){const a=parseFloat(r[1])/360,s=parseInt(r[2],10)/100,c=parseInt(r[3],10)/100;return t(r[5]),this.setHSL(a,s,c)}}}else if(n=/^\#([A-Fa-f0-9]+)$/.exec(e)){const r=n[1],i=r.length;if(i===3)return this.r=parseInt(r.charAt(0)+r.charAt(0),16)/255,this.g=parseInt(r.charAt(1)+r.charAt(1),16)/255,this.b=parseInt(r.charAt(2)+r.charAt(2),16)/255,this;if(i===6)return this.r=parseInt(r.charAt(0)+r.charAt(1),16)/255,this.g=parseInt(r.charAt(2)+r.charAt(3),16)/255,this.b=parseInt(r.charAt(4)+r.charAt(5),16)/255,this}return e&&e.length>0?this.setColorName(e):this}setColorName(e){const t=Yu[e];return t!==void 0?this.setHex(t):console.warn("THREE.Color: Unknown color "+e),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(e){return this.r=e.r,this.g=e.g,this.b=e.b,this}copyGammaToLinear(e,t=2){return this.r=Math.pow(e.r,t),this.g=Math.pow(e.g,t),this.b=Math.pow(e.b,t),this}copyLinearToGamma(e,t=2){const n=t>0?1/t:1;return this.r=Math.pow(e.r,n),this.g=Math.pow(e.g,n),this.b=Math.pow(e.b,n),this}convertGammaToLinear(e){return this.copyGammaToLinear(this,e),this}convertLinearToGamma(e){return this.copyLinearToGamma(this,e),this}copySRGBToLinear(e){return this.r=Ac(e.r),this.g=Ac(e.g),this.b=Ac(e.b),this}copyLinearToSRGB(e){return this.r=Lc(e.r),this.g=Lc(e.g),this.b=Lc(e.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(){return 255*this.r<<16^255*this.g<<8^255*this.b<<0}getHexString(){return("000000"+this.getHex().toString(16)).slice(-6)}getHSL(e){e===void 0&&(console.warn("THREE.Color: .getHSL() target is now required"),e={h:0,s:0,l:0});const t=this.r,n=this.g,r=this.b,i=Math.max(t,n,r),o=Math.min(t,n,r);let a,s;const c=(o+i)/2;if(o===i)a=0,s=0;else{const u=i-o;switch(s=c<=.5?u/(i+o):u/(2-i-o),i){case t:a=(n-r)/u+(n<r?6:0);break;case n:a=(r-t)/u+2;break;case r:a=(t-n)/u+4}a/=6}return e.h=a,e.s=s,e.l=c,e}getStyle(){return"rgb("+(255*this.r|0)+","+(255*this.g|0)+","+(255*this.b|0)+")"}offsetHSL(e,t,n){return this.getHSL(mr),mr.h+=e,mr.s+=t,mr.l+=n,this.setHSL(mr.h,mr.s,mr.l),this}add(e){return this.r+=e.r,this.g+=e.g,this.b+=e.b,this}addColors(e,t){return this.r=e.r+t.r,this.g=e.g+t.g,this.b=e.b+t.b,this}addScalar(e){return this.r+=e,this.g+=e,this.b+=e,this}sub(e){return this.r=Math.max(0,this.r-e.r),this.g=Math.max(0,this.g-e.g),this.b=Math.max(0,this.b-e.b),this}multiply(e){return this.r*=e.r,this.g*=e.g,this.b*=e.b,this}multiplyScalar(e){return this.r*=e,this.g*=e,this.b*=e,this}lerp(e,t){return this.r+=(e.r-this.r)*t,this.g+=(e.g-this.g)*t,this.b+=(e.b-this.b)*t,this}lerpHSL(e,t){this.getHSL(mr),e.getHSL(Ga);const n=Ft.lerp(mr.h,Ga.h,t),r=Ft.lerp(mr.s,Ga.s,t),i=Ft.lerp(mr.l,Ga.l,t);return this.setHSL(n,r,i),this}equals(e){return e.r===this.r&&e.g===this.g&&e.b===this.b}fromArray(e,t=0){return this.r=e[t],this.g=e[t+1],this.b=e[t+2],this}toArray(e=[],t=0){return e[t]=this.r,e[t+1]=this.g,e[t+2]=this.b,e}fromBufferAttribute(e,t){return this.r=e.getX(t),this.g=e.getY(t),this.b=e.getZ(t),e.normalized===!0&&(this.r/=255,this.g/=255,this.b/=255),this}toJSON(){return this.getHex()}}_t.NAMES=Yu,_t.prototype.r=1,_t.prototype.g=1,_t.prototype.b=1;class Bo{constructor(e,t,n,r,i,o=0){this.a=e,this.b=t,this.c=n,this.normal=r&&r.isVector3?r:new z,this.vertexNormals=Array.isArray(r)?r:[],this.color=i&&i.isColor?i:new _t,this.vertexColors=Array.isArray(i)?i:[],this.materialIndex=o}clone(){return new this.constructor().copy(this)}copy(e){this.a=e.a,this.b=e.b,this.c=e.c,this.normal.copy(e.normal),this.color.copy(e.color),this.materialIndex=e.materialIndex;for(let t=0,n=e.vertexNormals.length;t<n;t++)this.vertexNormals[t]=e.vertexNormals[t].clone();for(let t=0,n=e.vertexColors.length;t<n;t++)this.vertexColors[t]=e.vertexColors[t].clone();return this}}let kp=0;function Nt(){Object.defineProperty(this,"id",{value:kp++}),this.uuid=Ft.generateUUID(),this.name="",this.type="Material",this.fog=!0,this.blending=Q,this.side=T,this.flatShading=!1,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.blendSrc=ut,this.blendDst=pt,this.blendEquation=Re,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=be,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=Uu,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=Ia,this.stencilZFail=Ia,this.stencilZPass=Ia,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaTest=0,this.premultipliedAlpha=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0}function sr(e){Nt.call(this),this.type="MeshBasicMaterial",this.color=new _t(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=Ze,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.setValues(e)}Nt.prototype=Object.assign(Object.create(Sr.prototype),{constructor:Nt,isMaterial:!0,onBeforeCompile:function(){},customProgramCacheKey:function(){return this.onBeforeCompile.toString()},setValues:function(e){if(e!==void 0)for(const t in e){const n=e[t];if(n===void 0){console.warn("THREE.Material: '"+t+"' parameter is undefined.");continue}if(t==="shading"){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=n===L;continue}const r=this[t];r!==void 0?r&&r.isColor?r.set(n):r&&r.isVector3&&n&&n.isVector3?r.copy(n):this[t]=n:console.warn("THREE."+this.type+": '"+t+"' is not a property of this material.")}},toJSON:function(e){const t=e===void 0||typeof e=="string";t&&(e={textures:{},images:{}});const n={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};function r(i){const o=[];for(const a in i){const s=i[a];delete s.metadata,o.push(s)}return o}if(n.uuid=this.uuid,n.type=this.type,this.name!==""&&(n.name=this.name),this.color&&this.color.isColor&&(n.color=this.color.getHex()),this.roughness!==void 0&&(n.roughness=this.roughness),this.metalness!==void 0&&(n.metalness=this.metalness),this.sheen&&this.sheen.isColor&&(n.sheen=this.sheen.getHex()),this.emissive&&this.emissive.isColor&&(n.emissive=this.emissive.getHex()),this.emissiveIntensity&&this.emissiveIntensity!==1&&(n.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(n.specular=this.specular.getHex()),this.shininess!==void 0&&(n.shininess=this.shininess),this.clearcoat!==void 0&&(n.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(n.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(n.clearcoatMap=this.clearcoatMap.toJSON(e).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(n.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(e).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(n.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(e).uuid,n.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.map&&this.map.isTexture&&(n.map=this.map.toJSON(e).uuid),this.matcap&&this.matcap.isTexture&&(n.matcap=this.matcap.toJSON(e).uuid),this.alphaMap&&this.alphaMap.isTexture&&(n.alphaMap=this.alphaMap.toJSON(e).uuid),this.lightMap&&this.lightMap.isTexture&&(n.lightMap=this.lightMap.toJSON(e).uuid),this.aoMap&&this.aoMap.isTexture&&(n.aoMap=this.aoMap.toJSON(e).uuid,n.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(n.bumpMap=this.bumpMap.toJSON(e).uuid,n.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(n.normalMap=this.normalMap.toJSON(e).uuid,n.normalMapType=this.normalMapType,n.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(n.displacementMap=this.displacementMap.toJSON(e).uuid,n.displacementScale=this.displacementScale,n.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(n.roughnessMap=this.roughnessMap.toJSON(e).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(n.metalnessMap=this.metalnessMap.toJSON(e).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(n.emissiveMap=this.emissiveMap.toJSON(e).uuid),this.specularMap&&this.specularMap.isTexture&&(n.specularMap=this.specularMap.toJSON(e).uuid),this.envMap&&this.envMap.isTexture&&(n.envMap=this.envMap.toJSON(e).uuid,n.reflectivity=this.reflectivity,n.refractionRatio=this.refractionRatio,this.combine!==void 0&&(n.combine=this.combine),this.envMapIntensity!==void 0&&(n.envMapIntensity=this.envMapIntensity)),this.gradientMap&&this.gradientMap.isTexture&&(n.gradientMap=this.gradientMap.toJSON(e).uuid),this.size!==void 0&&(n.size=this.size),this.sizeAttenuation!==void 0&&(n.sizeAttenuation=this.sizeAttenuation),this.blending!==Q&&(n.blending=this.blending),this.flatShading===!0&&(n.flatShading=this.flatShading),this.side!==T&&(n.side=this.side),this.vertexColors&&(n.vertexColors=!0),this.opacity<1&&(n.opacity=this.opacity),this.transparent===!0&&(n.transparent=this.transparent),n.depthFunc=this.depthFunc,n.depthTest=this.depthTest,n.depthWrite=this.depthWrite,n.stencilWrite=this.stencilWrite,n.stencilWriteMask=this.stencilWriteMask,n.stencilFunc=this.stencilFunc,n.stencilRef=this.stencilRef,n.stencilFuncMask=this.stencilFuncMask,n.stencilFail=this.stencilFail,n.stencilZFail=this.stencilZFail,n.stencilZPass=this.stencilZPass,this.rotation&&this.rotation!==0&&(n.rotation=this.rotation),this.polygonOffset===!0&&(n.polygonOffset=!0),this.polygonOffsetFactor!==0&&(n.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(n.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth&&this.linewidth!==1&&(n.linewidth=this.linewidth),this.dashSize!==void 0&&(n.dashSize=this.dashSize),this.gapSize!==void 0&&(n.gapSize=this.gapSize),this.scale!==void 0&&(n.scale=this.scale),this.dithering===!0&&(n.dithering=!0),this.alphaTest>0&&(n.alphaTest=this.alphaTest),this.premultipliedAlpha===!0&&(n.premultipliedAlpha=this.premultipliedAlpha),this.wireframe===!0&&(n.wireframe=this.wireframe),this.wireframeLinewidth>1&&(n.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(n.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(n.wireframeLinejoin=this.wireframeLinejoin),this.morphTargets===!0&&(n.morphTargets=!0),this.morphNormals===!0&&(n.morphNormals=!0),this.skinning===!0&&(n.skinning=!0),this.visible===!1&&(n.visible=!1),this.toneMapped===!1&&(n.toneMapped=!1),JSON.stringify(this.userData)!=="{}"&&(n.userData=this.userData),t){const i=r(e.textures),o=r(e.images);i.length>0&&(n.textures=i),o.length>0&&(n.images=o)}return n},clone:function(){return new this.constructor().copy(this)},copy:function(e){this.name=e.name,this.fog=e.fog,this.blending=e.blending,this.side=e.side,this.flatShading=e.flatShading,this.vertexColors=e.vertexColors,this.opacity=e.opacity,this.transparent=e.transparent,this.blendSrc=e.blendSrc,this.blendDst=e.blendDst,this.blendEquation=e.blendEquation,this.blendSrcAlpha=e.blendSrcAlpha,this.blendDstAlpha=e.blendDstAlpha,this.blendEquationAlpha=e.blendEquationAlpha,this.depthFunc=e.depthFunc,this.depthTest=e.depthTest,this.depthWrite=e.depthWrite,this.stencilWriteMask=e.stencilWriteMask,this.stencilFunc=e.stencilFunc,this.stencilRef=e.stencilRef,this.stencilFuncMask=e.stencilFuncMask,this.stencilFail=e.stencilFail,this.stencilZFail=e.stencilZFail,this.stencilZPass=e.stencilZPass,this.stencilWrite=e.stencilWrite;const t=e.clippingPlanes;let n=null;if(t!==null){const r=t.length;n=new Array(r);for(let i=0;i!==r;++i)n[i]=t[i].clone()}return this.clippingPlanes=n,this.clipIntersection=e.clipIntersection,this.clipShadows=e.clipShadows,this.shadowSide=e.shadowSide,this.colorWrite=e.colorWrite,this.precision=e.precision,this.polygonOffset=e.polygonOffset,this.polygonOffsetFactor=e.polygonOffsetFactor,this.polygonOffsetUnits=e.polygonOffsetUnits,this.dithering=e.dithering,this.alphaTest=e.alphaTest,this.premultipliedAlpha=e.premultipliedAlpha,this.visible=e.visible,this.toneMapped=e.toneMapped,this.userData=JSON.parse(JSON.stringify(e.userData)),this},dispose:function(){this.dispatchEvent({type:"dispose"})}}),Object.defineProperty(Nt.prototype,"needsUpdate",{set:function(e){e===!0&&this.version++}}),sr.prototype=Object.create(Nt.prototype),sr.prototype.constructor=sr,sr.prototype.isMeshBasicMaterial=!0,sr.prototype.copy=function(e){return Nt.prototype.copy.call(this,e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this};const cn=new z,Va=new Je;function Rt(e,t,n){if(Array.isArray(e))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.name="",this.array=e,this.itemSize=t,this.count=e!==void 0?e.length/t:0,this.normalized=n===!0,this.usage=Ro,this.updateRange={offset:0,count:-1},this.version=0}function Fo(e,t,n){Rt.call(this,new Int8Array(e),t,n)}function Uo(e,t,n){Rt.call(this,new Uint8Array(e),t,n)}function zo(e,t,n){Rt.call(this,new Uint8ClampedArray(e),t,n)}function ko(e,t,n){Rt.call(this,new Int16Array(e),t,n)}function Si(e,t,n){Rt.call(this,new Uint16Array(e),t,n)}function Ho(e,t,n){Rt.call(this,new Int32Array(e),t,n)}function Ti(e,t,n){Rt.call(this,new Uint32Array(e),t,n)}function Go(e,t,n){Rt.call(this,new Uint16Array(e),t,n)}function yt(e,t,n){Rt.call(this,new Float32Array(e),t,n)}function Vo(e,t,n){Rt.call(this,new Float64Array(e),t,n)}Object.defineProperty(Rt.prototype,"needsUpdate",{set:function(e){e===!0&&this.version++}}),Object.assign(Rt.prototype,{isBufferAttribute:!0,onUploadCallback:function(){},setUsage:function(e){return this.usage=e,this},copy:function(e){return this.name=e.name,this.array=new e.array.constructor(e.array),this.itemSize=e.itemSize,this.count=e.count,this.normalized=e.normalized,this.usage=e.usage,this},copyAt:function(e,t,n){e*=this.itemSize,n*=t.itemSize;for(let r=0,i=this.itemSize;r<i;r++)this.array[e+r]=t.array[n+r];return this},copyArray:function(e){return this.array.set(e),this},copyColorsArray:function(e){const t=this.array;let n=0;for(let r=0,i=e.length;r<i;r++){let o=e[r];o===void 0&&(console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined",r),o=new _t),t[n++]=o.r,t[n++]=o.g,t[n++]=o.b}return this},copyVector2sArray:function(e){const t=this.array;let n=0;for(let r=0,i=e.length;r<i;r++){let o=e[r];o===void 0&&(console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined",r),o=new Je),t[n++]=o.x,t[n++]=o.y}return this},copyVector3sArray:function(e){const t=this.array;let n=0;for(let r=0,i=e.length;r<i;r++){let o=e[r];o===void 0&&(console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined",r),o=new z),t[n++]=o.x,t[n++]=o.y,t[n++]=o.z}return this},copyVector4sArray:function(e){const t=this.array;let n=0;for(let r=0,i=e.length;r<i;r++){let o=e[r];o===void 0&&(console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined",r),o=new nn),t[n++]=o.x,t[n++]=o.y,t[n++]=o.z,t[n++]=o.w}return this},applyMatrix3:function(e){if(this.itemSize===2)for(let t=0,n=this.count;t<n;t++)Va.fromBufferAttribute(this,t),Va.applyMatrix3(e),this.setXY(t,Va.x,Va.y);else if(this.itemSize===3)for(let t=0,n=this.count;t<n;t++)cn.fromBufferAttribute(this,t),cn.applyMatrix3(e),this.setXYZ(t,cn.x,cn.y,cn.z);return this},applyMatrix4:function(e){for(let t=0,n=this.count;t<n;t++)cn.x=this.getX(t),cn.y=this.getY(t),cn.z=this.getZ(t),cn.applyMatrix4(e),this.setXYZ(t,cn.x,cn.y,cn.z);return this},applyNormalMatrix:function(e){for(let t=0,n=this.count;t<n;t++)cn.x=this.getX(t),cn.y=this.getY(t),cn.z=this.getZ(t),cn.applyNormalMatrix(e),this.setXYZ(t,cn.x,cn.y,cn.z);return this},transformDirection:function(e){for(let t=0,n=this.count;t<n;t++)cn.x=this.getX(t),cn.y=this.getY(t),cn.z=this.getZ(t),cn.transformDirection(e),this.setXYZ(t,cn.x,cn.y,cn.z);return this},set:function(e,t=0){return this.array.set(e,t),this},getX:function(e){return this.array[e*this.itemSize]},setX:function(e,t){return this.array[e*this.itemSize]=t,this},getY:function(e){return this.array[e*this.itemSize+1]},setY:function(e,t){return this.array[e*this.itemSize+1]=t,this},getZ:function(e){return this.array[e*this.itemSize+2]},setZ:function(e,t){return this.array[e*this.itemSize+2]=t,this},getW:function(e){return this.array[e*this.itemSize+3]},setW:function(e,t){return this.array[e*this.itemSize+3]=t,this},setXY:function(e,t,n){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=n,this},setXYZ:function(e,t,n,r){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=n,this.array[e+2]=r,this},setXYZW:function(e,t,n,r,i){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=n,this.array[e+2]=r,this.array[e+3]=i,this},onUpload:function(e){return this.onUploadCallback=e,this},clone:function(){return new this.constructor(this.array,this.itemSize).copy(this)},toJSON:function(){return{itemSize:this.itemSize,type:this.array.constructor.name,array:Array.prototype.slice.call(this.array),normalized:this.normalized}}}),Fo.prototype=Object.create(Rt.prototype),Fo.prototype.constructor=Fo,Uo.prototype=Object.create(Rt.prototype),Uo.prototype.constructor=Uo,zo.prototype=Object.create(Rt.prototype),zo.prototype.constructor=zo,ko.prototype=Object.create(Rt.prototype),ko.prototype.constructor=ko,Si.prototype=Object.create(Rt.prototype),Si.prototype.constructor=Si,Ho.prototype=Object.create(Rt.prototype),Ho.prototype.constructor=Ho,Ti.prototype=Object.create(Rt.prototype),Ti.prototype.constructor=Ti,Go.prototype=Object.create(Rt.prototype),Go.prototype.constructor=Go,Go.prototype.isFloat16BufferAttribute=!0,yt.prototype=Object.create(Rt.prototype),yt.prototype.constructor=yt,Vo.prototype=Object.create(Rt.prototype),Vo.prototype.constructor=Vo;class Hp{constructor(){this.vertices=[],this.normals=[],this.colors=[],this.uvs=[],this.uvs2=[],this.groups=[],this.morphTargets={},this.skinWeights=[],this.skinIndices=[],this.boundingBox=null,this.boundingSphere=null,this.verticesNeedUpdate=!1,this.normalsNeedUpdate=!1,this.colorsNeedUpdate=!1,this.uvsNeedUpdate=!1,this.groupsNeedUpdate=!1}computeGroups(e){const t=[];let n,r,i;const o=e.faces;for(r=0;r<o.length;r++){const a=o[r];a.materialIndex!==i&&(i=a.materialIndex,n!==void 0&&(n.count=3*r-n.start,t.push(n)),n={start:3*r,materialIndex:i})}n!==void 0&&(n.count=3*r-n.start,t.push(n)),this.groups=t}fromGeometry(e){const t=e.faces,n=e.vertices,r=e.faceVertexUvs,i=r[0]&&r[0].length>0,o=r[1]&&r[1].length>0,a=e.morphTargets,s=a.length;let c;if(s>0){c=[];for(let b=0;b<s;b++)c[b]={name:a[b].name,data:[]};this.morphTargets.position=c}const u=e.morphNormals,p=u.length;let d;if(p>0){d=[];for(let b=0;b<p;b++)d[b]={name:u[b].name,data:[]};this.morphTargets.normal=d}const g=e.skinIndices,m=e.skinWeights,x=g.length===n.length,S=m.length===n.length;n.length>0&&t.length===0&&console.error("THREE.DirectGeometry: Faceless geometries are not supported.");for(let b=0;b<t.length;b++){const R=t[b];this.vertices.push(n[R.a],n[R.b],n[R.c]);const F=R.vertexNormals;if(F.length===3)this.normals.push(F[0],F[1],F[2]);else{const k=R.normal;this.normals.push(k,k,k)}const ee=R.vertexColors;if(ee.length===3)this.colors.push(ee[0],ee[1],ee[2]);else{const k=R.color;this.colors.push(k,k,k)}if(i===!0){const k=r[0][b];k!==void 0?this.uvs.push(k[0],k[1],k[2]):(console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ",b),this.uvs.push(new Je,new Je,new Je))}if(o===!0){const k=r[1][b];k!==void 0?this.uvs2.push(k[0],k[1],k[2]):(console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ",b),this.uvs2.push(new Je,new Je,new Je))}for(let k=0;k<s;k++){const K=a[k].vertices;c[k].data.push(K[R.a],K[R.b],K[R.c])}for(let k=0;k<p;k++){const K=u[k].vertexNormals[b];d[k].data.push(K.a,K.b,K.c)}x&&this.skinIndices.push(g[R.a],g[R.b],g[R.c]),S&&this.skinWeights.push(m[R.a],m[R.b],m[R.c])}return this.computeGroups(e),this.verticesNeedUpdate=e.verticesNeedUpdate,this.normalsNeedUpdate=e.normalsNeedUpdate,this.colorsNeedUpdate=e.colorsNeedUpdate,this.uvsNeedUpdate=e.uvsNeedUpdate,this.groupsNeedUpdate=e.groupsNeedUpdate,e.boundingSphere!==null&&(this.boundingSphere=e.boundingSphere.clone()),e.boundingBox!==null&&(this.boundingBox=e.boundingBox.clone()),this}}function Zu(e){if(e.length===0)return-1/0;let t=e[0];for(let n=1,r=e.length;n<r;++n)e[n]>t&&(t=e[n]);return t}const Gp={Int8Array,Uint8Array,Uint8ClampedArray:typeof Uint8ClampedArray!="undefined"?Uint8ClampedArray:Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array};function jo(e,t){return new Gp[e](t)}let Vp=1;const Ar=new Ht,Cc=new At,to=new z,$n=new Tr,Wo=new Tr,Ln=new z;function Ct(){Object.defineProperty(this,"id",{value:Vp+=2}),this.uuid=Ft.generateUUID(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}Ct.prototype=Object.assign(Object.create(Sr.prototype),{constructor:Ct,isBufferGeometry:!0,getIndex:function(){return this.index},setIndex:function(e){return Array.isArray(e)?this.index=new(Zu(e)>65535?Ti:Si)(e,1):this.index=e,this},getAttribute:function(e){return this.attributes[e]},setAttribute:function(e,t){return this.attributes[e]=t,this},deleteAttribute:function(e){return delete this.attributes[e],this},hasAttribute:function(e){return this.attributes[e]!==void 0},addGroup:function(e,t,n=0){this.groups.push({start:e,count:t,materialIndex:n})},clearGroups:function(){this.groups=[]},setDrawRange:function(e,t){this.drawRange.start=e,this.drawRange.count=t},applyMatrix4:function(e){const t=this.attributes.position;t!==void 0&&(t.applyMatrix4(e),t.needsUpdate=!0);const n=this.attributes.normal;if(n!==void 0){const i=new Vn().getNormalMatrix(e);n.applyNormalMatrix(i),n.needsUpdate=!0}const r=this.attributes.tangent;return r!==void 0&&(r.transformDirection(e),r.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this},rotateX:function(e){return Ar.makeRotationX(e),this.applyMatrix4(Ar),this},rotateY:function(e){return Ar.makeRotationY(e),this.applyMatrix4(Ar),this},rotateZ:function(e){return Ar.makeRotationZ(e),this.applyMatrix4(Ar),this},translate:function(e,t,n){return Ar.makeTranslation(e,t,n),this.applyMatrix4(Ar),this},scale:function(e,t,n){return Ar.makeScale(e,t,n),this.applyMatrix4(Ar),this},lookAt:function(e){return Cc.lookAt(e),Cc.updateMatrix(),this.applyMatrix4(Cc.matrix),this},center:function(){return this.computeBoundingBox(),this.boundingBox.getCenter(to).negate(),this.translate(to.x,to.y,to.z),this},setFromObject:function(e){const t=e.geometry;if(e.isPoints||e.isLine){const n=new yt(3*t.vertices.length,3),r=new yt(3*t.colors.length,3);if(this.setAttribute("position",n.copyVector3sArray(t.vertices)),this.setAttribute("color",r.copyColorsArray(t.colors)),t.lineDistances&&t.lineDistances.length===t.vertices.length){const i=new yt(t.lineDistances.length,1);this.setAttribute("lineDistance",i.copyArray(t.lineDistances))}t.boundingSphere!==null&&(this.boundingSphere=t.boundingSphere.clone()),t.boundingBox!==null&&(this.boundingBox=t.boundingBox.clone())}else e.isMesh&&t&&t.isGeometry&&this.fromGeometry(t);return this},setFromPoints:function(e){const t=[];for(let n=0,r=e.length;n<r;n++){const i=e[n];t.push(i.x,i.y,i.z||0)}return this.setAttribute("position",new yt(t,3)),this},updateFromObject:function(e){let t=e.geometry;if(e.isMesh){let n=t.__directGeometry;if(t.elementsNeedUpdate===!0&&(n=void 0,t.elementsNeedUpdate=!1),n===void 0)return this.fromGeometry(t);n.verticesNeedUpdate=t.verticesNeedUpdate,n.normalsNeedUpdate=t.normalsNeedUpdate,n.colorsNeedUpdate=t.colorsNeedUpdate,n.uvsNeedUpdate=t.uvsNeedUpdate,n.groupsNeedUpdate=t.groupsNeedUpdate,t.verticesNeedUpdate=!1,t.normalsNeedUpdate=!1,t.colorsNeedUpdate=!1,t.uvsNeedUpdate=!1,t.groupsNeedUpdate=!1,t=n}if(t.verticesNeedUpdate===!0){const n=this.attributes.position;n!==void 0&&(n.copyVector3sArray(t.vertices),n.needsUpdate=!0),t.verticesNeedUpdate=!1}if(t.normalsNeedUpdate===!0){const n=this.attributes.normal;n!==void 0&&(n.copyVector3sArray(t.normals),n.needsUpdate=!0),t.normalsNeedUpdate=!1}if(t.colorsNeedUpdate===!0){const n=this.attributes.color;n!==void 0&&(n.copyColorsArray(t.colors),n.needsUpdate=!0),t.colorsNeedUpdate=!1}if(t.uvsNeedUpdate){const n=this.attributes.uv;n!==void 0&&(n.copyVector2sArray(t.uvs),n.needsUpdate=!0),t.uvsNeedUpdate=!1}if(t.lineDistancesNeedUpdate){const n=this.attributes.lineDistance;n!==void 0&&(n.copyArray(t.lineDistances),n.needsUpdate=!0),t.lineDistancesNeedUpdate=!1}return t.groupsNeedUpdate&&(t.computeGroups(e.geometry),this.groups=t.groups,t.groupsNeedUpdate=!1),this},fromGeometry:function(e){return e.__directGeometry=new Hp().fromGeometry(e),this.fromDirectGeometry(e.__directGeometry)},fromDirectGeometry:function(e){const t=new Float32Array(3*e.vertices.length);if(this.setAttribute("position",new Rt(t,3).copyVector3sArray(e.vertices)),e.normals.length>0){const n=new Float32Array(3*e.normals.length);this.setAttribute("normal",new Rt(n,3).copyVector3sArray(e.normals))}if(e.colors.length>0){const n=new Float32Array(3*e.colors.length);this.setAttribute("color",new Rt(n,3).copyColorsArray(e.colors))}if(e.uvs.length>0){const n=new Float32Array(2*e.uvs.length);this.setAttribute("uv",new Rt(n,2).copyVector2sArray(e.uvs))}if(e.uvs2.length>0){const n=new Float32Array(2*e.uvs2.length);this.setAttribute("uv2",new Rt(n,2).copyVector2sArray(e.uvs2))}this.groups=e.groups;for(const n in e.morphTargets){const r=[],i=e.morphTargets[n];for(let o=0,a=i.length;o<a;o++){const s=i[o],c=new yt(3*s.data.length,3);c.name=s.name,r.push(c.copyVector3sArray(s.data))}this.morphAttributes[n]=r}if(e.skinIndices.length>0){const n=new yt(4*e.skinIndices.length,4);this.setAttribute("skinIndex",n.copyVector4sArray(e.skinIndices))}if(e.skinWeights.length>0){const n=new yt(4*e.skinWeights.length,4);this.setAttribute("skinWeight",n.copyVector4sArray(e.skinWeights))}return e.boundingSphere!==null&&(this.boundingSphere=e.boundingSphere.clone()),e.boundingBox!==null&&(this.boundingBox=e.boundingBox.clone()),this},computeBoundingBox:function(){this.boundingBox===null&&(this.boundingBox=new Tr);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute)return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),void this.boundingBox.set(new z(-1/0,-1/0,-1/0),new z(1/0,1/0,1/0));if(e!==void 0){if(this.boundingBox.setFromBufferAttribute(e),t)for(let n=0,r=t.length;n<r;n++){const i=t[n];$n.setFromBufferAttribute(i),this.morphTargetsRelative?(Ln.addVectors(this.boundingBox.min,$n.min),this.boundingBox.expandByPoint(Ln),Ln.addVectors(this.boundingBox.max,$n.max),this.boundingBox.expandByPoint(Ln)):(this.boundingBox.expandByPoint($n.min),this.boundingBox.expandByPoint($n.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)},computeBoundingSphere:function(){this.boundingSphere===null&&(this.boundingSphere=new Fr);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute)return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),void this.boundingSphere.set(new z,1/0);if(e){const n=this.boundingSphere.center;if($n.setFromBufferAttribute(e),t)for(let i=0,o=t.length;i<o;i++){const a=t[i];Wo.setFromBufferAttribute(a),this.morphTargetsRelative?(Ln.addVectors($n.min,Wo.min),$n.expandByPoint(Ln),Ln.addVectors($n.max,Wo.max),$n.expandByPoint(Ln)):($n.expandByPoint(Wo.min),$n.expandByPoint(Wo.max))}$n.getCenter(n);let r=0;for(let i=0,o=e.count;i<o;i++)Ln.fromBufferAttribute(e,i),r=Math.max(r,n.distanceToSquared(Ln));if(t)for(let i=0,o=t.length;i<o;i++){const a=t[i],s=this.morphTargetsRelative;for(let c=0,u=a.count;c<u;c++)Ln.fromBufferAttribute(a,c),s&&(to.fromBufferAttribute(e,c),Ln.add(to)),r=Math.max(r,n.distanceToSquared(Ln))}this.boundingSphere.radius=Math.sqrt(r),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}},computeFaceNormals:function(){},computeVertexNormals:function(){const e=this.index,t=this.getAttribute("position");if(t!==void 0){let n=this.getAttribute("normal");if(n===void 0)n=new Rt(new Float32Array(3*t.count),3),this.setAttribute("normal",n);else for(let d=0,g=n.count;d<g;d++)n.setXYZ(d,0,0,0);const r=new z,i=new z,o=new z,a=new z,s=new z,c=new z,u=new z,p=new z;if(e)for(let d=0,g=e.count;d<g;d+=3){const m=e.getX(d+0),x=e.getX(d+1),S=e.getX(d+2);r.fromBufferAttribute(t,m),i.fromBufferAttribute(t,x),o.fromBufferAttribute(t,S),u.subVectors(o,i),p.subVectors(r,i),u.cross(p),a.fromBufferAttribute(n,m),s.fromBufferAttribute(n,x),c.fromBufferAttribute(n,S),a.add(u),s.add(u),c.add(u),n.setXYZ(m,a.x,a.y,a.z),n.setXYZ(x,s.x,s.y,s.z),n.setXYZ(S,c.x,c.y,c.z)}else for(let d=0,g=t.count;d<g;d+=3)r.fromBufferAttribute(t,d+0),i.fromBufferAttribute(t,d+1),o.fromBufferAttribute(t,d+2),u.subVectors(o,i),p.subVectors(r,i),u.cross(p),n.setXYZ(d+0,u.x,u.y,u.z),n.setXYZ(d+1,u.x,u.y,u.z),n.setXYZ(d+2,u.x,u.y,u.z);this.normalizeNormals(),n.needsUpdate=!0}},merge:function(e,t){if(!e||!e.isBufferGeometry)return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",e);t===void 0&&(t=0,console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));const n=this.attributes;for(const r in n){if(e.attributes[r]===void 0)continue;const i=n[r].array,o=e.attributes[r],a=o.array,s=o.itemSize*t,c=Math.min(a.length,i.length-s);for(let u=0,p=s;u<c;u++,p++)i[p]=a[u]}return this},normalizeNormals:function(){const e=this.attributes.normal;for(let t=0,n=e.count;t<n;t++)Ln.fromBufferAttribute(e,t),Ln.normalize(),e.setXYZ(t,Ln.x,Ln.y,Ln.z)},toNonIndexed:function(){function e(a,s){const c=a.array,u=a.itemSize,p=a.normalized,d=new c.constructor(s.length*u);let g=0,m=0;for(let x=0,S=s.length;x<S;x++){g=s[x]*u;for(let b=0;b<u;b++)d[m++]=c[g++]}return new Rt(d,u,p)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."),this;const t=new Ct,n=this.index.array,r=this.attributes;for(const a in r){const s=e(r[a],n);t.setAttribute(a,s)}const i=this.morphAttributes;for(const a in i){const s=[],c=i[a];for(let u=0,p=c.length;u<p;u++){const d=e(c[u],n);s.push(d)}t.morphAttributes[a]=s}t.morphTargetsRelative=this.morphTargetsRelative;const o=this.groups;for(let a=0,s=o.length;a<s;a++){const c=o[a];t.addGroup(c.start,c.count,c.materialIndex)}return t},toJSON:function(){const e={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(e.uuid=this.uuid,e.type=this.type,this.name!==""&&(e.name=this.name),Object.keys(this.userData).length>0&&(e.userData=this.userData),this.parameters!==void 0){const s=this.parameters;for(const c in s)s[c]!==void 0&&(e[c]=s[c]);return e}e.data={attributes:{}};const t=this.index;t!==null&&(e.data.index={type:t.array.constructor.name,array:Array.prototype.slice.call(t.array)});const n=this.attributes;for(const s in n){const c=n[s],u=c.toJSON(e.data);c.name!==""&&(u.name=c.name),e.data.attributes[s]=u}const r={};let i=!1;for(const s in this.morphAttributes){const c=this.morphAttributes[s],u=[];for(let p=0,d=c.length;p<d;p++){const g=c[p],m=g.toJSON(e.data);g.name!==""&&(m.name=g.name),u.push(m)}u.length>0&&(r[s]=u,i=!0)}i&&(e.data.morphAttributes=r,e.data.morphTargetsRelative=this.morphTargetsRelative);const o=this.groups;o.length>0&&(e.data.groups=JSON.parse(JSON.stringify(o)));const a=this.boundingSphere;return a!==null&&(e.data.boundingSphere={center:a.center.toArray(),radius:a.radius}),e},clone:function(){return new Ct().copy(this)},copy:function(e){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const t={};this.name=e.name;const n=e.index;n!==null&&this.setIndex(n.clone(t));const r=e.attributes;for(const c in r){const u=r[c];this.setAttribute(c,u.clone(t))}const i=e.morphAttributes;for(const c in i){const u=[],p=i[c];for(let d=0,g=p.length;d<g;d++)u.push(p[d].clone(t));this.morphAttributes[c]=u}this.morphTargetsRelative=e.morphTargetsRelative;const o=e.groups;for(let c=0,u=o.length;c<u;c++){const p=o[c];this.addGroup(p.start,p.count,p.materialIndex)}const a=e.boundingBox;a!==null&&(this.boundingBox=a.clone());const s=e.boundingSphere;return s!==null&&(this.boundingSphere=s.clone()),this.drawRange.start=e.drawRange.start,this.drawRange.count=e.drawRange.count,this.userData=e.userData,this},dispose:function(){this.dispatchEvent({type:"dispose"})}});const Ju=new Ht,Ei=new Ji,Pc=new Fr,ei=new z,ti=new z,ni=new z,Rc=new z,Oc=new z,Dc=new z,ja=new z,Wa=new z,Xa=new z,no=new Je,ro=new Je,io=new Je,Xo=new z,qa=new z;function pn(e,t){At.call(this),this.type="Mesh",this.geometry=e!==void 0?e:new Ct,this.material=t!==void 0?t:new sr,this.updateMorphTargets()}function Ku(e,t,n,r,i,o,a,s){let c;if(c=t.side===Z?r.intersectTriangle(a,o,i,!0,s):r.intersectTriangle(i,o,a,t.side!==J,s),c===null)return null;qa.copy(s),qa.applyMatrix4(e.matrixWorld);const u=n.ray.origin.distanceTo(qa);return u<n.near||u>n.far?null:{distance:u,point:qa.clone(),object:e}}function Ya(e,t,n,r,i,o,a,s,c,u,p,d){ei.fromBufferAttribute(i,u),ti.fromBufferAttribute(i,p),ni.fromBufferAttribute(i,d);const g=e.morphTargetInfluences;if(t.morphTargets&&o&&g){ja.set(0,0,0),Wa.set(0,0,0),Xa.set(0,0,0);for(let x=0,S=o.length;x<S;x++){const b=g[x],R=o[x];b!==0&&(Rc.fromBufferAttribute(R,u),Oc.fromBufferAttribute(R,p),Dc.fromBufferAttribute(R,d),a?(ja.addScaledVector(Rc,b),Wa.addScaledVector(Oc,b),Xa.addScaledVector(Dc,b)):(ja.addScaledVector(Rc.sub(ei),b),Wa.addScaledVector(Oc.sub(ti),b),Xa.addScaledVector(Dc.sub(ni),b)))}ei.add(ja),ti.add(Wa),ni.add(Xa)}e.isSkinnedMesh&&(e.boneTransform(u,ei),e.boneTransform(p,ti),e.boneTransform(d,ni));const m=Ku(e,t,n,r,ei,ti,ni,Xo);if(m){s&&(no.fromBufferAttribute(s,u),ro.fromBufferAttribute(s,p),io.fromBufferAttribute(s,d),m.uv=Bn.getUV(Xo,ei,ti,ni,no,ro,io,new Je)),c&&(no.fromBufferAttribute(c,u),ro.fromBufferAttribute(c,p),io.fromBufferAttribute(c,d),m.uv2=Bn.getUV(Xo,ei,ti,ni,no,ro,io,new Je));const x=new Bo(u,p,d);Bn.getNormal(ei,ti,ni,x.normal),m.face=x}return m}pn.prototype=Object.assign(Object.create(At.prototype),{constructor:pn,isMesh:!0,copy:function(e){return At.prototype.copy.call(this,e),e.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=e.morphTargetInfluences.slice()),e.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},e.morphTargetDictionary)),this.material=e.material,this.geometry=e.geometry,this},updateMorphTargets:function(){const e=this.geometry;if(e.isBufferGeometry){const t=e.morphAttributes,n=Object.keys(t);if(n.length>0){const r=t[n[0]];if(r!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let i=0,o=r.length;i<o;i++){const a=r[i].name||String(i);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=i}}}}else{const t=e.morphTargets;t!==void 0&&t.length>0&&console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}},raycast:function(e,t){const n=this.geometry,r=this.material,i=this.matrixWorld;if(r===void 0)return;if(n.boundingSphere===null&&n.computeBoundingSphere(),Pc.copy(n.boundingSphere),Pc.applyMatrix4(i),e.ray.intersectsSphere(Pc)===!1)return;if(Ju.copy(i).invert(),Ei.copy(e.ray).applyMatrix4(Ju),n.boundingBox!==null&&Ei.intersectsBox(n.boundingBox)===!1)return;let o;if(n.isBufferGeometry){const a=n.index,s=n.attributes.position,c=n.morphAttributes.position,u=n.morphTargetsRelative,p=n.attributes.uv,d=n.attributes.uv2,g=n.groups,m=n.drawRange;if(a!==null)if(Array.isArray(r))for(let x=0,S=g.length;x<S;x++){const b=g[x],R=r[b.materialIndex];for(let F=Math.max(b.start,m.start),ee=Math.min(b.start+b.count,m.start+m.count);F<ee;F+=3){const k=a.getX(F),K=a.getX(F+1),le=a.getX(F+2);o=Ya(this,R,e,Ei,s,c,u,p,d,k,K,le),o&&(o.faceIndex=Math.floor(F/3),o.face.materialIndex=b.materialIndex,t.push(o))}}else for(let x=Math.max(0,m.start),S=Math.min(a.count,m.start+m.count);x<S;x+=3){const b=a.getX(x),R=a.getX(x+1),F=a.getX(x+2);o=Ya(this,r,e,Ei,s,c,u,p,d,b,R,F),o&&(o.faceIndex=Math.floor(x/3),t.push(o))}else if(s!==void 0)if(Array.isArray(r))for(let x=0,S=g.length;x<S;x++){const b=g[x],R=r[b.materialIndex];for(let F=Math.max(b.start,m.start),ee=Math.min(b.start+b.count,m.start+m.count);F<ee;F+=3)o=Ya(this,R,e,Ei,s,c,u,p,d,F,F+1,F+2),o&&(o.faceIndex=Math.floor(F/3),o.face.materialIndex=b.materialIndex,t.push(o))}else for(let x=Math.max(0,m.start),S=Math.min(s.count,m.start+m.count);x<S;x+=3)o=Ya(this,r,e,Ei,s,c,u,p,d,x,x+1,x+2),o&&(o.faceIndex=Math.floor(x/3),t.push(o))}else if(n.isGeometry){const a=Array.isArray(r),s=n.vertices,c=n.faces;let u;const p=n.faceVertexUvs[0];p.length>0&&(u=p);for(let d=0,g=c.length;d<g;d++){const m=c[d],x=a?r[m.materialIndex]:r;if(x===void 0)continue;const S=s[m.a],b=s[m.b],R=s[m.c];if(o=Ku(this,x,e,Ei,S,b,R,Xo),o){if(u&&u[d]){const F=u[d];no.copy(F[0]),ro.copy(F[1]),io.copy(F[2]),o.uv=Bn.getUV(Xo,S,b,R,no,ro,io,new Je)}o.face=m,o.faceIndex=d,t.push(o)}}}}});class qo extends Ct{constructor(e=1,t=1,n=1,r=1,i=1,o=1){super(),this.type="BoxBufferGeometry",this.parameters={width:e,height:t,depth:n,widthSegments:r,heightSegments:i,depthSegments:o};const a=this;r=Math.floor(r),i=Math.floor(i),o=Math.floor(o);const s=[],c=[],u=[],p=[];let d=0,g=0;function m(x,S,b,R,F,ee,k,K,le,ge,Le){const Ae=ee/le,xe=k/ge,Xe=ee/2,He=k/2,tt=K/2,ft=le+1,ke=ge+1;let dt=0,et=0;const st=new z;for(let Mt=0;Mt<ke;Mt++){const Dt=Mt*xe-He;for(let Jt=0;Jt<ft;Jt++){const ce=Jt*Ae-Xe;st[x]=ce*R,st[S]=Dt*F,st[b]=tt,c.push(st.x,st.y,st.z),st[x]=0,st[S]=0,st[b]=K>0?1:-1,u.push(st.x,st.y,st.z),p.push(Jt/le),p.push(1-Mt/ge),dt+=1}}for(let Mt=0;Mt<ge;Mt++)for(let Dt=0;Dt<le;Dt++){const Jt=d+Dt+ft*Mt,ce=d+Dt+ft*(Mt+1),ve=d+(Dt+1)+ft*(Mt+1),ht=d+(Dt+1)+ft*Mt;s.push(Jt,ce,ht),s.push(ce,ve,ht),et+=6}a.addGroup(g,et,Le),g+=et,d+=dt}m("z","y","x",-1,-1,n,t,e,o,i,0),m("z","y","x",1,-1,n,t,-e,o,i,1),m("x","z","y",1,1,e,n,t,r,o,2),m("x","z","y",1,-1,e,n,-t,r,o,3),m("x","y","z",1,-1,e,t,n,r,i,4),m("x","y","z",-1,-1,e,t,-n,r,i,5),this.setIndex(s),this.setAttribute("position",new yt(c,3)),this.setAttribute("normal",new yt(u,3)),this.setAttribute("uv",new yt(p,2))}}function oo(e){const t={};for(const n in e){t[n]={};for(const r in e[n]){const i=e[n][r];i&&(i.isColor||i.isMatrix3||i.isMatrix4||i.isVector2||i.isVector3||i.isVector4||i.isTexture)?t[n][r]=i.clone():Array.isArray(i)?t[n][r]=i.slice():t[n][r]=i}}return t}function Fn(e){const t={};for(let n=0;n<e.length;n++){const r=oo(e[n]);for(const i in r)t[i]=r[i]}return t}const Qu={clone:oo,merge:Fn};function jn(e){Nt.call(this),this.type="ShaderMaterial",this.defines={},this.uniforms={},this.vertexShader=`void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,this.fragmentShader=`void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,e!==void 0&&(e.attributes!==void 0&&console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),this.setValues(e))}function Lr(){At.call(this),this.type="Camera",this.matrixWorldInverse=new Ht,this.projectionMatrix=new Ht,this.projectionMatrixInverse=new Ht}function _n(e=50,t=1,n=.1,r=2e3){Lr.call(this),this.type="PerspectiveCamera",this.fov=e,this.zoom=1,this.near=n,this.far=r,this.focus=10,this.aspect=t,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}jn.prototype=Object.create(Nt.prototype),jn.prototype.constructor=jn,jn.prototype.isShaderMaterial=!0,jn.prototype.copy=function(e){return Nt.prototype.copy.call(this,e),this.fragmentShader=e.fragmentShader,this.vertexShader=e.vertexShader,this.uniforms=oo(e.uniforms),this.defines=Object.assign({},e.defines),this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.lights=e.lights,this.clipping=e.clipping,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this.extensions=Object.assign({},e.extensions),this.glslVersion=e.glslVersion,this},jn.prototype.toJSON=function(e){const t=Nt.prototype.toJSON.call(this,e);t.glslVersion=this.glslVersion,t.uniforms={};for(const r in this.uniforms){const i=this.uniforms[r].value;i&&i.isTexture?t.uniforms[r]={type:"t",value:i.toJSON(e).uuid}:i&&i.isColor?t.uniforms[r]={type:"c",value:i.getHex()}:i&&i.isVector2?t.uniforms[r]={type:"v2",value:i.toArray()}:i&&i.isVector3?t.uniforms[r]={type:"v3",value:i.toArray()}:i&&i.isVector4?t.uniforms[r]={type:"v4",value:i.toArray()}:i&&i.isMatrix3?t.uniforms[r]={type:"m3",value:i.toArray()}:i&&i.isMatrix4?t.uniforms[r]={type:"m4",value:i.toArray()}:t.uniforms[r]={value:i}}Object.keys(this.defines).length>0&&(t.defines=this.defines),t.vertexShader=this.vertexShader,t.fragmentShader=this.fragmentShader;const n={};for(const r in this.extensions)this.extensions[r]===!0&&(n[r]=!0);return Object.keys(n).length>0&&(t.extensions=n),t},Lr.prototype=Object.assign(Object.create(At.prototype),{constructor:Lr,isCamera:!0,copy:function(e,t){return At.prototype.copy.call(this,e,t),this.matrixWorldInverse.copy(e.matrixWorldInverse),this.projectionMatrix.copy(e.projectionMatrix),this.projectionMatrixInverse.copy(e.projectionMatrixInverse),this},getWorldDirection:function(e){e===void 0&&(console.warn("THREE.Camera: .getWorldDirection() target is now required"),e=new z),this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return e.set(-t[8],-t[9],-t[10]).normalize()},updateMatrixWorld:function(e){At.prototype.updateMatrixWorld.call(this,e),this.matrixWorldInverse.copy(this.matrixWorld).invert()},updateWorldMatrix:function(e,t){At.prototype.updateWorldMatrix.call(this,e,t),this.matrixWorldInverse.copy(this.matrixWorld).invert()},clone:function(){return new this.constructor().copy(this)}}),_n.prototype=Object.assign(Object.create(Lr.prototype),{constructor:_n,isPerspectiveCamera:!0,copy:function(e,t){return Lr.prototype.copy.call(this,e,t),this.fov=e.fov,this.zoom=e.zoom,this.near=e.near,this.far=e.far,this.focus=e.focus,this.aspect=e.aspect,this.view=e.view===null?null:Object.assign({},e.view),this.filmGauge=e.filmGauge,this.filmOffset=e.filmOffset,this},setFocalLength:function(e){const t=.5*this.getFilmHeight()/e;this.fov=2*Ft.RAD2DEG*Math.atan(t),this.updateProjectionMatrix()},getFocalLength:function(){const e=Math.tan(.5*Ft.DEG2RAD*this.fov);return .5*this.getFilmHeight()/e},getEffectiveFOV:function(){return 2*Ft.RAD2DEG*Math.atan(Math.tan(.5*Ft.DEG2RAD*this.fov)/this.zoom)},getFilmWidth:function(){return this.filmGauge*Math.min(this.aspect,1)},getFilmHeight:function(){return this.filmGauge/Math.max(this.aspect,1)},setViewOffset:function(e,t,n,r,i,o){this.aspect=e/t,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=n,this.view.offsetY=r,this.view.width=i,this.view.height=o,this.updateProjectionMatrix()},clearViewOffset:function(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()},updateProjectionMatrix:function(){const e=this.near;let t=e*Math.tan(.5*Ft.DEG2RAD*this.fov)/this.zoom,n=2*t,r=this.aspect*n,i=-.5*r;const o=this.view;if(this.view!==null&&this.view.enabled){const s=o.fullWidth,c=o.fullHeight;i+=o.offsetX*r/s,t-=o.offsetY*n/c,r*=o.width/s,n*=o.height/c}const a=this.filmOffset;a!==0&&(i+=e*a/this.getFilmWidth()),this.projectionMatrix.makePerspective(i,i+r,t,t-n,e,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()},toJSON:function(e){const t=At.prototype.toJSON.call(this,e);return t.object.fov=this.fov,t.object.zoom=this.zoom,t.object.near=this.near,t.object.far=this.far,t.object.focus=this.focus,t.object.aspect=this.aspect,this.view!==null&&(t.object.view=Object.assign({},this.view)),t.object.filmGauge=this.filmGauge,t.object.filmOffset=this.filmOffset,t}});function Ai(e,t,n){if(At.call(this),this.type="CubeCamera",n.isWebGLCubeRenderTarget!==!0)return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");this.renderTarget=n;const r=new _n(90,1,e,t);r.layers=this.layers,r.up.set(0,-1,0),r.lookAt(new z(1,0,0)),this.add(r);const i=new _n(90,1,e,t);i.layers=this.layers,i.up.set(0,-1,0),i.lookAt(new z(-1,0,0)),this.add(i);const o=new _n(90,1,e,t);o.layers=this.layers,o.up.set(0,0,1),o.lookAt(new z(0,1,0)),this.add(o);const a=new _n(90,1,e,t);a.layers=this.layers,a.up.set(0,0,-1),a.lookAt(new z(0,-1,0)),this.add(a);const s=new _n(90,1,e,t);s.layers=this.layers,s.up.set(0,-1,0),s.lookAt(new z(0,0,1)),this.add(s);const c=new _n(90,1,e,t);c.layers=this.layers,c.up.set(0,-1,0),c.lookAt(new z(0,0,-1)),this.add(c),this.update=function(u,p){this.parent===null&&this.updateMatrixWorld();const d=u.xr.enabled,g=u.getRenderTarget();u.xr.enabled=!1;const m=n.texture.generateMipmaps;n.texture.generateMipmaps=!1,u.setRenderTarget(n,0),u.render(p,r),u.setRenderTarget(n,1),u.render(p,i),u.setRenderTarget(n,2),u.render(p,o),u.setRenderTarget(n,3),u.render(p,a),u.setRenderTarget(n,4),u.render(p,s),n.texture.generateMipmaps=m,u.setRenderTarget(n,5),u.render(p,c),u.setRenderTarget(g),u.xr.enabled=d}}function Cr(e,t,n,r,i,o,a,s,c,u){e=e!==void 0?e:[],t=t!==void 0?t:ye,a=a!==void 0?a:En,tn.call(this,e,t,n,r,i,o,a,s,c,u),this.flipY=!1,this._needsFlipEnvMap=!0}function Gr(e,t,n){Number.isInteger(t)&&(console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"),t=n),Kn.call(this,e,e,t),t=t||{},this.texture=new Cr(void 0,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.encoding),this.texture._needsFlipEnvMap=!1}function Vr(e,t,n,r,i,o,a,s,c,u,p,d){tn.call(this,null,o,a,s,c,u,r,i,p,d),this.image={data:e||null,width:t||1,height:n||1},this.magFilter=c!==void 0?c:y,this.minFilter=u!==void 0?u:y,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}Ai.prototype=Object.create(At.prototype),Ai.prototype.constructor=Ai,Cr.prototype=Object.create(tn.prototype),Cr.prototype.constructor=Cr,Cr.prototype.isCubeTexture=!0,Object.defineProperty(Cr.prototype,"images",{get:function(){return this.image},set:function(e){this.image=e}}),Gr.prototype=Object.create(Kn.prototype),Gr.prototype.constructor=Gr,Gr.prototype.isWebGLCubeRenderTarget=!0,Gr.prototype.fromEquirectangularTexture=function(e,t){this.texture.type=t.type,this.texture.format=In,this.texture.encoding=t.encoding,this.texture.generateMipmaps=t.generateMipmaps,this.texture.minFilter=t.minFilter,this.texture.magFilter=t.magFilter;const n={uniforms:{tEquirect:{value:null}},vertexShader:`

			varying vec3 vWorldDirection;

			vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

				return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

			}

			void main() {

				vWorldDirection = transformDirection( position, modelMatrix );

				#include <begin_vertex>
				#include <project_vertex>

			}
		`,fragmentShader:`

			uniform sampler2D tEquirect;

			varying vec3 vWorldDirection;

			#include <common>

			void main() {

				vec3 direction = normalize( vWorldDirection );

				vec2 sampleUV = equirectUv( direction );

				gl_FragColor = texture2D( tEquirect, sampleUV );

			}
		`},r=new qo(5,5,5),i=new jn({name:"CubemapFromEquirect",uniforms:oo(n.uniforms),vertexShader:n.vertexShader,fragmentShader:n.fragmentShader,side:Z,blending:X});i.uniforms.tEquirect.value=t;const o=new pn(r,i),a=t.minFilter;return t.minFilter===Be&&(t.minFilter=se),new Ai(1,10,this).update(e,o),t.minFilter=a,o.geometry.dispose(),o.material.dispose(),this},Gr.prototype.clear=function(e,t,n,r){const i=e.getRenderTarget();for(let o=0;o<6;o++)e.setRenderTarget(this,o),e.clear(t,n,r);e.setRenderTarget(i)},Vr.prototype=Object.create(tn.prototype),Vr.prototype.constructor=Vr,Vr.prototype.isDataTexture=!0;const ao=new Fr,Za=new z;class Yo{constructor(e,t,n,r,i,o){this.planes=[e!==void 0?e:new Er,t!==void 0?t:new Er,n!==void 0?n:new Er,r!==void 0?r:new Er,i!==void 0?i:new Er,o!==void 0?o:new Er]}set(e,t,n,r,i,o){const a=this.planes;return a[0].copy(e),a[1].copy(t),a[2].copy(n),a[3].copy(r),a[4].copy(i),a[5].copy(o),this}clone(){return new this.constructor().copy(this)}copy(e){const t=this.planes;for(let n=0;n<6;n++)t[n].copy(e.planes[n]);return this}setFromProjectionMatrix(e){const t=this.planes,n=e.elements,r=n[0],i=n[1],o=n[2],a=n[3],s=n[4],c=n[5],u=n[6],p=n[7],d=n[8],g=n[9],m=n[10],x=n[11],S=n[12],b=n[13],R=n[14],F=n[15];return t[0].setComponents(a-r,p-s,x-d,F-S).normalize(),t[1].setComponents(a+r,p+s,x+d,F+S).normalize(),t[2].setComponents(a+i,p+c,x+g,F+b).normalize(),t[3].setComponents(a-i,p-c,x-g,F-b).normalize(),t[4].setComponents(a-o,p-u,x-m,F-R).normalize(),t[5].setComponents(a+o,p+u,x+m,F+R).normalize(),this}intersectsObject(e){const t=e.geometry;return t.boundingSphere===null&&t.computeBoundingSphere(),ao.copy(t.boundingSphere).applyMatrix4(e.matrixWorld),this.intersectsSphere(ao)}intersectsSprite(e){return ao.center.set(0,0,0),ao.radius=.7071067811865476,ao.applyMatrix4(e.matrixWorld),this.intersectsSphere(ao)}intersectsSphere(e){const t=this.planes,n=e.center,r=-e.radius;for(let i=0;i<6;i++)if(t[i].distanceToPoint(n)<r)return!1;return!0}intersectsBox(e){const t=this.planes;for(let n=0;n<6;n++){const r=t[n];if(Za.x=r.normal.x>0?e.max.x:e.min.x,Za.y=r.normal.y>0?e.max.y:e.min.y,Za.z=r.normal.z>0?e.max.z:e.min.z,r.distanceToPoint(Za)<0)return!1}return!0}containsPoint(e){const t=this.planes;for(let n=0;n<6;n++)if(t[n].distanceToPoint(e)<0)return!1;return!0}}function $u(){let e=null,t=!1,n=null,r=null;function i(o,a){n(o,a),r=e.requestAnimationFrame(i)}return{start:function(){t!==!0&&n!==null&&(r=e.requestAnimationFrame(i),t=!0)},stop:function(){e.cancelAnimationFrame(r),t=!1},setAnimationLoop:function(o){n=o},setContext:function(o){e=o}}}function jp(e,t){const n=t.isWebGL2,r=new WeakMap;return{get:function(i){return i.isInterleavedBufferAttribute&&(i=i.data),r.get(i)},remove:function(i){i.isInterleavedBufferAttribute&&(i=i.data);const o=r.get(i);o&&(e.deleteBuffer(o.buffer),r.delete(i))},update:function(i,o){if(i.isGLBufferAttribute){const s=r.get(i);return void((!s||s.version<i.version)&&r.set(i,{buffer:i.buffer,type:i.type,bytesPerElement:i.elementSize,version:i.version}))}i.isInterleavedBufferAttribute&&(i=i.data);const a=r.get(i);a===void 0?r.set(i,function(s,c){const u=s.array,p=s.usage,d=e.createBuffer();e.bindBuffer(c,d),e.bufferData(c,u,p),s.onUploadCallback();let g=5126;return u instanceof Float32Array?g=5126:u instanceof Float64Array?console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."):u instanceof Uint16Array?s.isFloat16BufferAttribute?n?g=5131:console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."):g=5123:u instanceof Int16Array?g=5122:u instanceof Uint32Array?g=5125:u instanceof Int32Array?g=5124:u instanceof Int8Array?g=5120:u instanceof Uint8Array&&(g=5121),{buffer:d,type:g,bytesPerElement:u.BYTES_PER_ELEMENT,version:s.version}}(i,o)):a.version<i.version&&(!function(s,c,u){const p=c.array,d=c.updateRange;e.bindBuffer(u,s),d.count===-1?e.bufferSubData(u,0,p):(n?e.bufferSubData(u,d.offset*p.BYTES_PER_ELEMENT,p,d.offset,d.count):e.bufferSubData(u,d.offset*p.BYTES_PER_ELEMENT,p.subarray(d.offset,d.offset+d.count)),d.count=-1)}(a.buffer,i,o),a.version=i.version)}}}class Ja extends Ct{constructor(e=1,t=1,n=1,r=1){super(),this.type="PlaneBufferGeometry",this.parameters={width:e,height:t,widthSegments:n,heightSegments:r};const i=e/2,o=t/2,a=Math.floor(n),s=Math.floor(r),c=a+1,u=s+1,p=e/a,d=t/s,g=[],m=[],x=[],S=[];for(let b=0;b<u;b++){const R=b*d-o;for(let F=0;F<c;F++){const ee=F*p-i;m.push(ee,-R,0),x.push(0,0,1),S.push(F/a),S.push(1-b/s)}}for(let b=0;b<s;b++)for(let R=0;R<a;R++){const F=R+c*b,ee=R+c*(b+1),k=R+1+c*(b+1),K=R+1+c*b;g.push(F,ee,K),g.push(ee,k,K)}this.setIndex(g),this.setAttribute("position",new yt(m,3)),this.setAttribute("normal",new yt(x,3)),this.setAttribute("uv",new yt(S,2))}}const Vt={alphamap_fragment:`#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`,alphamap_pars_fragment:`#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,alphatest_fragment:`#ifdef ALPHATEST
	if ( diffuseColor.a < ALPHATEST ) discard;
#endif`,aomap_fragment:`#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );
	#endif
#endif`,aomap_pars_fragment:`#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,begin_vertex:"vec3 transformed = vec3( position );",beginnormal_vertex:`vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,bsdfs:`vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	return vec2( -1.04, 1.04 ) * a004 + r.zw;
}
float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
#if defined ( PHYSICALLY_CORRECT_LIGHTS )
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
#else
	if( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
		return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );
	}
	return 1.0;
#endif
}
vec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {
	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );
	return ( 1.0 - specularColor ) * fresnel + specularColor;
}
vec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {
	float fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );
	vec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;
	return Fr * fresnel + F0;
}
float G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	return 1.0 / ( gl * gv );
}
float G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( incidentLight.direction + viewDir );
	float dotNL = saturate( dot( normal, incidentLight.direction ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );
	vec3 F = F_Schlick( specularColor, dotLH );
	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( G * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
vec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );
	return specularColor * brdf.x + brdf.y;
}
void BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
	vec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );
	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );
	vec3 FssEss = F * brdf.x + brdf.y;
	float Ess = brdf.x + brdf.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );
	float dotNH = saturate( dot( geometry.normal, halfDir ) );
	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );
	vec3 F = F_Schlick( specularColor, dotLH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
float GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {
	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );
}
float BlinnExponentToGGXRoughness( const in float blinnExponent ) {
	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );
}
#if defined( USE_SHEEN )
float D_Charlie(float roughness, float NoH) {
	float invAlpha = 1.0 / roughness;
	float cos2h = NoH * NoH;
	float sin2h = max(1.0 - cos2h, 0.0078125);	return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);
}
float V_Neubelt(float NoV, float NoL) {
	return saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));
}
vec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {
	vec3 N = geometry.normal;
	vec3 V = geometry.viewDir;
	vec3 H = normalize( V + L );
	float dotNH = saturate( dot( N, H ) );
	return specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );
}
#endif`,bumpmap_pars_fragment:`#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {
		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );
		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 );
		fDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,clipping_planes_fragment:`#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,clipping_planes_pars_fragment:`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,clipping_planes_pars_vertex:`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,clipping_planes_vertex:`#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,color_fragment:`#ifdef USE_COLOR
	diffuseColor.rgb *= vColor;
#endif`,color_pars_fragment:`#ifdef USE_COLOR
	varying vec3 vColor;
#endif`,color_pars_vertex:`#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,color_vertex:`#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor.xyz *= color.xyz;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,common:`#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate(a) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement(a) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract(sin(sn) * c);
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
vec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
	float distance = dot( planeNormal, point - pointOnPlane );
	return - distance * planeNormal + point;
}
float sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
	return sign( dot( point - pointOnPlane, planeNormal ) );
}
vec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {
	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float linearToRelativeLuminance( const in vec3 color ) {
	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );
	return dot( weights, color.rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`,cube_uv_reflection_fragment:`#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_maxMipLevel 8.0
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_maxTileSize 256.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		float texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );
		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );
		vec2 f = fract( uv );
		uv += 0.5 - f;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		if ( mipInt < cubeUV_maxMipLevel ) {
			uv.y += 2.0 * cubeUV_maxTileSize;
		}
		uv.y += filterInt * 2.0 * cubeUV_minTileSize;
		uv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );
		uv *= texelSize;
		vec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.x += texelSize;
		vec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.y += texelSize;
		vec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.x -= texelSize;
		vec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		vec3 tm = mix( tl, tr, f.x );
		vec3 bm = mix( bl, br, f.x );
		return mix( tm, bm, f.y );
	}
	#define r0 1.0
	#define v0 0.339
	#define m0 - 2.0
	#define r1 0.8
	#define v1 0.276
	#define m1 - 1.0
	#define r4 0.4
	#define v4 0.046
	#define m4 2.0
	#define r5 0.305
	#define v5 0.016
	#define m5 3.0
	#define r6 0.21
	#define v6 0.0038
	#define m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= r1 ) {
			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;
		} else if ( roughness >= r4 ) {
			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;
		} else if ( roughness >= r5 ) {
			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;
		} else if ( roughness >= r6 ) {
			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,defaultnormal_vertex:`vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,displacementmap_pars_vertex:`#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,displacementmap_vertex:`#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`,emissivemap_fragment:`#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,emissivemap_pars_fragment:`#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,encodings_fragment:"gl_FragColor = linearToOutputTexel( gl_FragColor );",encodings_pars_fragment:`
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 GammaToLinear( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );
}
vec4 LinearToGamma( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );
}
vec4 sRGBToLinear( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 RGBEToLinear( in vec4 value ) {
	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );
}
vec4 LinearToRGBE( in vec4 value ) {
	float maxComponent = max( max( value.r, value.g ), value.b );
	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );
	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );
}
vec4 RGBMToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * value.a * maxRange, 1.0 );
}
vec4 LinearToRGBM( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );
	M = ceil( M * 255.0 ) / 255.0;
	return vec4( value.rgb / ( M * maxRange ), M );
}
vec4 RGBDToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );
}
vec4 LinearToRGBD( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float D = max( maxRange / maxRGB, 1.0 );
	D = clamp( floor( D ) / 255.0, 0.0, 1.0 );
	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );
}
const mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );
vec4 LinearToLogLuv( in vec4 value ) {
	vec3 Xp_Y_XYZp = cLogLuvM * value.rgb;
	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );
	vec4 vResult;
	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;
	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;
	vResult.w = fract( Le );
	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;
	return vResult;
}
const mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );
vec4 LogLuvToLinear( in vec4 value ) {
	float Le = value.z * 255.0 + value.w;
	vec3 Xp_Y_XYZp;
	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );
	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;
	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;
	vec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;
	return vec4( max( vRGB, 0.0 ), 1.0 );
}`,envmap_fragment:`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifndef ENVMAP_TYPE_CUBE_UV
		envColor = envMapTexelToLinear( envColor );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,envmap_common_pars_fragment:`#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform int maxMipLevel;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,envmap_pars_fragment:`#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,envmap_pars_vertex:`#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,envmap_physical_pars_fragment:`#if defined( USE_ENVMAP )
	#ifdef ENVMAP_MODE_REFRACTION
		uniform float refractionRatio;
	#endif
	vec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {
		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );
		#ifdef ENVMAP_TYPE_CUBE
			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );
			#ifdef TEXTURE_LOD_EXT
				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );
			#else
				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );
			#endif
			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
		#elif defined( ENVMAP_TYPE_CUBE_UV )
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
		#else
			vec4 envMapColor = vec4( 0.0 );
		#endif
		return PI * envMapColor.rgb * envMapIntensity;
	}
	float getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {
		float maxMIPLevelScalar = float( maxMIPLevel );
		float sigma = PI * roughness * roughness / ( 1.0 + roughness );
		float desiredMIPLevel = maxMIPLevelScalar + log2( sigma );
		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );
	}
	vec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( -viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
		#else
			vec3 reflectVec = refract( -viewDir, normal, refractionRatio );
		#endif
		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
		float specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );
		#ifdef ENVMAP_TYPE_CUBE
			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );
			#ifdef TEXTURE_LOD_EXT
				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );
			#else
				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );
			#endif
			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
		#elif defined( ENVMAP_TYPE_CUBE_UV )
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
		#endif
		return envMapColor.rgb * envMapIntensity;
	}
#endif`,envmap_vertex:`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,fog_vertex:`#ifdef USE_FOG
	fogDepth = - mvPosition.z;
#endif`,fog_pars_vertex:`#ifdef USE_FOG
	varying float fogDepth;
#endif`,fog_fragment:`#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, fogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,fog_pars_fragment:`#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float fogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,gradientmap_pars_fragment:`#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return texture2D( gradientMap, coord ).rgb;
	#else
		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );
	#endif
}`,lightmap_fragment:`#ifdef USE_LIGHTMAP
	vec4 lightMapTexel= texture2D( lightMap, vUv2 );
	reflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
#endif`,lightmap_pars_fragment:`#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,lights_lambert_vertex:`vec3 diffuse = vec3( 1.0 );
GeometricContext geometry;
geometry.position = mvPosition.xyz;
geometry.normal = normalize( transformedNormal );
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );
GeometricContext backGeometry;
backGeometry.position = geometry.position;
backGeometry.normal = -geometry.normal;
backGeometry.viewDir = geometry.viewDir;
vLightFront = vec3( 0.0 );
vIndirectFront = vec3( 0.0 );
#ifdef DOUBLE_SIDED
	vLightBack = vec3( 0.0 );
	vIndirectBack = vec3( 0.0 );
#endif
IncidentLight directLight;
float dotNL;
vec3 directLightColor_Diffuse;
vIndirectFront += getAmbientLightIrradiance( ambientLightColor );
vIndirectFront += getLightProbeIrradiance( lightProbe, geometry );
#ifdef DOUBLE_SIDED
	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );
	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );
#endif
#if NUM_POINT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_SPOT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_DIR_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_HEMI_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );
		#ifdef DOUBLE_SIDED
			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );
		#endif
	}
	#pragma unroll_loop_end
#endif`,lights_pars_begin:`uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {
	vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	return irradiance;
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {
		directLight.color = directionalLight.color;
		directLight.direction = directionalLight.direction;
		directLight.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {
		vec3 lVector = pointLight.position - geometry.position;
		directLight.direction = normalize( lVector );
		float lightDistance = length( lVector );
		directLight.color = pointLight.color;
		directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );
		directLight.visible = ( directLight.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {
		vec3 lVector = spotLight.position - geometry.position;
		directLight.direction = normalize( lVector );
		float lightDistance = length( lVector );
		float angleCos = dot( directLight.direction, spotLight.direction );
		if ( angleCos > spotLight.coneCos ) {
			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );
			directLight.color = spotLight.color;
			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );
			directLight.visible = true;
		} else {
			directLight.color = vec3( 0.0 );
			directLight.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {
		float dotNL = dot( geometry.normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			irradiance *= PI;
		#endif
		return irradiance;
	}
#endif`,lights_toon_fragment:`ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,lights_toon_pars_fragment:`varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
#define Material_LightProbeLOD( material )	(0)`,lights_phong_fragment:`BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,lights_phong_pars_fragment:`varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong
#define Material_LightProbeLOD( material )	(0)`,lights_physical_fragment:`PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;
material.specularRoughness = min( material.specularRoughness, 1.0 );
#ifdef REFLECTIVITY
	material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );
#endif
#ifdef CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheen;
#endif`,lights_physical_pars_fragment:`struct PhysicalMaterial {
	vec3 diffuseColor;
	float specularRoughness;
	vec3 specularColor;
#ifdef CLEARCOAT
	float clearcoat;
	float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	vec3 sheenColor;
#endif
};
#define MAXIMUM_SPECULAR_COEFFICIENT 0.16
#define DEFAULT_SPECULAR_COEFFICIENT 0.04
float clearcoatDHRApprox( const in float roughness, const in float dotNL ) {
	return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.specularRoughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	#ifdef CLEARCOAT
		float ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = ccDotNL * directLight.color;
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			ccIrradiance *= PI;
		#endif
		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );
		reflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );
	#else
		float clearcoatDHR = 0.0;
	#endif
	#ifdef USE_SHEEN
		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(
			material.specularRoughness,
			directLight.direction,
			geometry,
			material.sheenColor
		);
	#else
		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);
	#endif
	reflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef CLEARCOAT
		float ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		reflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );
		float ccDotNL = ccDotNV;
		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );
	#else
		float clearcoatDHR = 0.0;
	#endif
	float clearcoatInv = 1.0 - clearcoatDHR;
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	BRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );
	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );
	reflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,lights_fragment_begin:`
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointDirectLightIrradiance( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotDirectLightIrradiance( spotLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,lights_fragment_maps:`#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			lightMapIrradiance *= PI;
		#endif
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );
	#ifdef CLEARCOAT
		clearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );
	#endif
#endif`,lights_fragment_end:`#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,logdepthbuf_fragment:`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,logdepthbuf_pars_fragment:`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,logdepthbuf_pars_vertex:`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,logdepthbuf_vertex:`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,map_fragment:`#ifdef USE_MAP
	vec4 texelColor = texture2D( map, vUv );
	texelColor = mapTexelToLinear( texelColor );
	diffuseColor *= texelColor;
#endif`,map_pars_fragment:`#ifdef USE_MAP
	uniform sampler2D map;
#endif`,map_particle_fragment:`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	vec4 mapTexel = texture2D( map, uv );
	diffuseColor *= mapTexelToLinear( mapTexel );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,map_particle_pars_fragment:`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,metalnessmap_fragment:`float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`,metalnessmap_pars_fragment:`#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,morphnormal_vertex:`#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
	objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
	objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
	objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
#endif`,morphtarget_pars_vertex:`#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifndef USE_MORPHNORMALS
		uniform float morphTargetInfluences[ 8 ];
	#else
		uniform float morphTargetInfluences[ 4 ];
	#endif
#endif`,morphtarget_vertex:`#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	transformed += morphTarget0 * morphTargetInfluences[ 0 ];
	transformed += morphTarget1 * morphTargetInfluences[ 1 ];
	transformed += morphTarget2 * morphTargetInfluences[ 2 ];
	transformed += morphTarget3 * morphTargetInfluences[ 3 ];
	#ifndef USE_MORPHNORMALS
		transformed += morphTarget4 * morphTargetInfluences[ 4 ];
		transformed += morphTarget5 * morphTargetInfluences[ 5 ];
		transformed += morphTarget6 * morphTargetInfluences[ 6 ];
		transformed += morphTarget7 * morphTargetInfluences[ 7 ];
	#endif
#endif`,normal_fragment_begin:`#ifdef FLAT_SHADED
	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );
			bitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`,normal_fragment_maps:`#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( -vViewPosition, normal, mapN );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );
#endif`,normalmap_pars_fragment:`#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {
		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		float scale = sign( st1.t * st0.s - st0.t * st1.s );
		vec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );
		vec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );
		vec3 N = normalize( surf_norm );
		mat3 tsn = mat3( S, T, N );
		mapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );
		return normalize( tsn * mapN );
	}
#endif`,clearcoat_normal_fragment_begin:`#ifdef CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`,clearcoat_normal_fragment_maps:`#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );
	#endif
#endif`,clearcoat_pars_fragment:`#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`,packing:`vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return (( near + viewZ ) * far ) / (( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`,premultiplied_alpha_fragment:`#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,project_vertex:`vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,dithering_fragment:`#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,dithering_pars_fragment:`#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,roughnessmap_fragment:`float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`,roughnessmap_pars_fragment:`#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,shadowmap_pars_fragment:`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );
		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
		bool frustumTest = all( frustumTestVec );
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,shadowmap_pars_vertex:`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,shadowmap_vertex:`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;
	#endif
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
#endif`,shadowmask_pars_fragment:`float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,skinbase_vertex:`#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,skinning_pars_vertex:`#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	#ifdef BONE_TEXTURE
		uniform highp sampler2D boneTexture;
		uniform int boneTextureSize;
		mat4 getBoneMatrix( const in float i ) {
			float j = i * 4.0;
			float x = mod( j, float( boneTextureSize ) );
			float y = floor( j / float( boneTextureSize ) );
			float dx = 1.0 / float( boneTextureSize );
			float dy = 1.0 / float( boneTextureSize );
			y = dy * ( y + 0.5 );
			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
			mat4 bone = mat4( v1, v2, v3, v4 );
			return bone;
		}
	#else
		uniform mat4 boneMatrices[ MAX_BONES ];
		mat4 getBoneMatrix( const in float i ) {
			mat4 bone = boneMatrices[ int(i) ];
			return bone;
		}
	#endif
#endif`,skinning_vertex:`#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,skinnormal_vertex:`#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,specularmap_fragment:`float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,specularmap_pars_fragment:`#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,tonemapping_fragment:`#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,tonemapping_pars_fragment:`#ifndef saturate
#define saturate(a) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,transmissionmap_fragment:`#ifdef USE_TRANSMISSIONMAP
	totalTransmission *= texture2D( transmissionMap, vUv ).r;
#endif`,transmissionmap_pars_fragment:`#ifdef USE_TRANSMISSIONMAP
	uniform sampler2D transmissionMap;
#endif`,uv_pars_fragment:`#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`,uv_pars_vertex:`#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`,uv_vertex:`#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`,uv2_pars_fragment:`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`,uv2_pars_vertex:`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`,uv2_vertex:`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`,worldpos_vertex:`#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`,background_frag:`uniform sampler2D t2D;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,background_vert:`varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,cube_frag:`#include <envmap_common_pars_fragment>
uniform float opacity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	vec3 vReflect = vWorldDirection;
	#include <envmap_fragment>
	gl_FragColor = envColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,cube_vert:`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,depth_frag:`#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,depth_vert:`#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,distanceRGBA_frag:`#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,distanceRGBA_vert:`#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,equirect_frag:`uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	vec4 texColor = texture2D( tEquirect, sampleUV );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,equirect_vert:`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,linedashed_frag:`uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,linedashed_vert:`uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,meshbasic_frag:`uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
	
		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,meshbasic_vert:`#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <skinbase_vertex>
	#ifdef USE_ENVMAP
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,meshlambert_frag:`uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <emissivemap_fragment>
	#ifdef DOUBLE_SIDED
		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;
	#else
		reflectedLight.indirectDiffuse += vIndirectFront;
	#endif
	#include <lightmap_fragment>
	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );
	#ifdef DOUBLE_SIDED
		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;
	#else
		reflectedLight.directDiffuse = vLightFront;
	#endif
	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,meshlambert_vert:`#define LAMBERT
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars_begin>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <lights_lambert_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,meshmatcap_frag:`#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <fog_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
		matcapColor = matcapTexelToLinear( matcapColor );
	#else
		vec4 matcapColor = vec4( 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,meshmatcap_vert:`#define MATCAP
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#ifndef FLAT_SHADED
		vNormal = normalize( transformedNormal );
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,meshtoon_frag:`#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,meshtoon_vert:`#define TOON
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,meshphong_frag:`#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,meshphong_vert:`#define PHONG
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,meshphysical_frag:`#define STANDARD
#ifdef PHYSICAL
	#define REFLECTIVITY
	#define CLEARCOAT
	#define TRANSMISSION
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef TRANSMISSION
	uniform float transmission;
#endif
#ifdef REFLECTIVITY
	uniform float reflectivity;
#endif
#ifdef CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheen;
#endif
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <transmissionmap_pars_fragment>
#include <bsdfs>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <lights_physical_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#ifdef TRANSMISSION
		float totalTransmission = transmission;
	#endif
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <transmissionmap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#ifdef TRANSMISSION
		diffuseColor.a *= mix( saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) ), 1.0, metalness );
	#endif
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,meshphysical_vert:`#define STANDARD
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,normal_frag:`#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <packing>
#include <uv_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
}`,normal_vert:`#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`,points_frag:`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,points_vert:`uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,shadow_frag:`uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,shadow_vert:`#include <common>
#include <fog_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <begin_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,sprite_frag:`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,sprite_vert:`uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`},mt={common:{diffuse:{value:new _t(15658734)},opacity:{value:1},map:{value:null},uvTransform:{value:new Vn},uv2Transform:{value:new Vn},alphaMap:{value:null}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},refractionRatio:{value:.98},maxMipLevel:{value:0}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new Je(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new _t(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new _t(15658734)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},uvTransform:{value:new Vn}},sprite:{diffuse:{value:new _t(15658734)},opacity:{value:1},center:{value:new Je(.5,.5)},rotation:{value:0},map:{value:null},alphaMap:{value:null},uvTransform:{value:new Vn}}},gr={basic:{uniforms:Fn([mt.common,mt.specularmap,mt.envmap,mt.aomap,mt.lightmap,mt.fog]),vertexShader:Vt.meshbasic_vert,fragmentShader:Vt.meshbasic_frag},lambert:{uniforms:Fn([mt.common,mt.specularmap,mt.envmap,mt.aomap,mt.lightmap,mt.emissivemap,mt.fog,mt.lights,{emissive:{value:new _t(0)}}]),vertexShader:Vt.meshlambert_vert,fragmentShader:Vt.meshlambert_frag},phong:{uniforms:Fn([mt.common,mt.specularmap,mt.envmap,mt.aomap,mt.lightmap,mt.emissivemap,mt.bumpmap,mt.normalmap,mt.displacementmap,mt.fog,mt.lights,{emissive:{value:new _t(0)},specular:{value:new _t(1118481)},shininess:{value:30}}]),vertexShader:Vt.meshphong_vert,fragmentShader:Vt.meshphong_frag},standard:{uniforms:Fn([mt.common,mt.envmap,mt.aomap,mt.lightmap,mt.emissivemap,mt.bumpmap,mt.normalmap,mt.displacementmap,mt.roughnessmap,mt.metalnessmap,mt.fog,mt.lights,{emissive:{value:new _t(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:Vt.meshphysical_vert,fragmentShader:Vt.meshphysical_frag},toon:{uniforms:Fn([mt.common,mt.aomap,mt.lightmap,mt.emissivemap,mt.bumpmap,mt.normalmap,mt.displacementmap,mt.gradientmap,mt.fog,mt.lights,{emissive:{value:new _t(0)}}]),vertexShader:Vt.meshtoon_vert,fragmentShader:Vt.meshtoon_frag},matcap:{uniforms:Fn([mt.common,mt.bumpmap,mt.normalmap,mt.displacementmap,mt.fog,{matcap:{value:null}}]),vertexShader:Vt.meshmatcap_vert,fragmentShader:Vt.meshmatcap_frag},points:{uniforms:Fn([mt.points,mt.fog]),vertexShader:Vt.points_vert,fragmentShader:Vt.points_frag},dashed:{uniforms:Fn([mt.common,mt.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:Vt.linedashed_vert,fragmentShader:Vt.linedashed_frag},depth:{uniforms:Fn([mt.common,mt.displacementmap]),vertexShader:Vt.depth_vert,fragmentShader:Vt.depth_frag},normal:{uniforms:Fn([mt.common,mt.bumpmap,mt.normalmap,mt.displacementmap,{opacity:{value:1}}]),vertexShader:Vt.normal_vert,fragmentShader:Vt.normal_frag},sprite:{uniforms:Fn([mt.sprite,mt.fog]),vertexShader:Vt.sprite_vert,fragmentShader:Vt.sprite_frag},background:{uniforms:{uvTransform:{value:new Vn},t2D:{value:null}},vertexShader:Vt.background_vert,fragmentShader:Vt.background_frag},cube:{uniforms:Fn([mt.envmap,{opacity:{value:1}}]),vertexShader:Vt.cube_vert,fragmentShader:Vt.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:Vt.equirect_vert,fragmentShader:Vt.equirect_frag},distanceRGBA:{uniforms:Fn([mt.common,mt.displacementmap,{referencePosition:{value:new z},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:Vt.distanceRGBA_vert,fragmentShader:Vt.distanceRGBA_frag},shadow:{uniforms:Fn([mt.lights,mt.fog,{color:{value:new _t(0)},opacity:{value:1}}]),vertexShader:Vt.shadow_vert,fragmentShader:Vt.shadow_frag}};function Wp(e,t,n,r,i){const o=new _t(0);let a,s,c=0,u=null,p=0,d=null;function g(m,x){n.buffers.color.setClear(m.r,m.g,m.b,x,i)}return{getClearColor:function(){return o},setClearColor:function(m,x=1){o.set(m),c=x,g(o,c)},getClearAlpha:function(){return c},setClearAlpha:function(m){c=m,g(o,c)},render:function(m,x,S,b){let R=x.isScene===!0?x.background:null;R&&R.isTexture&&(R=t.get(R));const F=e.xr,ee=F.getSession&&F.getSession();ee&&ee.environmentBlendMode==="additive"&&(R=null),R===null?g(o,c):R&&R.isColor&&(g(R,1),b=!0),(e.autoClear||b)&&e.clear(e.autoClearColor,e.autoClearDepth,e.autoClearStencil),R&&(R.isCubeTexture||R.isWebGLCubeRenderTarget||R.mapping===pe)?(s===void 0&&(s=new pn(new qo(1,1,1),new jn({name:"BackgroundCubeMaterial",uniforms:oo(gr.cube.uniforms),vertexShader:gr.cube.vertexShader,fragmentShader:gr.cube.fragmentShader,side:Z,depthTest:!1,depthWrite:!1,fog:!1})),s.geometry.deleteAttribute("normal"),s.geometry.deleteAttribute("uv"),s.onBeforeRender=function(k,K,le){this.matrixWorld.copyPosition(le.matrixWorld)},Object.defineProperty(s.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),r.update(s)),R.isWebGLCubeRenderTarget&&(R=R.texture),s.material.uniforms.envMap.value=R,s.material.uniforms.flipEnvMap.value=R.isCubeTexture&&R._needsFlipEnvMap?-1:1,u===R&&p===R.version&&d===e.toneMapping||(s.material.needsUpdate=!0,u=R,p=R.version,d=e.toneMapping),m.unshift(s,s.geometry,s.material,0,0,null)):R&&R.isTexture&&(a===void 0&&(a=new pn(new Ja(2,2),new jn({name:"BackgroundMaterial",uniforms:oo(gr.background.uniforms),vertexShader:gr.background.vertexShader,fragmentShader:gr.background.fragmentShader,side:T,depthTest:!1,depthWrite:!1,fog:!1})),a.geometry.deleteAttribute("normal"),Object.defineProperty(a.material,"map",{get:function(){return this.uniforms.t2D.value}}),r.update(a)),a.material.uniforms.t2D.value=R,R.matrixAutoUpdate===!0&&R.updateMatrix(),a.material.uniforms.uvTransform.value.copy(R.matrix),u===R&&p===R.version&&d===e.toneMapping||(a.material.needsUpdate=!0,u=R,p=R.version,d=e.toneMapping),m.unshift(a,a.geometry,a.material,0,0,null))}}}function Xp(e,t,n,r){const i=e.getParameter(34921),o=r.isWebGL2?null:t.get("OES_vertex_array_object"),a=r.isWebGL2||o!==null,s={},c=g(null);let u=c;function p(k){return r.isWebGL2?e.bindVertexArray(k):o.bindVertexArrayOES(k)}function d(k){return r.isWebGL2?e.deleteVertexArray(k):o.deleteVertexArrayOES(k)}function g(k){const K=[],le=[],ge=[];for(let Le=0;Le<i;Le++)K[Le]=0,le[Le]=0,ge[Le]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:K,enabledAttributes:le,attributeDivisors:ge,object:k,attributes:{},index:null}}function m(){const k=u.newAttributes;for(let K=0,le=k.length;K<le;K++)k[K]=0}function x(k){S(k,0)}function S(k,K){const le=u.newAttributes,ge=u.enabledAttributes,Le=u.attributeDivisors;(le[k]=1,ge[k]===0&&(e.enableVertexAttribArray(k),ge[k]=1),Le[k]!==K)&&((r.isWebGL2?e:t.get("ANGLE_instanced_arrays"))[r.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](k,K),Le[k]=K)}function b(){const k=u.newAttributes,K=u.enabledAttributes;for(let le=0,ge=K.length;le<ge;le++)K[le]!==k[le]&&(e.disableVertexAttribArray(le),K[le]=0)}function R(k,K,le,ge,Le,Ae){r.isWebGL2!==!0||le!==5124&&le!==5125?e.vertexAttribPointer(k,K,le,ge,Le,Ae):e.vertexAttribIPointer(k,K,le,Le,Ae)}function F(){ee(),u!==c&&(u=c,p(u.object))}function ee(){c.geometry=null,c.program=null,c.wireframe=!1}return{setup:function(k,K,le,ge,Le){let Ae=!1;if(a){const xe=function(Xe,He,tt){const ft=tt.wireframe===!0;let ke=s[Xe.id];ke===void 0&&(ke={},s[Xe.id]=ke);let dt=ke[He.id];dt===void 0&&(dt={},ke[He.id]=dt);let et=dt[ft];return et===void 0&&(et=g(r.isWebGL2?e.createVertexArray():o.createVertexArrayOES()),dt[ft]=et),et}(ge,le,K);u!==xe&&(u=xe,p(u.object)),Ae=function(Xe,He){const tt=u.attributes,ft=Xe.attributes;let ke=0;for(const dt in ft){const et=tt[dt],st=ft[dt];if(et===void 0)return!0;if(et.attribute!==st)return!0;if(et.data!==st.data)return!0;ke++}return u.attributesNum!==ke||u.index!==He}(ge,Le),Ae&&function(Xe,He){const tt={},ft=Xe.attributes;let ke=0;for(const dt in ft){const et=ft[dt],st={};st.attribute=et,et.data&&(st.data=et.data),tt[dt]=st,ke++}u.attributes=tt,u.attributesNum=ke,u.index=He}(ge,Le)}else{const xe=K.wireframe===!0;u.geometry===ge.id&&u.program===le.id&&u.wireframe===xe||(u.geometry=ge.id,u.program=le.id,u.wireframe=xe,Ae=!0)}k.isInstancedMesh===!0&&(Ae=!0),Le!==null&&n.update(Le,34963),Ae&&(!function(xe,Xe,He,tt){if(r.isWebGL2===!1&&(xe.isInstancedMesh||tt.isInstancedBufferGeometry)&&t.get("ANGLE_instanced_arrays")===null)return;m();const ft=tt.attributes,ke=He.getAttributes(),dt=Xe.defaultAttributeValues;for(const et in ke){const st=ke[et];if(st>=0){const Mt=ft[et];if(Mt!==void 0){const Dt=Mt.normalized,Jt=Mt.itemSize,ce=n.get(Mt);if(ce===void 0)continue;const ve=ce.buffer,ht=ce.type,Ve=ce.bytesPerElement;if(Mt.isInterleavedBufferAttribute){const ne=Mt.data,je=ne.stride,De=Mt.offset;ne&&ne.isInstancedInterleavedBuffer?(S(st,ne.meshPerAttribute),tt._maxInstanceCount===void 0&&(tt._maxInstanceCount=ne.meshPerAttribute*ne.count)):x(st),e.bindBuffer(34962,ve),R(st,Jt,ht,Dt,je*Ve,De*Ve)}else Mt.isInstancedBufferAttribute?(S(st,Mt.meshPerAttribute),tt._maxInstanceCount===void 0&&(tt._maxInstanceCount=Mt.meshPerAttribute*Mt.count)):x(st),e.bindBuffer(34962,ve),R(st,Jt,ht,Dt,0,0)}else if(et==="instanceMatrix"){const Dt=n.get(xe.instanceMatrix);if(Dt===void 0)continue;const Jt=Dt.buffer,ce=Dt.type;S(st+0,1),S(st+1,1),S(st+2,1),S(st+3,1),e.bindBuffer(34962,Jt),e.vertexAttribPointer(st+0,4,ce,!1,64,0),e.vertexAttribPointer(st+1,4,ce,!1,64,16),e.vertexAttribPointer(st+2,4,ce,!1,64,32),e.vertexAttribPointer(st+3,4,ce,!1,64,48)}else if(et==="instanceColor"){const Dt=n.get(xe.instanceColor);if(Dt===void 0)continue;const Jt=Dt.buffer,ce=Dt.type;S(st,1),e.bindBuffer(34962,Jt),e.vertexAttribPointer(st,3,ce,!1,12,0)}else if(dt!==void 0){const Dt=dt[et];if(Dt!==void 0)switch(Dt.length){case 2:e.vertexAttrib2fv(st,Dt);break;case 3:e.vertexAttrib3fv(st,Dt);break;case 4:e.vertexAttrib4fv(st,Dt);break;default:e.vertexAttrib1fv(st,Dt)}}}}b()}(k,K,le,ge),Le!==null&&e.bindBuffer(34963,n.get(Le).buffer))},reset:F,resetDefaultState:ee,dispose:function(){F();for(const k in s){const K=s[k];for(const le in K){const ge=K[le];for(const Le in ge)d(ge[Le].object),delete ge[Le];delete K[le]}delete s[k]}},releaseStatesOfGeometry:function(k){if(s[k.id]===void 0)return;const K=s[k.id];for(const le in K){const ge=K[le];for(const Le in ge)d(ge[Le].object),delete ge[Le];delete K[le]}delete s[k.id]},releaseStatesOfProgram:function(k){for(const K in s){const le=s[K];if(le[k.id]===void 0)continue;const ge=le[k.id];for(const Le in ge)d(ge[Le].object),delete ge[Le];delete le[k.id]}},initAttributes:m,enableAttribute:x,disableUnusedAttributes:b}}function qp(e,t,n,r){const i=r.isWebGL2;let o;this.setMode=function(a){o=a},this.render=function(a,s){e.drawArrays(o,a,s),n.update(s,o,1)},this.renderInstances=function(a,s,c){if(c===0)return;let u,p;if(i)u=e,p="drawArraysInstanced";else if(u=t.get("ANGLE_instanced_arrays"),p="drawArraysInstancedANGLE",u===null)return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");u[p](o,a,s,c),n.update(s,o,c)}}function Yp(e,t,n){let r;function i(ee){if(ee==="highp"){if(e.getShaderPrecisionFormat(35633,36338).precision>0&&e.getShaderPrecisionFormat(35632,36338).precision>0)return"highp";ee="mediump"}return ee==="mediump"&&e.getShaderPrecisionFormat(35633,36337).precision>0&&e.getShaderPrecisionFormat(35632,36337).precision>0?"mediump":"lowp"}const o=typeof WebGL2RenderingContext!="undefined"&&e instanceof WebGL2RenderingContext||typeof WebGL2ComputeRenderingContext!="undefined"&&e instanceof WebGL2ComputeRenderingContext;let a=n.precision!==void 0?n.precision:"highp";const s=i(a);s!==a&&(console.warn("THREE.WebGLRenderer:",a,"not supported, using",s,"instead."),a=s);const c=n.logarithmicDepthBuffer===!0,u=e.getParameter(34930),p=e.getParameter(35660),d=e.getParameter(3379),g=e.getParameter(34076),m=e.getParameter(34921),x=e.getParameter(36347),S=e.getParameter(36348),b=e.getParameter(36349),R=p>0,F=o||!!t.get("OES_texture_float");return{isWebGL2:o,getMaxAnisotropy:function(){if(r!==void 0)return r;const ee=t.get("EXT_texture_filter_anisotropic");return r=ee!==null?e.getParameter(ee.MAX_TEXTURE_MAX_ANISOTROPY_EXT):0,r},getMaxPrecision:i,precision:a,logarithmicDepthBuffer:c,maxTextures:u,maxVertexTextures:p,maxTextureSize:d,maxCubemapSize:g,maxAttributes:m,maxVertexUniforms:x,maxVaryings:S,maxFragmentUniforms:b,vertexTextures:R,floatFragmentTextures:F,floatVertexTextures:R&&F,maxSamples:o?e.getParameter(36183):0}}function Zp(e){const t=this;let n=null,r=0,i=!1,o=!1;const a=new Er,s=new Vn,c={value:null,needsUpdate:!1};function u(){c.value!==n&&(c.value=n,c.needsUpdate=r>0),t.numPlanes=r,t.numIntersection=0}function p(d,g,m,x){const S=d!==null?d.length:0;let b=null;if(S!==0){if(b=c.value,x!==!0||b===null){const R=m+4*S,F=g.matrixWorldInverse;s.getNormalMatrix(F),(b===null||b.length<R)&&(b=new Float32Array(R));for(let ee=0,k=m;ee!==S;++ee,k+=4)a.copy(d[ee]).applyMatrix4(F,s),a.normal.toArray(b,k),b[k+3]=a.constant}c.value=b,c.needsUpdate=!0}return t.numPlanes=S,t.numIntersection=0,b}this.uniform=c,this.numPlanes=0,this.numIntersection=0,this.init=function(d,g,m){const x=d.length!==0||g||r!==0||i;return i=g,n=p(d,m,0),r=d.length,x},this.beginShadows=function(){o=!0,p(null)},this.endShadows=function(){o=!1,u()},this.setState=function(d,g,m){const x=d.clippingPlanes,S=d.clipIntersection,b=d.clipShadows,R=e.get(d);if(!i||x===null||x.length===0||o&&!b)o?p(null):u();else{const F=o?0:r,ee=4*F;let k=R.clippingState||null;c.value=k,k=p(x,g,ee,m);for(let K=0;K!==ee;++K)k[K]=n[K];R.clippingState=k,this.numIntersection=S?this.numPlanes:0,this.numPlanes+=F}}}function Jp(e){let t=new WeakMap;function n(i,o){return o===W?i.mapping=ye:o===ae&&(i.mapping=_e),i}function r(i){const o=i.target;o.removeEventListener("dispose",r);const a=t.get(o);a!==void 0&&(t.delete(o),a.dispose())}return{get:function(i){if(i&&i.isTexture){const o=i.mapping;if(o===W||o===ae){if(t.has(i))return n(t.get(i).texture,i.mapping);{const a=i.image;if(a&&a.height>0){const s=e.getRenderList(),c=e.getRenderTarget(),u=e.getRenderState(),p=new Gr(a.height/2);return p.fromEquirectangularTexture(e,i),t.set(i,p),e.setRenderTarget(c),e.setRenderList(s),e.setRenderState(u),i.addEventListener("dispose",r),n(p.texture,i.mapping)}return null}}}return i},dispose:function(){t=new WeakMap}}}function Kp(e){const t={};return{has:function(n){if(t[n]!==void 0)return t[n]!==null;let r;switch(n){case"WEBGL_depth_texture":r=e.getExtension("WEBGL_depth_texture")||e.getExtension("MOZ_WEBGL_depth_texture")||e.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":r=e.getExtension("EXT_texture_filter_anisotropic")||e.getExtension("MOZ_EXT_texture_filter_anisotropic")||e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":r=e.getExtension("WEBGL_compressed_texture_s3tc")||e.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":r=e.getExtension("WEBGL_compressed_texture_pvrtc")||e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:r=e.getExtension(n)}return t[n]=r,r!==null},get:function(n){return this.has(n)||console.warn("THREE.WebGLRenderer: "+n+" extension not supported."),t[n]}}}function Qp(e,t,n,r){const i=new WeakMap,o=new WeakMap;function a(c){const u=c.target,p=i.get(u);p.index!==null&&t.remove(p.index);for(const g in p.attributes)t.remove(p.attributes[g]);u.removeEventListener("dispose",a),i.delete(u);const d=o.get(p);d&&(t.remove(d),o.delete(p)),r.releaseStatesOfGeometry(p),u.isInstancedBufferGeometry===!0&&delete u._maxInstanceCount,n.memory.geometries--}function s(c){const u=[],p=c.index,d=c.attributes.position;let g=0;if(p!==null){const S=p.array;g=p.version;for(let b=0,R=S.length;b<R;b+=3){const F=S[b+0],ee=S[b+1],k=S[b+2];u.push(F,ee,ee,k,k,F)}}else{const S=d.array;g=d.version;for(let b=0,R=S.length/3-1;b<R;b+=3){const F=b+0,ee=b+1,k=b+2;u.push(F,ee,ee,k,k,F)}}const m=new(Zu(u)>65535?Ti:Si)(u,1);m.version=g;const x=o.get(c);x&&t.remove(x),o.set(c,m)}return{get:function(c,u){let p=i.get(u);return p||(u.addEventListener("dispose",a),u.isBufferGeometry?p=u:u.isGeometry&&(u._bufferGeometry===void 0&&(u._bufferGeometry=new Ct().setFromObject(c)),p=u._bufferGeometry),i.set(u,p),n.memory.geometries++,p)},update:function(c){const u=c.attributes;for(const d in u)t.update(u[d],34962);const p=c.morphAttributes;for(const d in p){const g=p[d];for(let m=0,x=g.length;m<x;m++)t.update(g[m],34962)}},getWireframeAttribute:function(c){const u=o.get(c);if(u){const p=c.index;p!==null&&u.version<p.version&&s(c)}else s(c);return o.get(c)}}}function $p(e,t,n,r){const i=r.isWebGL2;let o,a,s;this.setMode=function(c){o=c},this.setIndex=function(c){a=c.type,s=c.bytesPerElement},this.render=function(c,u){e.drawElements(o,u,a,c*s),n.update(u,o,1)},this.renderInstances=function(c,u,p){if(p===0)return;let d,g;if(i)d=e,g="drawElementsInstanced";else if(d=t.get("ANGLE_instanced_arrays"),g="drawElementsInstancedANGLE",d===null)return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");d[g](o,u,a,c*s,p),n.update(u,o,p)}}function ef(e){const t={frame:0,calls:0,triangles:0,points:0,lines:0};return{memory:{geometries:0,textures:0},render:t,programs:null,autoReset:!0,reset:function(){t.frame++,t.calls=0,t.triangles=0,t.points=0,t.lines=0},update:function(n,r,i){switch(t.calls++,r){case 4:t.triangles+=i*(n/3);break;case 1:t.lines+=i*(n/2);break;case 3:t.lines+=i*(n-1);break;case 2:t.lines+=i*n;break;case 0:t.points+=i*n;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",r)}}}}function tf(e,t){return e[0]-t[0]}function nf(e,t){return Math.abs(t[1])-Math.abs(e[1])}function rf(e){const t={},n=new Float32Array(8),r=[];for(let i=0;i<8;i++)r[i]=[i,0];return{update:function(i,o,a,s){const c=i.morphTargetInfluences,u=c===void 0?0:c.length;let p=t[o.id];if(p===void 0){p=[];for(let S=0;S<u;S++)p[S]=[S,0];t[o.id]=p}for(let S=0;S<u;S++){const b=p[S];b[0]=S,b[1]=c[S]}p.sort(nf);for(let S=0;S<8;S++)S<u&&p[S][1]?(r[S][0]=p[S][0],r[S][1]=p[S][1]):(r[S][0]=Number.MAX_SAFE_INTEGER,r[S][1]=0);r.sort(tf);const d=a.morphTargets&&o.morphAttributes.position,g=a.morphNormals&&o.morphAttributes.normal;let m=0;for(let S=0;S<8;S++){const b=r[S],R=b[0],F=b[1];R!==Number.MAX_SAFE_INTEGER&&F?(d&&o.getAttribute("morphTarget"+S)!==d[R]&&o.setAttribute("morphTarget"+S,d[R]),g&&o.getAttribute("morphNormal"+S)!==g[R]&&o.setAttribute("morphNormal"+S,g[R]),n[S]=F,m+=F):(d&&o.hasAttribute("morphTarget"+S)===!0&&o.deleteAttribute("morphTarget"+S),g&&o.hasAttribute("morphNormal"+S)===!0&&o.deleteAttribute("morphNormal"+S),n[S]=0)}const x=o.morphTargetsRelative?1:1-m;s.getUniforms().setValue(e,"morphTargetBaseInfluence",x),s.getUniforms().setValue(e,"morphTargetInfluences",n)}}}function of(e,t,n,r){let i=new WeakMap;return{update:function(o){const a=r.render.frame,s=o.geometry,c=t.get(o,s);return i.get(c)!==a&&(s.isGeometry&&c.updateFromObject(o),t.update(c),i.set(c,a)),o.isInstancedMesh&&(n.update(o.instanceMatrix,34962),o.instanceColor!==null&&n.update(o.instanceColor,34962)),c},dispose:function(){i=new WeakMap}}}function so(e=null,t=1,n=1,r=1){tn.call(this,null),this.image={data:e,width:t,height:n,depth:r},this.magFilter=y,this.minFilter=y,this.wrapR=v,this.generateMipmaps=!1,this.flipY=!1,this.needsUpdate=!0}function co(e=null,t=1,n=1,r=1){tn.call(this,null),this.image={data:e,width:t,height:n,depth:r},this.magFilter=y,this.minFilter=y,this.wrapR=v,this.generateMipmaps=!1,this.flipY=!1,this.needsUpdate=!0}gr.physical={uniforms:Fn([gr.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new Je(1,1)},clearcoatNormalMap:{value:null},sheen:{value:new _t(0)},transmission:{value:0},transmissionMap:{value:null}}]),vertexShader:Vt.meshphysical_vert,fragmentShader:Vt.meshphysical_frag},so.prototype=Object.create(tn.prototype),so.prototype.constructor=so,so.prototype.isDataTexture2DArray=!0,co.prototype=Object.create(tn.prototype),co.prototype.constructor=co,co.prototype.isDataTexture3D=!0;const eh=new tn,af=new so,sf=new co,th=new Cr,nh=[],rh=[],ih=new Float32Array(16),oh=new Float32Array(9),ah=new Float32Array(4);function lo(e,t,n){const r=e[0];if(r<=0||r>0)return e;const i=t*n;let o=nh[i];if(o===void 0&&(o=new Float32Array(i),nh[i]=o),t!==0){r.toArray(o,0);for(let a=1,s=0;a!==t;++a)s+=n,e[a].toArray(o,s)}return o}function cr(e,t){if(e.length!==t.length)return!1;for(let n=0,r=e.length;n<r;n++)if(e[n]!==t[n])return!1;return!0}function er(e,t){for(let n=0,r=t.length;n<r;n++)e[n]=t[n]}function sh(e,t){let n=rh[t];n===void 0&&(n=new Int32Array(t),rh[t]=n);for(let r=0;r!==t;++r)n[r]=e.allocateTextureUnit();return n}function cf(e,t){const n=this.cache;n[0]!==t&&(e.uniform1f(this.addr,t),n[0]=t)}function lf(e,t){const n=this.cache;if(t.x!==void 0)n[0]===t.x&&n[1]===t.y||(e.uniform2f(this.addr,t.x,t.y),n[0]=t.x,n[1]=t.y);else{if(cr(n,t))return;e.uniform2fv(this.addr,t),er(n,t)}}function uf(e,t){const n=this.cache;if(t.x!==void 0)n[0]===t.x&&n[1]===t.y&&n[2]===t.z||(e.uniform3f(this.addr,t.x,t.y,t.z),n[0]=t.x,n[1]=t.y,n[2]=t.z);else if(t.r!==void 0)n[0]===t.r&&n[1]===t.g&&n[2]===t.b||(e.uniform3f(this.addr,t.r,t.g,t.b),n[0]=t.r,n[1]=t.g,n[2]=t.b);else{if(cr(n,t))return;e.uniform3fv(this.addr,t),er(n,t)}}function hf(e,t){const n=this.cache;if(t.x!==void 0)n[0]===t.x&&n[1]===t.y&&n[2]===t.z&&n[3]===t.w||(e.uniform4f(this.addr,t.x,t.y,t.z,t.w),n[0]=t.x,n[1]=t.y,n[2]=t.z,n[3]=t.w);else{if(cr(n,t))return;e.uniform4fv(this.addr,t),er(n,t)}}function df(e,t){const n=this.cache,r=t.elements;if(r===void 0){if(cr(n,t))return;e.uniformMatrix2fv(this.addr,!1,t),er(n,t)}else{if(cr(n,r))return;ah.set(r),e.uniformMatrix2fv(this.addr,!1,ah),er(n,r)}}function pf(e,t){const n=this.cache,r=t.elements;if(r===void 0){if(cr(n,t))return;e.uniformMatrix3fv(this.addr,!1,t),er(n,t)}else{if(cr(n,r))return;oh.set(r),e.uniformMatrix3fv(this.addr,!1,oh),er(n,r)}}function ff(e,t){const n=this.cache,r=t.elements;if(r===void 0){if(cr(n,t))return;e.uniformMatrix4fv(this.addr,!1,t),er(n,t)}else{if(cr(n,r))return;ih.set(r),e.uniformMatrix4fv(this.addr,!1,ih),er(n,r)}}function mf(e,t,n){const r=this.cache,i=n.allocateTextureUnit();r[0]!==i&&(e.uniform1i(this.addr,i),r[0]=i),n.safeSetTexture2D(t||eh,i)}function gf(e,t,n){const r=this.cache,i=n.allocateTextureUnit();r[0]!==i&&(e.uniform1i(this.addr,i),r[0]=i),n.setTexture2DArray(t||af,i)}function vf(e,t,n){const r=this.cache,i=n.allocateTextureUnit();r[0]!==i&&(e.uniform1i(this.addr,i),r[0]=i),n.setTexture3D(t||sf,i)}function yf(e,t,n){const r=this.cache,i=n.allocateTextureUnit();r[0]!==i&&(e.uniform1i(this.addr,i),r[0]=i),n.safeSetTextureCube(t||th,i)}function xf(e,t){const n=this.cache;n[0]!==t&&(e.uniform1i(this.addr,t),n[0]=t)}function bf(e,t){const n=this.cache;cr(n,t)||(e.uniform2iv(this.addr,t),er(n,t))}function wf(e,t){const n=this.cache;cr(n,t)||(e.uniform3iv(this.addr,t),er(n,t))}function _f(e,t){const n=this.cache;cr(n,t)||(e.uniform4iv(this.addr,t),er(n,t))}function Mf(e,t){const n=this.cache;n[0]!==t&&(e.uniform1ui(this.addr,t),n[0]=t)}function Sf(e,t){e.uniform1fv(this.addr,t)}function Tf(e,t){e.uniform1iv(this.addr,t)}function Ef(e,t){e.uniform2iv(this.addr,t)}function Af(e,t){e.uniform3iv(this.addr,t)}function Lf(e,t){e.uniform4iv(this.addr,t)}function Cf(e,t){const n=lo(t,this.size,2);e.uniform2fv(this.addr,n)}function Pf(e,t){const n=lo(t,this.size,3);e.uniform3fv(this.addr,n)}function Rf(e,t){const n=lo(t,this.size,4);e.uniform4fv(this.addr,n)}function Of(e,t){const n=lo(t,this.size,4);e.uniformMatrix2fv(this.addr,!1,n)}function Df(e,t){const n=lo(t,this.size,9);e.uniformMatrix3fv(this.addr,!1,n)}function If(e,t){const n=lo(t,this.size,16);e.uniformMatrix4fv(this.addr,!1,n)}function Nf(e,t,n){const r=t.length,i=sh(n,r);e.uniform1iv(this.addr,i);for(let o=0;o!==r;++o)n.safeSetTexture2D(t[o]||eh,i[o])}function Bf(e,t,n){const r=t.length,i=sh(n,r);e.uniform1iv(this.addr,i);for(let o=0;o!==r;++o)n.safeSetTextureCube(t[o]||th,i[o])}function Ff(e,t,n){this.id=e,this.addr=n,this.cache=[],this.setValue=function(r){switch(r){case 5126:return cf;case 35664:return lf;case 35665:return uf;case 35666:return hf;case 35674:return df;case 35675:return pf;case 35676:return ff;case 5124:case 35670:return xf;case 35667:case 35671:return bf;case 35668:case 35672:return wf;case 35669:case 35673:return _f;case 5125:return Mf;case 35678:case 36198:case 36298:case 36306:case 35682:return mf;case 35679:case 36299:case 36307:return vf;case 35680:case 36300:case 36308:case 36293:return yf;case 36289:case 36303:case 36311:case 36292:return gf}}(t.type)}function ch(e,t,n){this.id=e,this.addr=n,this.cache=[],this.size=t.size,this.setValue=function(r){switch(r){case 5126:return Sf;case 35664:return Cf;case 35665:return Pf;case 35666:return Rf;case 35674:return Of;case 35675:return Df;case 35676:return If;case 5124:case 35670:return Tf;case 35667:case 35671:return Ef;case 35668:case 35672:return Af;case 35669:case 35673:return Lf;case 35678:case 36198:case 36298:case 36306:case 35682:return Nf;case 35680:case 36300:case 36308:case 36293:return Bf}}(t.type)}function lh(e){this.id=e,this.seq=[],this.map={}}ch.prototype.updateCache=function(e){const t=this.cache;e instanceof Float32Array&&t.length!==e.length&&(this.cache=new Float32Array(e.length)),er(t,e)},lh.prototype.setValue=function(e,t,n){const r=this.seq;for(let i=0,o=r.length;i!==o;++i){const a=r[i];a.setValue(e,t[a.id],n)}};const Ic=/([\w\d_]+)(\])?(\[|\.)?/g;function uh(e,t){e.seq.push(t),e.map[t.id]=t}function Uf(e,t,n){const r=e.name,i=r.length;for(Ic.lastIndex=0;;){const o=Ic.exec(r),a=Ic.lastIndex;let s=o[1];const c=o[2]==="]",u=o[3];if(c&&(s|=0),u===void 0||u==="["&&a+2===i){uh(n,u===void 0?new Ff(s,e,t):new ch(s,e,t));break}{let p=n.map[s];p===void 0&&(p=new lh(s),uh(n,p)),n=p}}}function ri(e,t){this.seq=[],this.map={};const n=e.getProgramParameter(t,35718);for(let r=0;r<n;++r){const i=e.getActiveUniform(t,r);Uf(i,e.getUniformLocation(t,i.name),this)}}function hh(e,t,n){const r=e.createShader(t);return e.shaderSource(r,n),e.compileShader(r),r}ri.prototype.setValue=function(e,t,n,r){const i=this.map[t];i!==void 0&&i.setValue(e,n,r)},ri.prototype.setOptional=function(e,t,n){const r=t[n];r!==void 0&&this.setValue(e,n,r)},ri.upload=function(e,t,n,r){for(let i=0,o=t.length;i!==o;++i){const a=t[i],s=n[a.id];s.needsUpdate!==!1&&a.setValue(e,s.value,r)}},ri.seqWithValue=function(e,t){const n=[];for(let r=0,i=e.length;r!==i;++r){const o=e[r];o.id in t&&n.push(o)}return n};let zf=0;function dh(e){switch(e){case Gn:return["Linear","( value )"];case Po:return["sRGB","( value )"];case Da:return["RGBE","( value )"];case cc:return["RGBM","( value, 7.0 )"];case lc:return["RGBM","( value, 16.0 )"];case uc:return["RGBD","( value, 256.0 )"];case Oa:return["Gamma","( value, float( GAMMA_FACTOR ) )"];case Iu:return["LogLuv","( value )"];default:return console.warn("THREE.WebGLProgram: Unsupported encoding:",e),["Linear","( value )"]}}function ph(e,t,n){const r=e.getShaderParameter(t,35713),i=e.getShaderInfoLog(t).trim();return r&&i===""?"":"THREE.WebGLShader: gl.getShaderInfoLog() "+n+`
`+i+function(o){const a=o.split(`
`);for(let s=0;s<a.length;s++)a[s]=s+1+": "+a[s];return a.join(`
`)}(e.getShaderSource(t))}function Zo(e,t){const n=dh(t);return"vec4 "+e+"( vec4 value ) { return "+n[0]+"ToLinear"+n[1]+"; }"}function kf(e,t){const n=dh(t);return"vec4 "+e+"( vec4 value ) { return LinearTo"+n[0]+n[1]+"; }"}function Hf(e,t){let n;switch(t){case V:n="Linear";break;case j:n="Reinhard";break;case H:n="OptimizedCineon";break;case B:n="ACESFilmic";break;case w:n="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",t),n="Linear"}return"vec3 "+e+"( vec3 color ) { return "+n+"ToneMapping( color ); }"}function Jo(e){return e!==""}function fh(e,t){return e.replace(/NUM_DIR_LIGHTS/g,t.numDirLights).replace(/NUM_SPOT_LIGHTS/g,t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,t.numPointLights).replace(/NUM_HEMI_LIGHTS/g,t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g,t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,t.numPointLightShadows)}function mh(e,t){return e.replace(/NUM_CLIPPING_PLANES/g,t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,t.numClippingPlanes-t.numClipIntersection)}const Gf=/^[ \t]*#include +<([\w\d./]+)>/gm;function Nc(e){return e.replace(Gf,Vf)}function Vf(e,t){const n=Vt[t];if(n===void 0)throw new Error("Can not resolve #include <"+t+">");return Nc(n)}const jf=/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,Wf=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function gh(e){return e.replace(Wf,vh).replace(jf,Xf)}function Xf(e,t,n,r){return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."),vh(e,t,n,r)}function vh(e,t,n,r){let i="";for(let o=parseInt(t);o<parseInt(n);o++)i+=r.replace(/\[\s*i\s*\]/g,"[ "+o+" ]").replace(/UNROLLED_LOOP_INDEX/g,o);return i}function yh(e){let t="precision "+e.precision+` float;
precision `+e.precision+" int;";return e.precision==="highp"?t+=`
#define HIGH_PRECISION`:e.precision==="mediump"?t+=`
#define MEDIUM_PRECISION`:e.precision==="lowp"&&(t+=`
#define LOW_PRECISION`),t}function qf(e,t,n,r){const i=e.getContext(),o=n.defines;let a=n.vertexShader,s=n.fragmentShader;const c=function(Le){let Ae="SHADOWMAP_TYPE_BASIC";return Le.shadowMapType===we?Ae="SHADOWMAP_TYPE_PCF":Le.shadowMapType===Se?Ae="SHADOWMAP_TYPE_PCF_SOFT":Le.shadowMapType===Me&&(Ae="SHADOWMAP_TYPE_VSM"),Ae}(n),u=function(Le){let Ae="ENVMAP_TYPE_CUBE";if(Le.envMap)switch(Le.envMapMode){case ye:case _e:Ae="ENVMAP_TYPE_CUBE";break;case pe:case Fe:Ae="ENVMAP_TYPE_CUBE_UV"}return Ae}(n),p=function(Le){let Ae="ENVMAP_MODE_REFLECTION";if(Le.envMap)switch(Le.envMapMode){case _e:case Fe:Ae="ENVMAP_MODE_REFRACTION"}return Ae}(n),d=function(Le){let Ae="ENVMAP_BLENDING_NONE";if(Le.envMap)switch(Le.combine){case Ze:Ae="ENVMAP_BLENDING_MULTIPLY";break;case Oe:Ae="ENVMAP_BLENDING_MIX";break;case O:Ae="ENVMAP_BLENDING_ADD"}return Ae}(n),g=e.gammaFactor>0?e.gammaFactor:1,m=n.isWebGL2?"":function(Le){return[Le.extensionDerivatives||Le.envMapCubeUV||Le.bumpMap||Le.tangentSpaceNormalMap||Le.clearcoatNormalMap||Le.flatShading||Le.shaderID==="physical"?"#extension GL_OES_standard_derivatives : enable":"",(Le.extensionFragDepth||Le.logarithmicDepthBuffer)&&Le.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",Le.extensionDrawBuffers&&Le.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(Le.extensionShaderTextureLOD||Le.envMap)&&Le.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(Jo).join(`
`)}(n),x=function(Le){const Ae=[];for(const xe in Le){const Xe=Le[xe];Xe!==!1&&Ae.push("#define "+xe+" "+Xe)}return Ae.join(`
`)}(o),S=i.createProgram();let b,R,F=n.glslVersion?"#version "+n.glslVersion+`
`:"";n.isRawShaderMaterial?(b=[x].filter(Jo).join(`
`),b.length>0&&(b+=`
`),R=[m,x].filter(Jo).join(`
`),R.length>0&&(R+=`
`)):(b=[yh(n),"#define SHADER_NAME "+n.shaderName,x,n.instancing?"#define USE_INSTANCING":"",n.instancingColor?"#define USE_INSTANCING_COLOR":"",n.supportsVertexTextures?"#define VERTEX_TEXTURES":"","#define GAMMA_FACTOR "+g,"#define MAX_BONES "+n.maxBones,n.useFog&&n.fog?"#define USE_FOG":"",n.useFog&&n.fogExp2?"#define FOG_EXP2":"",n.map?"#define USE_MAP":"",n.envMap?"#define USE_ENVMAP":"",n.envMap?"#define "+p:"",n.lightMap?"#define USE_LIGHTMAP":"",n.aoMap?"#define USE_AOMAP":"",n.emissiveMap?"#define USE_EMISSIVEMAP":"",n.bumpMap?"#define USE_BUMPMAP":"",n.normalMap?"#define USE_NORMALMAP":"",n.normalMap&&n.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",n.normalMap&&n.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",n.clearcoatMap?"#define USE_CLEARCOATMAP":"",n.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",n.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",n.displacementMap&&n.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",n.specularMap?"#define USE_SPECULARMAP":"",n.roughnessMap?"#define USE_ROUGHNESSMAP":"",n.metalnessMap?"#define USE_METALNESSMAP":"",n.alphaMap?"#define USE_ALPHAMAP":"",n.transmissionMap?"#define USE_TRANSMISSIONMAP":"",n.vertexTangents?"#define USE_TANGENT":"",n.vertexColors?"#define USE_COLOR":"",n.vertexUvs?"#define USE_UV":"",n.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",n.flatShading?"#define FLAT_SHADED":"",n.skinning?"#define USE_SKINNING":"",n.useVertexTexture?"#define BONE_TEXTURE":"",n.morphTargets?"#define USE_MORPHTARGETS":"",n.morphNormals&&n.flatShading===!1?"#define USE_MORPHNORMALS":"",n.doubleSided?"#define DOUBLE_SIDED":"",n.flipSided?"#define FLIP_SIDED":"",n.shadowMapEnabled?"#define USE_SHADOWMAP":"",n.shadowMapEnabled?"#define "+c:"",n.sizeAttenuation?"#define USE_SIZEATTENUATION":"",n.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",n.logarithmicDepthBuffer&&n.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#ifdef USE_COLOR","	attribute vec3 color;","#endif","#ifdef USE_MORPHTARGETS","	attribute vec3 morphTarget0;","	attribute vec3 morphTarget1;","	attribute vec3 morphTarget2;","	attribute vec3 morphTarget3;","	#ifdef USE_MORPHNORMALS","		attribute vec3 morphNormal0;","		attribute vec3 morphNormal1;","		attribute vec3 morphNormal2;","		attribute vec3 morphNormal3;","	#else","		attribute vec3 morphTarget4;","		attribute vec3 morphTarget5;","		attribute vec3 morphTarget6;","		attribute vec3 morphTarget7;","	#endif","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif",`
`].filter(Jo).join(`
`),R=[m,yh(n),"#define SHADER_NAME "+n.shaderName,x,n.alphaTest?"#define ALPHATEST "+n.alphaTest+(n.alphaTest%1?"":".0"):"","#define GAMMA_FACTOR "+g,n.useFog&&n.fog?"#define USE_FOG":"",n.useFog&&n.fogExp2?"#define FOG_EXP2":"",n.map?"#define USE_MAP":"",n.matcap?"#define USE_MATCAP":"",n.envMap?"#define USE_ENVMAP":"",n.envMap?"#define "+u:"",n.envMap?"#define "+p:"",n.envMap?"#define "+d:"",n.lightMap?"#define USE_LIGHTMAP":"",n.aoMap?"#define USE_AOMAP":"",n.emissiveMap?"#define USE_EMISSIVEMAP":"",n.bumpMap?"#define USE_BUMPMAP":"",n.normalMap?"#define USE_NORMALMAP":"",n.normalMap&&n.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",n.normalMap&&n.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",n.clearcoatMap?"#define USE_CLEARCOATMAP":"",n.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",n.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",n.specularMap?"#define USE_SPECULARMAP":"",n.roughnessMap?"#define USE_ROUGHNESSMAP":"",n.metalnessMap?"#define USE_METALNESSMAP":"",n.alphaMap?"#define USE_ALPHAMAP":"",n.sheen?"#define USE_SHEEN":"",n.transmissionMap?"#define USE_TRANSMISSIONMAP":"",n.vertexTangents?"#define USE_TANGENT":"",n.vertexColors||n.instancingColor?"#define USE_COLOR":"",n.vertexUvs?"#define USE_UV":"",n.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",n.gradientMap?"#define USE_GRADIENTMAP":"",n.flatShading?"#define FLAT_SHADED":"",n.doubleSided?"#define DOUBLE_SIDED":"",n.flipSided?"#define FLIP_SIDED":"",n.shadowMapEnabled?"#define USE_SHADOWMAP":"",n.shadowMapEnabled?"#define "+c:"",n.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",n.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":"",n.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",n.logarithmicDepthBuffer&&n.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"",(n.extensionShaderTextureLOD||n.envMap)&&n.rendererExtensionShaderTextureLod?"#define TEXTURE_LOD_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",n.toneMapping!==C?"#define TONE_MAPPING":"",n.toneMapping!==C?Vt.tonemapping_pars_fragment:"",n.toneMapping!==C?Hf("toneMapping",n.toneMapping):"",n.dithering?"#define DITHERING":"",Vt.encodings_pars_fragment,n.map?Zo("mapTexelToLinear",n.mapEncoding):"",n.matcap?Zo("matcapTexelToLinear",n.matcapEncoding):"",n.envMap?Zo("envMapTexelToLinear",n.envMapEncoding):"",n.emissiveMap?Zo("emissiveMapTexelToLinear",n.emissiveMapEncoding):"",n.lightMap?Zo("lightMapTexelToLinear",n.lightMapEncoding):"",kf("linearToOutputTexel",n.outputEncoding),n.depthPacking?"#define DEPTH_PACKING "+n.depthPacking:"",`
`].filter(Jo).join(`
`)),a=Nc(a),a=fh(a,n),a=mh(a,n),s=Nc(s),s=fh(s,n),s=mh(s,n),a=gh(a),s=gh(s),n.isWebGL2&&n.isRawShaderMaterial!==!0&&(F=`#version 300 es
`,b=["#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+b,R=["#define varying in",n.glslVersion===hc?"":"out highp vec4 pc_fragColor;",n.glslVersion===hc?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+R);const ee=F+R+s,k=hh(i,35633,F+b+a),K=hh(i,35632,ee);if(i.attachShader(S,k),i.attachShader(S,K),n.index0AttributeName!==void 0?i.bindAttribLocation(S,0,n.index0AttributeName):n.morphTargets===!0&&i.bindAttribLocation(S,0,"position"),i.linkProgram(S),e.debug.checkShaderErrors){const Le=i.getProgramInfoLog(S).trim(),Ae=i.getShaderInfoLog(k).trim(),xe=i.getShaderInfoLog(K).trim();let Xe=!0,He=!0;if(i.getProgramParameter(S,35714)===!1){Xe=!1;const tt=ph(i,k,"vertex"),ft=ph(i,K,"fragment");console.error("THREE.WebGLProgram: shader error: ",i.getError(),"35715",i.getProgramParameter(S,35715),"gl.getProgramInfoLog",Le,tt,ft)}else Le!==""?console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()",Le):Ae!==""&&xe!==""||(He=!1);He&&(this.diagnostics={runnable:Xe,programLog:Le,vertexShader:{log:Ae,prefix:b},fragmentShader:{log:xe,prefix:R}})}let le,ge;return i.deleteShader(k),i.deleteShader(K),this.getUniforms=function(){return le===void 0&&(le=new ri(i,S)),le},this.getAttributes=function(){return ge===void 0&&(ge=function(Le,Ae){const xe={},Xe=Le.getProgramParameter(Ae,35721);for(let He=0;He<Xe;He++){const tt=Le.getActiveAttrib(Ae,He).name;xe[tt]=Le.getAttribLocation(Ae,tt)}return xe}(i,S)),ge},this.destroy=function(){r.releaseStatesOfProgram(this),i.deleteProgram(S),this.program=void 0},this.name=n.shaderName,this.id=zf++,this.cacheKey=t,this.usedTimes=1,this.program=S,this.vertexShader=k,this.fragmentShader=K,this}function Yf(e,t,n,r,i,o){const a=[],s=r.isWebGL2,c=r.logarithmicDepthBuffer,u=r.floatVertexTextures,p=r.maxVertexUniforms,d=r.vertexTextures;let g=r.precision;const m={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"},x=["precision","isWebGL2","supportsVertexTextures","outputEncoding","instancing","instancingColor","map","mapEncoding","matcap","matcapEncoding","envMap","envMapMode","envMapEncoding","envMapCubeUV","lightMap","lightMapEncoding","aoMap","emissiveMap","emissiveMapEncoding","bumpMap","normalMap","objectSpaceNormalMap","tangentSpaceNormalMap","clearcoatMap","clearcoatRoughnessMap","clearcoatNormalMap","displacementMap","specularMap","roughnessMap","metalnessMap","gradientMap","alphaMap","combine","vertexColors","vertexTangents","vertexUvs","uvsVertexOnly","fog","useFog","fogExp2","flatShading","sizeAttenuation","logarithmicDepthBuffer","skinning","maxBones","useVertexTexture","morphTargets","morphNormals","maxMorphTargets","maxMorphNormals","premultipliedAlpha","numDirLights","numPointLights","numSpotLights","numHemiLights","numRectAreaLights","numDirLightShadows","numPointLightShadows","numSpotLightShadows","shadowMapEnabled","shadowMapType","toneMapping","physicallyCorrectLights","alphaTest","doubleSided","flipSided","numClippingPlanes","numClipIntersection","depthPacking","dithering","sheen","transmissionMap"];function S(b){let R;return b?b.isTexture?R=b.encoding:b.isWebGLRenderTarget&&(console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."),R=b.texture.encoding):R=Gn,R}return{getParameters:function(b,R,F,ee,k){const K=ee.fog,le=b.isMeshStandardMaterial?ee.environment:null,ge=t.get(b.envMap||le),Le=m[b.type],Ae=k.isSkinnedMesh?function(tt){const ft=tt.skeleton.bones;if(u)return 1024;{const ke=p,dt=Math.floor((ke-20)/4),et=Math.min(dt,ft.length);return et<ft.length?(console.warn("THREE.WebGLRenderer: Skeleton has "+ft.length+" bones. This GPU supports "+et+"."),0):et}}(k):0;let xe,Xe;if(b.precision!==null&&(g=r.getMaxPrecision(b.precision),g!==b.precision&&console.warn("THREE.WebGLProgram.getParameters:",b.precision,"not supported, using",g,"instead.")),Le){const tt=gr[Le];xe=tt.vertexShader,Xe=tt.fragmentShader}else xe=b.vertexShader,Xe=b.fragmentShader;const He=e.getRenderTarget();return{isWebGL2:s,shaderID:Le,shaderName:b.type,vertexShader:xe,fragmentShader:Xe,defines:b.defines,isRawShaderMaterial:b.isRawShaderMaterial===!0,glslVersion:b.glslVersion,precision:g,instancing:k.isInstancedMesh===!0,instancingColor:k.isInstancedMesh===!0&&k.instanceColor!==null,supportsVertexTextures:d,outputEncoding:He!==null?S(He.texture):e.outputEncoding,map:!!b.map,mapEncoding:S(b.map),matcap:!!b.matcap,matcapEncoding:S(b.matcap),envMap:!!ge,envMapMode:ge&&ge.mapping,envMapEncoding:S(ge),envMapCubeUV:!!ge&&(ge.mapping===pe||ge.mapping===Fe),lightMap:!!b.lightMap,lightMapEncoding:S(b.lightMap),aoMap:!!b.aoMap,emissiveMap:!!b.emissiveMap,emissiveMapEncoding:S(b.emissiveMap),bumpMap:!!b.bumpMap,normalMap:!!b.normalMap,objectSpaceNormalMap:b.normalMapType===Fu,tangentSpaceNormalMap:b.normalMapType===xi,clearcoatMap:!!b.clearcoatMap,clearcoatRoughnessMap:!!b.clearcoatRoughnessMap,clearcoatNormalMap:!!b.clearcoatNormalMap,displacementMap:!!b.displacementMap,roughnessMap:!!b.roughnessMap,metalnessMap:!!b.metalnessMap,specularMap:!!b.specularMap,alphaMap:!!b.alphaMap,gradientMap:!!b.gradientMap,sheen:!!b.sheen,transmissionMap:!!b.transmissionMap,combine:b.combine,vertexTangents:b.normalMap&&b.vertexTangents,vertexColors:b.vertexColors,vertexUvs:!!(b.map||b.bumpMap||b.normalMap||b.specularMap||b.alphaMap||b.emissiveMap||b.roughnessMap||b.metalnessMap||b.clearcoatMap||b.clearcoatRoughnessMap||b.clearcoatNormalMap||b.displacementMap||b.transmissionMap),uvsVertexOnly:!(b.map||b.bumpMap||b.normalMap||b.specularMap||b.alphaMap||b.emissiveMap||b.roughnessMap||b.metalnessMap||b.clearcoatNormalMap||b.transmissionMap||!b.displacementMap),fog:!!K,useFog:b.fog,fogExp2:K&&K.isFogExp2,flatShading:b.flatShading,sizeAttenuation:b.sizeAttenuation,logarithmicDepthBuffer:c,skinning:b.skinning&&Ae>0,maxBones:Ae,useVertexTexture:u,morphTargets:b.morphTargets,morphNormals:b.morphNormals,maxMorphTargets:e.maxMorphTargets,maxMorphNormals:e.maxMorphNormals,numDirLights:R.directional.length,numPointLights:R.point.length,numSpotLights:R.spot.length,numRectAreaLights:R.rectArea.length,numHemiLights:R.hemi.length,numDirLightShadows:R.directionalShadowMap.length,numPointLightShadows:R.pointShadowMap.length,numSpotLightShadows:R.spotShadowMap.length,numClippingPlanes:o.numPlanes,numClipIntersection:o.numIntersection,dithering:b.dithering,shadowMapEnabled:e.shadowMap.enabled&&F.length>0,shadowMapType:e.shadowMap.type,toneMapping:b.toneMapped?e.toneMapping:C,physicallyCorrectLights:e.physicallyCorrectLights,premultipliedAlpha:b.premultipliedAlpha,alphaTest:b.alphaTest,doubleSided:b.side===J,flipSided:b.side===Z,depthPacking:b.depthPacking!==void 0&&b.depthPacking,index0AttributeName:b.index0AttributeName,extensionDerivatives:b.extensions&&b.extensions.derivatives,extensionFragDepth:b.extensions&&b.extensions.fragDepth,extensionDrawBuffers:b.extensions&&b.extensions.drawBuffers,extensionShaderTextureLOD:b.extensions&&b.extensions.shaderTextureLOD,rendererExtensionFragDepth:s||n.has("EXT_frag_depth"),rendererExtensionDrawBuffers:s||n.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:s||n.has("EXT_shader_texture_lod"),customProgramCacheKey:b.customProgramCacheKey()}},getProgramCacheKey:function(b){const R=[];if(b.shaderID?R.push(b.shaderID):(R.push(b.fragmentShader),R.push(b.vertexShader)),b.defines!==void 0)for(const F in b.defines)R.push(F),R.push(b.defines[F]);if(b.isRawShaderMaterial===!1){for(let F=0;F<x.length;F++)R.push(b[x[F]]);R.push(e.outputEncoding),R.push(e.gammaFactor)}return R.push(b.customProgramCacheKey),R.join()},getUniforms:function(b){const R=m[b.type];let F;if(R){const ee=gr[R];F=Qu.clone(ee.uniforms)}else F=b.uniforms;return F},acquireProgram:function(b,R){let F;for(let ee=0,k=a.length;ee<k;ee++){const K=a[ee];if(K.cacheKey===R){F=K,++F.usedTimes;break}}return F===void 0&&(F=new qf(e,R,b,i),a.push(F)),F},releaseProgram:function(b){if(--b.usedTimes==0){const R=a.indexOf(b);a[R]=a[a.length-1],a.pop(),b.destroy()}},programs:a}}function Zf(){let e=new WeakMap;return{get:function(t){let n=e.get(t);return n===void 0&&(n={},e.set(t,n)),n},remove:function(t){e.delete(t)},update:function(t,n,r){e.get(t)[n]=r},dispose:function(){e=new WeakMap}}}function Jf(e,t){return e.groupOrder!==t.groupOrder?e.groupOrder-t.groupOrder:e.renderOrder!==t.renderOrder?e.renderOrder-t.renderOrder:e.program!==t.program?e.program.id-t.program.id:e.material.id!==t.material.id?e.material.id-t.material.id:e.z!==t.z?e.z-t.z:e.id-t.id}function Kf(e,t){return e.groupOrder!==t.groupOrder?e.groupOrder-t.groupOrder:e.renderOrder!==t.renderOrder?e.renderOrder-t.renderOrder:e.z!==t.z?t.z-e.z:e.id-t.id}function xh(e){const t=[];let n=0;const r=[],i=[],o={id:-1};function a(s,c,u,p,d,g){let m=t[n];const x=e.get(u);return m===void 0?(m={id:s.id,object:s,geometry:c,material:u,program:x.program||o,groupOrder:p,renderOrder:s.renderOrder,z:d,group:g},t[n]=m):(m.id=s.id,m.object=s,m.geometry=c,m.material=u,m.program=x.program||o,m.groupOrder=p,m.renderOrder=s.renderOrder,m.z=d,m.group=g),n++,m}return{opaque:r,transparent:i,init:function(){n=0,r.length=0,i.length=0},push:function(s,c,u,p,d,g){const m=a(s,c,u,p,d,g);(u.transparent===!0?i:r).push(m)},unshift:function(s,c,u,p,d,g){const m=a(s,c,u,p,d,g);(u.transparent===!0?i:r).unshift(m)},finish:function(){for(let s=n,c=t.length;s<c;s++){const u=t[s];if(u.id===null)break;u.id=null,u.object=null,u.geometry=null,u.material=null,u.program=null,u.group=null}},sort:function(s,c){r.length>1&&r.sort(s||Jf),i.length>1&&i.sort(c||Kf)}}}function Qf(e){let t=new WeakMap;return{get:function(n,r){const i=t.get(n);let o;return i===void 0?(o=new xh(e),t.set(n,new WeakMap),t.get(n).set(r,o)):(o=i.get(r),o===void 0&&(o=new xh(e),i.set(r,o))),o},dispose:function(){t=new WeakMap}}}function $f(){const e={};return{get:function(t){if(e[t.id]!==void 0)return e[t.id];let n;switch(t.type){case"DirectionalLight":n={direction:new z,color:new _t};break;case"SpotLight":n={position:new z,direction:new z,color:new _t,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":n={position:new z,color:new _t,distance:0,decay:0};break;case"HemisphereLight":n={direction:new z,skyColor:new _t,groundColor:new _t};break;case"RectAreaLight":n={color:new _t,position:new z,halfWidth:new z,halfHeight:new z}}return e[t.id]=n,n}}}let em=0;function tm(e,t){return(t.castShadow?1:0)-(e.castShadow?1:0)}function nm(e,t){const n=new $f,r=function(){const c={};return{get:function(u){if(c[u.id]!==void 0)return c[u.id];let p;switch(u.type){case"DirectionalLight":case"SpotLight":p={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Je};break;case"PointLight":p={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Je,shadowCameraNear:1,shadowCameraFar:1e3}}return c[u.id]=p,p}}}(),i={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadow:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[]};for(let c=0;c<9;c++)i.probe.push(new z);const o=new z,a=new Ht,s=new Ht;return{setup:function(c,u,p){let d=0,g=0,m=0;for(let Le=0;Le<9;Le++)i.probe[Le].set(0,0,0);let x=0,S=0,b=0,R=0,F=0,ee=0,k=0,K=0;const le=p.matrixWorldInverse;c.sort(tm);for(let Le=0,Ae=c.length;Le<Ae;Le++){const xe=c[Le],Xe=xe.color,He=xe.intensity,tt=xe.distance,ft=xe.shadow&&xe.shadow.map?xe.shadow.map.texture:null;if(xe.isAmbientLight)d+=Xe.r*He,g+=Xe.g*He,m+=Xe.b*He;else if(xe.isLightProbe)for(let ke=0;ke<9;ke++)i.probe[ke].addScaledVector(xe.sh.coefficients[ke],He);else if(xe.isDirectionalLight){const ke=n.get(xe);if(ke.color.copy(xe.color).multiplyScalar(xe.intensity),ke.direction.setFromMatrixPosition(xe.matrixWorld),o.setFromMatrixPosition(xe.target.matrixWorld),ke.direction.sub(o),ke.direction.transformDirection(le),xe.castShadow){const dt=xe.shadow,et=r.get(xe);et.shadowBias=dt.bias,et.shadowNormalBias=dt.normalBias,et.shadowRadius=dt.radius,et.shadowMapSize=dt.mapSize,i.directionalShadow[x]=et,i.directionalShadowMap[x]=ft,i.directionalShadowMatrix[x]=xe.shadow.matrix,ee++}i.directional[x]=ke,x++}else if(xe.isSpotLight){const ke=n.get(xe);if(ke.position.setFromMatrixPosition(xe.matrixWorld),ke.position.applyMatrix4(le),ke.color.copy(Xe).multiplyScalar(He),ke.distance=tt,ke.direction.setFromMatrixPosition(xe.matrixWorld),o.setFromMatrixPosition(xe.target.matrixWorld),ke.direction.sub(o),ke.direction.transformDirection(le),ke.coneCos=Math.cos(xe.angle),ke.penumbraCos=Math.cos(xe.angle*(1-xe.penumbra)),ke.decay=xe.decay,xe.castShadow){const dt=xe.shadow,et=r.get(xe);et.shadowBias=dt.bias,et.shadowNormalBias=dt.normalBias,et.shadowRadius=dt.radius,et.shadowMapSize=dt.mapSize,i.spotShadow[b]=et,i.spotShadowMap[b]=ft,i.spotShadowMatrix[b]=xe.shadow.matrix,K++}i.spot[b]=ke,b++}else if(xe.isRectAreaLight){const ke=n.get(xe);ke.color.copy(Xe).multiplyScalar(He),ke.position.setFromMatrixPosition(xe.matrixWorld),ke.position.applyMatrix4(le),s.identity(),a.copy(xe.matrixWorld),a.premultiply(le),s.extractRotation(a),ke.halfWidth.set(.5*xe.width,0,0),ke.halfHeight.set(0,.5*xe.height,0),ke.halfWidth.applyMatrix4(s),ke.halfHeight.applyMatrix4(s),i.rectArea[R]=ke,R++}else if(xe.isPointLight){const ke=n.get(xe);if(ke.position.setFromMatrixPosition(xe.matrixWorld),ke.position.applyMatrix4(le),ke.color.copy(xe.color).multiplyScalar(xe.intensity),ke.distance=xe.distance,ke.decay=xe.decay,xe.castShadow){const dt=xe.shadow,et=r.get(xe);et.shadowBias=dt.bias,et.shadowNormalBias=dt.normalBias,et.shadowRadius=dt.radius,et.shadowMapSize=dt.mapSize,et.shadowCameraNear=dt.camera.near,et.shadowCameraFar=dt.camera.far,i.pointShadow[S]=et,i.pointShadowMap[S]=ft,i.pointShadowMatrix[S]=xe.shadow.matrix,k++}i.point[S]=ke,S++}else if(xe.isHemisphereLight){const ke=n.get(xe);ke.direction.setFromMatrixPosition(xe.matrixWorld),ke.direction.transformDirection(le),ke.direction.normalize(),ke.skyColor.copy(xe.color).multiplyScalar(He),ke.groundColor.copy(xe.groundColor).multiplyScalar(He),i.hemi[F]=ke,F++}}R>0&&(t.isWebGL2||e.has("OES_texture_float_linear")===!0?(i.rectAreaLTC1=mt.LTC_FLOAT_1,i.rectAreaLTC2=mt.LTC_FLOAT_2):e.has("OES_texture_half_float_linear")===!0?(i.rectAreaLTC1=mt.LTC_HALF_1,i.rectAreaLTC2=mt.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),i.ambient[0]=d,i.ambient[1]=g,i.ambient[2]=m;const ge=i.hash;ge.directionalLength===x&&ge.pointLength===S&&ge.spotLength===b&&ge.rectAreaLength===R&&ge.hemiLength===F&&ge.numDirectionalShadows===ee&&ge.numPointShadows===k&&ge.numSpotShadows===K||(i.directional.length=x,i.spot.length=b,i.rectArea.length=R,i.point.length=S,i.hemi.length=F,i.directionalShadow.length=ee,i.directionalShadowMap.length=ee,i.pointShadow.length=k,i.pointShadowMap.length=k,i.spotShadow.length=K,i.spotShadowMap.length=K,i.directionalShadowMatrix.length=ee,i.pointShadowMatrix.length=k,i.spotShadowMatrix.length=K,ge.directionalLength=x,ge.pointLength=S,ge.spotLength=b,ge.rectAreaLength=R,ge.hemiLength=F,ge.numDirectionalShadows=ee,ge.numPointShadows=k,ge.numSpotShadows=K,i.version=em++)},state:i}}function bh(e,t){const n=new nm(e,t),r=[],i=[];return{init:function(){r.length=0,i.length=0},state:{lightsArray:r,shadowsArray:i,lights:n},setupLights:function(o){n.setup(r,i,o)},pushLight:function(o){r.push(o)},pushShadow:function(o){i.push(o)}}}function rm(e,t){let n=new WeakMap;return{get:function(r,i){let o;return n.has(r)===!1?(o=new bh(e,t),n.set(r,new WeakMap),n.get(r).set(i,o)):n.get(r).has(i)===!1?(o=new bh(e,t),n.get(r).set(i,o)):o=n.get(r).get(i),o},dispose:function(){n=new WeakMap}}}function ii(e){Nt.call(this),this.type="MeshDepthMaterial",this.depthPacking=Nu,this.skinning=!1,this.morphTargets=!1,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.setValues(e)}function oi(e){Nt.call(this),this.type="MeshDistanceMaterial",this.referencePosition=new z,this.nearDistance=1,this.farDistance=1e3,this.skinning=!1,this.morphTargets=!1,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.fog=!1,this.setValues(e)}ii.prototype=Object.create(Nt.prototype),ii.prototype.constructor=ii,ii.prototype.isMeshDepthMaterial=!0,ii.prototype.copy=function(e){return Nt.prototype.copy.call(this,e),this.depthPacking=e.depthPacking,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this},oi.prototype=Object.create(Nt.prototype),oi.prototype.constructor=oi,oi.prototype.isMeshDistanceMaterial=!0,oi.prototype.copy=function(e){return Nt.prototype.copy.call(this,e),this.referencePosition.copy(e.referencePosition),this.nearDistance=e.nearDistance,this.farDistance=e.farDistance,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this};function wh(e,t,n){let r=new Yo;const i=new Je,o=new Je,a=new nn,s=[],c=[],u={},p={0:Z,1:T,2:J},d=new jn({defines:{SAMPLE_RATE:2/8,HALF_SAMPLE_RATE:1/8},uniforms:{shadow_pass:{value:null},resolution:{value:new Je},radius:{value:4}},vertexShader:`void main() {
	gl_Position = vec4( position, 1.0 );
}`,fragmentShader:`uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	float mean = 0.0;
	float squared_mean = 0.0;
	float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );
	for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {
		#ifdef HORIZONAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean * HALF_SAMPLE_RATE;
	squared_mean = squared_mean * HALF_SAMPLE_RATE;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`}),g=d.clone();g.defines.HORIZONAL_PASS=1;const m=new Ct;m.setAttribute("position",new Rt(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const x=new pn(m,d),S=this;function b(K,le){const ge=t.update(x);d.uniforms.shadow_pass.value=K.map.texture,d.uniforms.resolution.value=K.mapSize,d.uniforms.radius.value=K.radius,e.setRenderTarget(K.mapPass),e.clear(),e.renderBufferDirect(le,null,ge,d,x,null),g.uniforms.shadow_pass.value=K.mapPass.texture,g.uniforms.resolution.value=K.mapSize,g.uniforms.radius.value=K.radius,e.setRenderTarget(K.map),e.clear(),e.renderBufferDirect(le,null,ge,g,x,null)}function R(K,le,ge){const Le=K<<0|le<<1|ge<<2;let Ae=s[Le];return Ae===void 0&&(Ae=new ii({depthPacking:Bu,morphTargets:K,skinning:le}),s[Le]=Ae),Ae}function F(K,le,ge){const Le=K<<0|le<<1|ge<<2;let Ae=c[Le];return Ae===void 0&&(Ae=new oi({morphTargets:K,skinning:le}),c[Le]=Ae),Ae}function ee(K,le,ge,Le,Ae,xe,Xe){let He=null,tt=R,ft=K.customDepthMaterial;if(Le.isPointLight===!0&&(tt=F,ft=K.customDistanceMaterial),ft===void 0){let ke=!1;ge.morphTargets===!0&&(ke=le.morphAttributes&&le.morphAttributes.position&&le.morphAttributes.position.length>0);let dt=!1;K.isSkinnedMesh===!0&&(ge.skinning===!0?dt=!0:console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:",K)),He=tt(ke,dt,K.isInstancedMesh===!0)}else He=ft;if(e.localClippingEnabled&&ge.clipShadows===!0&&ge.clippingPlanes.length!==0){const ke=He.uuid,dt=ge.uuid;let et=u[ke];et===void 0&&(et={},u[ke]=et);let st=et[dt];st===void 0&&(st=He.clone(),et[dt]=st),He=st}return He.visible=ge.visible,He.wireframe=ge.wireframe,He.side=Xe===Me?ge.shadowSide!==null?ge.shadowSide:ge.side:ge.shadowSide!==null?ge.shadowSide:p[ge.side],He.clipShadows=ge.clipShadows,He.clippingPlanes=ge.clippingPlanes,He.clipIntersection=ge.clipIntersection,He.wireframeLinewidth=ge.wireframeLinewidth,He.linewidth=ge.linewidth,Le.isPointLight===!0&&He.isMeshDistanceMaterial===!0&&(He.referencePosition.setFromMatrixPosition(Le.matrixWorld),He.nearDistance=Ae,He.farDistance=xe),He}function k(K,le,ge,Le,Ae){if(K.visible===!1)return;if(K.layers.test(le.layers)&&(K.isMesh||K.isLine||K.isPoints)&&(K.castShadow||K.receiveShadow&&Ae===Me)&&(!K.frustumCulled||r.intersectsObject(K))){K.modelViewMatrix.multiplyMatrices(ge.matrixWorldInverse,K.matrixWorld);const Xe=t.update(K),He=K.material;if(Array.isArray(He)){const tt=Xe.groups;for(let ft=0,ke=tt.length;ft<ke;ft++){const dt=tt[ft],et=He[dt.materialIndex];if(et&&et.visible){const st=ee(K,Xe,et,Le,ge.near,ge.far,Ae);e.renderBufferDirect(ge,null,Xe,st,K,dt)}}}else if(He.visible){const tt=ee(K,Xe,He,Le,ge.near,ge.far,Ae);e.renderBufferDirect(ge,null,Xe,tt,K,null)}}const xe=K.children;for(let Xe=0,He=xe.length;Xe<He;Xe++)k(xe[Xe],le,ge,Le,Ae)}this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=we,this.render=function(K,le,ge){if(S.enabled===!1)return;if(S.autoUpdate===!1&&S.needsUpdate===!1)return;if(K.length===0)return;const Le=e.getRenderTarget(),Ae=e.getActiveCubeFace(),xe=e.getActiveMipmapLevel(),Xe=e.state;Xe.setBlending(X),Xe.buffers.color.setClear(1,1,1,1),Xe.buffers.depth.setTest(!0),Xe.setScissorTest(!1);for(let He=0,tt=K.length;He<tt;He++){const ft=K[He],ke=ft.shadow;if(ke===void 0){console.warn("THREE.WebGLShadowMap:",ft,"has no shadow.");continue}if(ke.autoUpdate===!1&&ke.needsUpdate===!1)continue;i.copy(ke.mapSize);const dt=ke.getFrameExtents();if(i.multiply(dt),o.copy(ke.mapSize),(i.x>n||i.y>n)&&(i.x>n&&(o.x=Math.floor(n/dt.x),i.x=o.x*dt.x,ke.mapSize.x=o.x),i.y>n&&(o.y=Math.floor(n/dt.y),i.y=o.y*dt.y,ke.mapSize.y=o.y)),ke.map===null&&!ke.isPointLightShadow&&this.type===Me){const st={minFilter:se,magFilter:se,format:In};ke.map=new Kn(i.x,i.y,st),ke.map.texture.name=ft.name+".shadowMap",ke.mapPass=new Kn(i.x,i.y,st),ke.camera.updateProjectionMatrix()}if(ke.map===null){const st={minFilter:y,magFilter:y,format:In};ke.map=new Kn(i.x,i.y,st),ke.map.texture.name=ft.name+".shadowMap",ke.camera.updateProjectionMatrix()}e.setRenderTarget(ke.map),e.clear();const et=ke.getViewportCount();for(let st=0;st<et;st++){const Mt=ke.getViewport(st);a.set(o.x*Mt.x,o.y*Mt.y,o.x*Mt.z,o.y*Mt.w),Xe.viewport(a),ke.updateMatrices(ft,st),r=ke.getFrustum(),k(le,ge,ke.camera,ft,this.type)}ke.isPointLightShadow||this.type!==Me||b(ke,ge),ke.needsUpdate=!1}S.needsUpdate=!1,e.setRenderTarget(Le,Ae,xe)}}function im(e,t,n){const r=n.isWebGL2,i=new function(){let ne=!1;const je=new nn;let De=null;const Ge=new nn(0,0,0,0);return{setMask:function(Ie){De===Ie||ne||(e.colorMask(Ie,Ie,Ie,Ie),De=Ie)},setLocked:function(Ie){ne=Ie},setClear:function(Ie,ct,nt,wt,xt){xt===!0&&(Ie*=wt,ct*=wt,nt*=wt),je.set(Ie,ct,nt,wt),Ge.equals(je)===!1&&(e.clearColor(Ie,ct,nt,wt),Ge.copy(je))},reset:function(){ne=!1,De=null,Ge.set(-1,0,0,0)}}},o=new function(){let ne=!1,je=null,De=null,Ge=null;return{setTest:function(Ie){Ie?et(2929):st(2929)},setMask:function(Ie){je===Ie||ne||(e.depthMask(Ie),je=Ie)},setFunc:function(Ie){if(De!==Ie){if(Ie)switch(Ie){case Yt:e.depthFunc(512);break;case Kt:e.depthFunc(519);break;case Zt:e.depthFunc(513);break;case be:e.depthFunc(515);break;case de:e.depthFunc(514);break;case re:e.depthFunc(518);break;case q:e.depthFunc(516);break;case he:e.depthFunc(517);break;default:e.depthFunc(515)}else e.depthFunc(515);De=Ie}},setLocked:function(Ie){ne=Ie},setClear:function(Ie){Ge!==Ie&&(e.clearDepth(Ie),Ge=Ie)},reset:function(){ne=!1,je=null,De=null,Ge=null}}},a=new function(){let ne=!1,je=null,De=null,Ge=null,Ie=null,ct=null,nt=null,wt=null,xt=null;return{setTest:function(St){ne||(St?et(2960):st(2960))},setMask:function(St){je===St||ne||(e.stencilMask(St),je=St)},setFunc:function(St,jt,Pt){De===St&&Ge===jt&&Ie===Pt||(e.stencilFunc(St,jt,Pt),De=St,Ge=jt,Ie=Pt)},setOp:function(St,jt,Pt){ct===St&&nt===jt&&wt===Pt||(e.stencilOp(St,jt,Pt),ct=St,nt=jt,wt=Pt)},setLocked:function(St){ne=St},setClear:function(St){xt!==St&&(e.clearStencil(St),xt=St)},reset:function(){ne=!1,je=null,De=null,Ge=null,Ie=null,ct=null,nt=null,wt=null,xt=null}}};let s={},c=null,u=null,p=null,d=null,g=null,m=null,x=null,S=null,b=null,R=!1,F=null,ee=null,k=null,K=null,le=null;const ge=e.getParameter(35661);let Le=!1,Ae=0;const xe=e.getParameter(7938);xe.indexOf("WebGL")!==-1?(Ae=parseFloat(/^WebGL\ ([0-9])/.exec(xe)[1]),Le=Ae>=1):xe.indexOf("OpenGL ES")!==-1&&(Ae=parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(xe)[1]),Le=Ae>=2);let Xe=null,He={};const tt=new nn,ft=new nn;function ke(ne,je,De){const Ge=new Uint8Array(4),Ie=e.createTexture();e.bindTexture(ne,Ie),e.texParameteri(ne,10241,9728),e.texParameteri(ne,10240,9728);for(let ct=0;ct<De;ct++)e.texImage2D(je+ct,0,6408,1,1,0,6408,5121,Ge);return Ie}const dt={};function et(ne){s[ne]!==!0&&(e.enable(ne),s[ne]=!0)}function st(ne){s[ne]!==!1&&(e.disable(ne),s[ne]=!1)}dt[3553]=ke(3553,3553,1),dt[34067]=ke(34067,34069,6),i.setClear(0,0,0,1),o.setClear(1),a.setClear(0),et(2929),o.setFunc(be),ce(!1),ve(E),et(2884),Jt(X);const Mt={[Re]:32774,[Ee]:32778,[Ye]:32779};if(r)Mt[Qe]=32775,Mt[lt]=32776;else{const ne=t.get("EXT_blend_minmax");ne!==null&&(Mt[Qe]=ne.MIN_EXT,Mt[lt]=ne.MAX_EXT)}const Dt={[ot]:0,[Ne]:1,[at]:768,[ut]:770,[Tt]:776,[Bt]:774,[Ot]:772,[$e]:769,[pt]:771,[Wt]:775,[It]:773};function Jt(ne,je,De,Ge,Ie,ct,nt,wt){if(ne!==X){if(u||(et(3042),u=!0),ne===Pe)Ie=Ie||je,ct=ct||De,nt=nt||Ge,je===d&&Ie===x||(e.blendEquationSeparate(Mt[je],Mt[Ie]),d=je,x=Ie),De===g&&Ge===m&&ct===S&&nt===b||(e.blendFuncSeparate(Dt[De],Dt[Ge],Dt[ct],Dt[nt]),g=De,m=Ge,S=ct,b=nt),p=ne,R=null;else if(ne!==p||wt!==R){if(d===Re&&x===Re||(e.blendEquation(32774),d=Re,x=Re),wt)switch(ne){case Q:e.blendFuncSeparate(1,771,1,771);break;case oe:e.blendFunc(1,1);break;case me:e.blendFuncSeparate(0,0,769,771);break;case Te:e.blendFuncSeparate(0,768,0,770);break;default:console.error("THREE.WebGLState: Invalid blending: ",ne)}else switch(ne){case Q:e.blendFuncSeparate(770,771,1,771);break;case oe:e.blendFunc(770,1);break;case me:e.blendFunc(0,769);break;case Te:e.blendFunc(0,768);break;default:console.error("THREE.WebGLState: Invalid blending: ",ne)}g=null,m=null,S=null,b=null,p=ne,R=wt}}else u&&(st(3042),u=!1)}function ce(ne){F!==ne&&(ne?e.frontFace(2304):e.frontFace(2305),F=ne)}function ve(ne){ne!==I?(et(2884),ne!==ee&&(ne===E?e.cullFace(1029):ne===U?e.cullFace(1028):e.cullFace(1032))):st(2884),ee=ne}function ht(ne,je,De){ne?(et(32823),K===je&&le===De||(e.polygonOffset(je,De),K=je,le=De)):st(32823)}function Ve(ne){ne===void 0&&(ne=33984+ge-1),Xe!==ne&&(e.activeTexture(ne),Xe=ne)}return{buffers:{color:i,depth:o,stencil:a},enable:et,disable:st,useProgram:function(ne){return c!==ne&&(e.useProgram(ne),c=ne,!0)},setBlending:Jt,setMaterial:function(ne,je){ne.side===J?st(2884):et(2884);let De=ne.side===Z;je&&(De=!De),ce(De),ne.blending===Q&&ne.transparent===!1?Jt(X):Jt(ne.blending,ne.blendEquation,ne.blendSrc,ne.blendDst,ne.blendEquationAlpha,ne.blendSrcAlpha,ne.blendDstAlpha,ne.premultipliedAlpha),o.setFunc(ne.depthFunc),o.setTest(ne.depthTest),o.setMask(ne.depthWrite),i.setMask(ne.colorWrite);const Ge=ne.stencilWrite;a.setTest(Ge),Ge&&(a.setMask(ne.stencilWriteMask),a.setFunc(ne.stencilFunc,ne.stencilRef,ne.stencilFuncMask),a.setOp(ne.stencilFail,ne.stencilZFail,ne.stencilZPass)),ht(ne.polygonOffset,ne.polygonOffsetFactor,ne.polygonOffsetUnits)},setFlipSided:ce,setCullFace:ve,setLineWidth:function(ne){ne!==k&&(Le&&e.lineWidth(ne),k=ne)},setPolygonOffset:ht,setScissorTest:function(ne){ne?et(3089):st(3089)},activeTexture:Ve,bindTexture:function(ne,je){Xe===null&&Ve();let De=He[Xe];De===void 0&&(De={type:void 0,texture:void 0},He[Xe]=De),De.type===ne&&De.texture===je||(e.bindTexture(ne,je||dt[ne]),De.type=ne,De.texture=je)},unbindTexture:function(){const ne=He[Xe];ne!==void 0&&ne.type!==void 0&&(e.bindTexture(ne.type,null),ne.type=void 0,ne.texture=void 0)},compressedTexImage2D:function(){try{e.compressedTexImage2D.apply(e,arguments)}catch(ne){console.error("THREE.WebGLState:",ne)}},texImage2D:function(){try{e.texImage2D.apply(e,arguments)}catch(ne){console.error("THREE.WebGLState:",ne)}},texImage3D:function(){try{e.texImage3D.apply(e,arguments)}catch(ne){console.error("THREE.WebGLState:",ne)}},scissor:function(ne){tt.equals(ne)===!1&&(e.scissor(ne.x,ne.y,ne.z,ne.w),tt.copy(ne))},viewport:function(ne){ft.equals(ne)===!1&&(e.viewport(ne.x,ne.y,ne.z,ne.w),ft.copy(ne))},reset:function(){s={},Xe=null,He={},c=null,u=null,p=null,d=null,g=null,m=null,x=null,S=null,b=null,R=!1,F=null,ee=null,k=null,K=null,le=null,i.reset(),o.reset(),a.reset()}}}function om(e,t,n,r,i,o,a){const s=i.isWebGL2,c=i.maxTextures,u=i.maxCubemapSize,p=i.maxTextureSize,d=i.maxSamples,g=new WeakMap;let m,x=!1;try{x=typeof OffscreenCanvas!="undefined"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch(ce){}function S(ce,ve){return x?new OffscreenCanvas(ce,ve):document.createElementNS("http://www.w3.org/1999/xhtml","canvas")}function b(ce,ve,ht,Ve){let ne=1;if((ce.width>Ve||ce.height>Ve)&&(ne=Ve/Math.max(ce.width,ce.height)),ne<1||ve===!0){if(typeof HTMLImageElement!="undefined"&&ce instanceof HTMLImageElement||typeof HTMLCanvasElement!="undefined"&&ce instanceof HTMLCanvasElement||typeof ImageBitmap!="undefined"&&ce instanceof ImageBitmap){const je=ve?Ft.floorPowerOfTwo:Math.floor,De=je(ne*ce.width),Ge=je(ne*ce.height);m===void 0&&(m=S(De,Ge));const Ie=ht?S(De,Ge):m;return Ie.width=De,Ie.height=Ge,Ie.getContext("2d").drawImage(ce,0,0,De,Ge),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+ce.width+"x"+ce.height+") to ("+De+"x"+Ge+")."),Ie}return"data"in ce&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+ce.width+"x"+ce.height+")."),ce}return ce}function R(ce){return Ft.isPowerOfTwo(ce.width)&&Ft.isPowerOfTwo(ce.height)}function F(ce,ve){return ce.generateMipmaps&&ve&&ce.minFilter!==y&&ce.minFilter!==se}function ee(ce,ve,ht,Ve){e.generateMipmap(ce),r.get(ve).__maxMipLevel=Math.log(Math.max(ht,Ve))*Math.LOG2E}function k(ce,ve,ht){if(s===!1)return ve;if(ce!==null){if(e[ce]!==void 0)return e[ce];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+ce+"'")}let Ve=ve;return ve===6403&&(ht===5126&&(Ve=33326),ht===5131&&(Ve=33325),ht===5121&&(Ve=33321)),ve===6407&&(ht===5126&&(Ve=34837),ht===5131&&(Ve=34843),ht===5121&&(Ve=32849)),ve===6408&&(ht===5126&&(Ve=34836),ht===5131&&(Ve=34842),ht===5121&&(Ve=32856)),Ve!==33325&&Ve!==33326&&Ve!==34842&&Ve!==34836||t.get("EXT_color_buffer_float"),Ve}function K(ce){return ce===y||ce===_||ce===ie?9728:9729}function le(ce){const ve=ce.target;ve.removeEventListener("dispose",le),function(ht){const Ve=r.get(ht);if(Ve.__webglInit===void 0)return;e.deleteTexture(Ve.__webglTexture),r.remove(ht)}(ve),ve.isVideoTexture&&g.delete(ve),a.memory.textures--}function ge(ce){const ve=ce.target;ve.removeEventListener("dispose",ge),function(ht){const Ve=r.get(ht),ne=r.get(ht.texture);if(!ht)return;if(ne.__webglTexture!==void 0&&e.deleteTexture(ne.__webglTexture),ht.depthTexture&&ht.depthTexture.dispose(),ht.isWebGLCubeRenderTarget)for(let je=0;je<6;je++)e.deleteFramebuffer(Ve.__webglFramebuffer[je]),Ve.__webglDepthbuffer&&e.deleteRenderbuffer(Ve.__webglDepthbuffer[je]);else e.deleteFramebuffer(Ve.__webglFramebuffer),Ve.__webglDepthbuffer&&e.deleteRenderbuffer(Ve.__webglDepthbuffer),Ve.__webglMultisampledFramebuffer&&e.deleteFramebuffer(Ve.__webglMultisampledFramebuffer),Ve.__webglColorRenderbuffer&&e.deleteRenderbuffer(Ve.__webglColorRenderbuffer),Ve.__webglDepthRenderbuffer&&e.deleteRenderbuffer(Ve.__webglDepthRenderbuffer);r.remove(ht.texture),r.remove(ht)}(ve),a.memory.textures--}let Le=0;function Ae(ce,ve){const ht=r.get(ce);if(ce.isVideoTexture&&function(Ve){const ne=a.render.frame;g.get(Ve)!==ne&&(g.set(Ve,ne),Ve.update())}(ce),ce.version>0&&ht.__version!==ce.version){const Ve=ce.image;if(Ve===void 0)console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");else{if(Ve.complete!==!1)return void ke(ht,ce,ve);console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")}}n.activeTexture(33984+ve),n.bindTexture(3553,ht.__webglTexture)}function xe(ce,ve){const ht=r.get(ce);ce.version>0&&ht.__version!==ce.version?function(Ve,ne,je){if(ne.image.length!==6)return;ft(Ve,ne),n.activeTexture(33984+je),n.bindTexture(34067,Ve.__webglTexture),e.pixelStorei(37440,ne.flipY);const De=ne&&(ne.isCompressedTexture||ne.image[0].isCompressedTexture),Ge=ne.image[0]&&ne.image[0].isDataTexture,Ie=[];for(let Pt=0;Pt<6;Pt++)Ie[Pt]=De||Ge?Ge?ne.image[Pt].image:ne.image[Pt]:b(ne.image[Pt],!1,!0,u);const ct=Ie[0],nt=R(ct)||s,wt=o.convert(ne.format),xt=o.convert(ne.type),St=k(ne.internalFormat,wt,xt);let jt;if(tt(34067,ne,nt),De){for(let Pt=0;Pt<6;Pt++){jt=Ie[Pt].mipmaps;for(let un=0;un<jt.length;un++){const hn=jt[un];ne.format!==In&&ne.format!==En?wt!==null?n.compressedTexImage2D(34069+Pt,un,St,hn.width,hn.height,0,hn.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):n.texImage2D(34069+Pt,un,St,hn.width,hn.height,0,wt,xt,hn.data)}}Ve.__maxMipLevel=jt.length-1}else{jt=ne.mipmaps;for(let Pt=0;Pt<6;Pt++)if(Ge){n.texImage2D(34069+Pt,0,St,Ie[Pt].width,Ie[Pt].height,0,wt,xt,Ie[Pt].data);for(let un=0;un<jt.length;un++){const hn=jt[un].image[Pt].image;n.texImage2D(34069+Pt,un+1,St,hn.width,hn.height,0,wt,xt,hn.data)}}else{n.texImage2D(34069+Pt,0,St,wt,xt,Ie[Pt]);for(let un=0;un<jt.length;un++){const hn=jt[un];n.texImage2D(34069+Pt,un+1,St,wt,xt,hn.image[Pt])}}Ve.__maxMipLevel=jt.length}F(ne,nt)&&ee(34067,ne,ct.width,ct.height),Ve.__version=ne.version,ne.onUpdate&&ne.onUpdate(ne)}(ht,ce,ve):(n.activeTexture(33984+ve),n.bindTexture(34067,ht.__webglTexture))}const Xe={[Ce]:10497,[v]:33071,[M]:33648},He={[y]:9728,[_]:9984,[ie]:9986,[se]:9729,[Ue]:9985,[Be]:9987};function tt(ce,ve,ht){ht?(e.texParameteri(ce,10242,Xe[ve.wrapS]),e.texParameteri(ce,10243,Xe[ve.wrapT]),ce!==32879&&ce!==35866||e.texParameteri(ce,32882,Xe[ve.wrapR]),e.texParameteri(ce,10240,He[ve.magFilter]),e.texParameteri(ce,10241,He[ve.minFilter])):(e.texParameteri(ce,10242,33071),e.texParameteri(ce,10243,33071),ce!==32879&&ce!==35866||e.texParameteri(ce,32882,33071),ve.wrapS===v&&ve.wrapT===v||console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),e.texParameteri(ce,10240,K(ve.magFilter)),e.texParameteri(ce,10241,K(ve.minFilter)),ve.minFilter!==y&&ve.minFilter!==se&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."));const Ve=t.get("EXT_texture_filter_anisotropic");if(Ve){if(ve.type===sn&&t.get("OES_texture_float_linear")===null)return;if(ve.type===On&&(s||t.get("OES_texture_half_float_linear"))===null)return;(ve.anisotropy>1||r.get(ve).__currentAnisotropy)&&(e.texParameterf(ce,Ve.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(ve.anisotropy,i.getMaxAnisotropy())),r.get(ve).__currentAnisotropy=ve.anisotropy)}}function ft(ce,ve){ce.__webglInit===void 0&&(ce.__webglInit=!0,ve.addEventListener("dispose",le),ce.__webglTexture=e.createTexture(),a.memory.textures++)}function ke(ce,ve,ht){let Ve=3553;ve.isDataTexture2DArray&&(Ve=35866),ve.isDataTexture3D&&(Ve=32879),ft(ce,ve),n.activeTexture(33984+ht),n.bindTexture(Ve,ce.__webglTexture),e.pixelStorei(37440,ve.flipY),e.pixelStorei(37441,ve.premultiplyAlpha),e.pixelStorei(3317,ve.unpackAlignment);const ne=function(xt){return!s&&(xt.wrapS!==v||xt.wrapT!==v||xt.minFilter!==y&&xt.minFilter!==se)}(ve)&&R(ve.image)===!1,je=b(ve.image,ne,!1,p),De=R(je)||s,Ge=o.convert(ve.format);let Ie,ct=o.convert(ve.type),nt=k(ve.internalFormat,Ge,ct);tt(Ve,ve,De);const wt=ve.mipmaps;if(ve.isDepthTexture)nt=6402,s?nt=ve.type===sn?36012:ve.type===gn?33190:ve.type===Tn?35056:33189:ve.type===sn&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),ve.format===gi&&nt===6402&&ve.type!==Xt&&ve.type!==gn&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),ve.type=Xt,ct=o.convert(ve.type)),ve.format===Wi&&nt===6402&&(nt=34041,ve.type!==Tn&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),ve.type=Tn,ct=o.convert(ve.type))),n.texImage2D(3553,0,nt,je.width,je.height,0,Ge,ct,null);else if(ve.isDataTexture)if(wt.length>0&&De){for(let xt=0,St=wt.length;xt<St;xt++)Ie=wt[xt],n.texImage2D(3553,xt,nt,Ie.width,Ie.height,0,Ge,ct,Ie.data);ve.generateMipmaps=!1,ce.__maxMipLevel=wt.length-1}else n.texImage2D(3553,0,nt,je.width,je.height,0,Ge,ct,je.data),ce.__maxMipLevel=0;else if(ve.isCompressedTexture){for(let xt=0,St=wt.length;xt<St;xt++)Ie=wt[xt],ve.format!==In&&ve.format!==En?Ge!==null?n.compressedTexImage2D(3553,xt,nt,Ie.width,Ie.height,0,Ie.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):n.texImage2D(3553,xt,nt,Ie.width,Ie.height,0,Ge,ct,Ie.data);ce.__maxMipLevel=wt.length-1}else if(ve.isDataTexture2DArray)n.texImage3D(35866,0,nt,je.width,je.height,je.depth,0,Ge,ct,je.data),ce.__maxMipLevel=0;else if(ve.isDataTexture3D)n.texImage3D(32879,0,nt,je.width,je.height,je.depth,0,Ge,ct,je.data),ce.__maxMipLevel=0;else if(wt.length>0&&De){for(let xt=0,St=wt.length;xt<St;xt++)Ie=wt[xt],n.texImage2D(3553,xt,nt,Ge,ct,Ie);ve.generateMipmaps=!1,ce.__maxMipLevel=wt.length-1}else n.texImage2D(3553,0,nt,Ge,ct,je),ce.__maxMipLevel=0;F(ve,De)&&ee(Ve,ve,je.width,je.height),ce.__version=ve.version,ve.onUpdate&&ve.onUpdate(ve)}function dt(ce,ve,ht,Ve){const ne=o.convert(ve.texture.format),je=o.convert(ve.texture.type),De=k(ve.texture.internalFormat,ne,je);n.texImage2D(Ve,0,De,ve.width,ve.height,0,ne,je,null),e.bindFramebuffer(36160,ce),e.framebufferTexture2D(36160,ht,Ve,r.get(ve.texture).__webglTexture,0),e.bindFramebuffer(36160,null)}function et(ce,ve,ht){if(e.bindRenderbuffer(36161,ce),ve.depthBuffer&&!ve.stencilBuffer){let Ve=33189;if(ht){const ne=ve.depthTexture;ne&&ne.isDepthTexture&&(ne.type===sn?Ve=36012:ne.type===gn&&(Ve=33190));const je=Mt(ve);e.renderbufferStorageMultisample(36161,je,Ve,ve.width,ve.height)}else e.renderbufferStorage(36161,Ve,ve.width,ve.height);e.framebufferRenderbuffer(36160,36096,36161,ce)}else if(ve.depthBuffer&&ve.stencilBuffer){if(ht){const Ve=Mt(ve);e.renderbufferStorageMultisample(36161,Ve,35056,ve.width,ve.height)}else e.renderbufferStorage(36161,34041,ve.width,ve.height);e.framebufferRenderbuffer(36160,33306,36161,ce)}else{const Ve=o.convert(ve.texture.format),ne=o.convert(ve.texture.type),je=k(ve.texture.internalFormat,Ve,ne);if(ht){const De=Mt(ve);e.renderbufferStorageMultisample(36161,De,je,ve.width,ve.height)}else e.renderbufferStorage(36161,je,ve.width,ve.height)}e.bindRenderbuffer(36161,null)}function st(ce){const ve=r.get(ce),ht=ce.isWebGLCubeRenderTarget===!0;if(ce.depthTexture){if(ht)throw new Error("target.depthTexture not supported in Cube render targets");!function(Ve,ne){if(ne&&ne.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(e.bindFramebuffer(36160,Ve),!ne.depthTexture||!ne.depthTexture.isDepthTexture)throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");r.get(ne.depthTexture).__webglTexture&&ne.depthTexture.image.width===ne.width&&ne.depthTexture.image.height===ne.height||(ne.depthTexture.image.width=ne.width,ne.depthTexture.image.height=ne.height,ne.depthTexture.needsUpdate=!0),Ae(ne.depthTexture,0);const je=r.get(ne.depthTexture).__webglTexture;if(ne.depthTexture.format===gi)e.framebufferTexture2D(36160,36096,3553,je,0);else{if(ne.depthTexture.format!==Wi)throw new Error("Unknown depthTexture format");e.framebufferTexture2D(36160,33306,3553,je,0)}}(ve.__webglFramebuffer,ce)}else if(ht){ve.__webglDepthbuffer=[];for(let Ve=0;Ve<6;Ve++)e.bindFramebuffer(36160,ve.__webglFramebuffer[Ve]),ve.__webglDepthbuffer[Ve]=e.createRenderbuffer(),et(ve.__webglDepthbuffer[Ve],ce,!1)}else e.bindFramebuffer(36160,ve.__webglFramebuffer),ve.__webglDepthbuffer=e.createRenderbuffer(),et(ve.__webglDepthbuffer,ce,!1);e.bindFramebuffer(36160,null)}function Mt(ce){return s&&ce.isWebGLMultisampleRenderTarget?Math.min(d,ce.samples):0}let Dt=!1,Jt=!1;this.allocateTextureUnit=function(){const ce=Le;return ce>=c&&console.warn("THREE.WebGLTextures: Trying to use "+ce+" texture units while this GPU supports only "+c),Le+=1,ce},this.resetTextureUnits=function(){Le=0},this.setTexture2D=Ae,this.setTexture2DArray=function(ce,ve){const ht=r.get(ce);ce.version>0&&ht.__version!==ce.version?ke(ht,ce,ve):(n.activeTexture(33984+ve),n.bindTexture(35866,ht.__webglTexture))},this.setTexture3D=function(ce,ve){const ht=r.get(ce);ce.version>0&&ht.__version!==ce.version?ke(ht,ce,ve):(n.activeTexture(33984+ve),n.bindTexture(32879,ht.__webglTexture))},this.setTextureCube=xe,this.setupRenderTarget=function(ce){const ve=r.get(ce),ht=r.get(ce.texture);ce.addEventListener("dispose",ge),ht.__webglTexture=e.createTexture(),a.memory.textures++;const Ve=ce.isWebGLCubeRenderTarget===!0,ne=ce.isWebGLMultisampleRenderTarget===!0,je=R(ce)||s;if(!s||ce.texture.format!==En||ce.texture.type!==sn&&ce.texture.type!==On||(ce.texture.format=In,console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")),Ve){ve.__webglFramebuffer=[];for(let De=0;De<6;De++)ve.__webglFramebuffer[De]=e.createFramebuffer()}else if(ve.__webglFramebuffer=e.createFramebuffer(),ne)if(s){ve.__webglMultisampledFramebuffer=e.createFramebuffer(),ve.__webglColorRenderbuffer=e.createRenderbuffer(),e.bindRenderbuffer(36161,ve.__webglColorRenderbuffer);const De=o.convert(ce.texture.format),Ge=o.convert(ce.texture.type),Ie=k(ce.texture.internalFormat,De,Ge),ct=Mt(ce);e.renderbufferStorageMultisample(36161,ct,Ie,ce.width,ce.height),e.bindFramebuffer(36160,ve.__webglMultisampledFramebuffer),e.framebufferRenderbuffer(36160,36064,36161,ve.__webglColorRenderbuffer),e.bindRenderbuffer(36161,null),ce.depthBuffer&&(ve.__webglDepthRenderbuffer=e.createRenderbuffer(),et(ve.__webglDepthRenderbuffer,ce,!0)),e.bindFramebuffer(36160,null)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");if(Ve){n.bindTexture(34067,ht.__webglTexture),tt(34067,ce.texture,je);for(let De=0;De<6;De++)dt(ve.__webglFramebuffer[De],ce,36064,34069+De);F(ce.texture,je)&&ee(34067,ce.texture,ce.width,ce.height),n.bindTexture(34067,null)}else n.bindTexture(3553,ht.__webglTexture),tt(3553,ce.texture,je),dt(ve.__webglFramebuffer,ce,36064,3553),F(ce.texture,je)&&ee(3553,ce.texture,ce.width,ce.height),n.bindTexture(3553,null);ce.depthBuffer&&st(ce)},this.updateRenderTargetMipmap=function(ce){const ve=ce.texture;if(F(ve,R(ce)||s)){const ht=ce.isWebGLCubeRenderTarget?34067:3553,Ve=r.get(ve).__webglTexture;n.bindTexture(ht,Ve),ee(ht,ve,ce.width,ce.height),n.bindTexture(ht,null)}},this.updateMultisampleRenderTarget=function(ce){if(ce.isWebGLMultisampleRenderTarget)if(s){const ve=r.get(ce);e.bindFramebuffer(36008,ve.__webglMultisampledFramebuffer),e.bindFramebuffer(36009,ve.__webglFramebuffer);const ht=ce.width,Ve=ce.height;let ne=16384;ce.depthBuffer&&(ne|=256),ce.stencilBuffer&&(ne|=1024),e.blitFramebuffer(0,0,ht,Ve,0,0,ht,Ve,ne,9728),e.bindFramebuffer(36160,ve.__webglMultisampledFramebuffer)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")},this.safeSetTexture2D=function(ce,ve){ce&&ce.isWebGLRenderTarget&&(Dt===!1&&(console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."),Dt=!0),ce=ce.texture),Ae(ce,ve)},this.safeSetTextureCube=function(ce,ve){ce&&ce.isWebGLCubeRenderTarget&&(Jt===!1&&(console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."),Jt=!0),ce=ce.texture),xe(ce,ve)}}function _h(e,t,n){const r=n.isWebGL2;return{convert:function(i){let o;if(i===bt)return 5121;if(i===Zn)return 32819;if(i===Dn)return 32820;if(i===Cn)return 33635;if(i===on)return 5120;if(i===Qt)return 5122;if(i===Xt)return 5123;if(i===wn)return 5124;if(i===gn)return 5125;if(i===sn)return 5126;if(i===On)return r?5131:(o=t.get("OES_texture_half_float"),o!==null?o.HALF_FLOAT_OES:null);if(i===Jn)return 6406;if(i===En)return 6407;if(i===In)return 6408;if(i===ji)return 6409;if(i===La)return 6410;if(i===gi)return 6402;if(i===Wi)return 34041;if(i===Yl)return 6403;if(i===Zl)return 36244;if(i===Jl)return 33319;if(i===Kl)return 33320;if(i===Ql)return 36248;if(i===$l)return 36249;if(i===Ks||i===Qs||i===$s||i===ec){if(o=t.get("WEBGL_compressed_texture_s3tc"),o===null)return null;if(i===Ks)return o.COMPRESSED_RGB_S3TC_DXT1_EXT;if(i===Qs)return o.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(i===$s)return o.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(i===ec)return o.COMPRESSED_RGBA_S3TC_DXT5_EXT}if(i===tc||i===nc||i===rc||i===ic){if(o=t.get("WEBGL_compressed_texture_pvrtc"),o===null)return null;if(i===tc)return o.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(i===nc)return o.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(i===rc)return o.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(i===ic)return o.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}if(i===eu)return o=t.get("WEBGL_compressed_texture_etc1"),o!==null?o.COMPRESSED_RGB_ETC1_WEBGL:null;if((i===oc||i===ac)&&(o=t.get("WEBGL_compressed_texture_etc"),o!==null)){if(i===oc)return o.COMPRESSED_RGB8_ETC2;if(i===ac)return o.COMPRESSED_RGBA8_ETC2_EAC}return i===tu||i===nu||i===ru||i===iu||i===ou||i===au||i===su||i===cu||i===lu||i===uu||i===hu||i===du||i===pu||i===fu||i===gu||i===vu||i===yu||i===xu||i===bu||i===wu||i===_u||i===Mu||i===Su||i===Tu||i===Eu||i===Au||i===Lu||i===Cu?(o=t.get("WEBGL_compressed_texture_astc"),o!==null?i:null):i===mu?(o=t.get("EXT_texture_compression_bptc"),o!==null?i:null):i===Tn?r?34042:(o=t.get("WEBGL_depth_texture"),o!==null?o.UNSIGNED_INT_24_8_WEBGL:null):void 0}}}function Ka(e=[]){_n.call(this),this.cameras=e}function ai(){At.call(this),this.type="Group"}function Ko(){this._targetRay=null,this._grip=null,this._hand=null}function Mh(e,t){const n=this;let r=null,i=1,o=null,a="local-floor",s=null;const c=[],u=new Map,p=new _n;p.layers.enable(1),p.viewport=new nn;const d=new _n;d.layers.enable(2),d.viewport=new nn;const g=[p,d],m=new Ka;m.layers.enable(1),m.layers.enable(2);let x=null,S=null;function b(Ae){const xe=u.get(Ae.inputSource);xe&&xe.dispatchEvent({type:Ae.type,data:Ae.inputSource})}function R(){u.forEach(function(Ae,xe){Ae.disconnect(xe)}),u.clear(),e.setFramebuffer(null),e.setRenderTarget(e.getRenderTarget()),Le.stop(),n.isPresenting=!1,n.dispatchEvent({type:"sessionend"})}function F(Ae){o=Ae,Le.setContext(r),Le.start(),n.isPresenting=!0,n.dispatchEvent({type:"sessionstart"})}function ee(Ae){const xe=r.inputSources;for(let Xe=0;Xe<c.length;Xe++)u.set(xe[Xe],c[Xe]);for(let Xe=0;Xe<Ae.removed.length;Xe++){const He=Ae.removed[Xe],tt=u.get(He);tt&&(tt.dispatchEvent({type:"disconnected",data:He}),u.delete(He))}for(let Xe=0;Xe<Ae.added.length;Xe++){const He=Ae.added[Xe],tt=u.get(He);tt&&tt.dispatchEvent({type:"connected",data:He})}}this.enabled=!1,this.isPresenting=!1,this.getController=function(Ae){let xe=c[Ae];return xe===void 0&&(xe=new Ko,c[Ae]=xe),xe.getTargetRaySpace()},this.getControllerGrip=function(Ae){let xe=c[Ae];return xe===void 0&&(xe=new Ko,c[Ae]=xe),xe.getGripSpace()},this.getHand=function(Ae){let xe=c[Ae];return xe===void 0&&(xe=new Ko,c[Ae]=xe),xe.getHandSpace()},this.setFramebufferScaleFactor=function(Ae){i=Ae,n.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(Ae){a=Ae,n.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return o},this.getSession=function(){return r},this.setSession=function(Ae){if(r=Ae,r!==null){r.addEventListener("select",b),r.addEventListener("selectstart",b),r.addEventListener("selectend",b),r.addEventListener("squeeze",b),r.addEventListener("squeezestart",b),r.addEventListener("squeezeend",b),r.addEventListener("end",R);const xe=t.getContextAttributes();xe.xrCompatible!==!0&&t.makeXRCompatible();const Xe={antialias:xe.antialias,alpha:xe.alpha,depth:xe.depth,stencil:xe.stencil,framebufferScaleFactor:i},He=new XRWebGLLayer(r,t,Xe);r.updateRenderState({baseLayer:He}),r.requestReferenceSpace(a).then(F),r.addEventListener("inputsourceschange",ee)}};const k=new z,K=new z;function le(Ae,xe){xe===null?Ae.matrixWorld.copy(Ae.matrix):Ae.matrixWorld.multiplyMatrices(xe.matrixWorld,Ae.matrix),Ae.matrixWorldInverse.copy(Ae.matrixWorld).invert()}this.getCamera=function(Ae){m.near=d.near=p.near=Ae.near,m.far=d.far=p.far=Ae.far,x===m.near&&S===m.far||(r.updateRenderState({depthNear:m.near,depthFar:m.far}),x=m.near,S=m.far);const xe=Ae.parent,Xe=m.cameras;le(m,xe);for(let tt=0;tt<Xe.length;tt++)le(Xe[tt],xe);Ae.matrixWorld.copy(m.matrixWorld);const He=Ae.children;for(let tt=0,ft=He.length;tt<ft;tt++)He[tt].updateMatrixWorld(!0);return Xe.length===2?function(tt,ft,ke){k.setFromMatrixPosition(ft.matrixWorld),K.setFromMatrixPosition(ke.matrixWorld);const dt=k.distanceTo(K),et=ft.projectionMatrix.elements,st=ke.projectionMatrix.elements,Mt=et[14]/(et[10]-1),Dt=et[14]/(et[10]+1),Jt=(et[9]+1)/et[5],ce=(et[9]-1)/et[5],ve=(et[8]-1)/et[0],ht=(st[8]+1)/st[0],Ve=Mt*ve,ne=Mt*ht,je=dt/(-ve+ht),De=je*-ve;ft.matrixWorld.decompose(tt.position,tt.quaternion,tt.scale),tt.translateX(De),tt.translateZ(je),tt.matrixWorld.compose(tt.position,tt.quaternion,tt.scale),tt.matrixWorldInverse.copy(tt.matrixWorld).invert();const Ge=Mt+je,Ie=Dt+je,ct=Ve-De,nt=ne+(dt-De),wt=Jt*Dt/Ie*Ge,xt=ce*Dt/Ie*Ge;tt.projectionMatrix.makePerspective(ct,nt,wt,xt,Ge,Ie)}(m,p,d):m.projectionMatrix.copy(p.projectionMatrix),m};let ge=null;const Le=new $u;Le.setAnimationLoop(function(Ae,xe){if(s=xe.getViewerPose(o),s!==null){const He=s.views,tt=r.renderState.baseLayer;e.setFramebuffer(tt.framebuffer);let ft=!1;He.length!==m.cameras.length&&(m.cameras.length=0,ft=!0);for(let ke=0;ke<He.length;ke++){const dt=He[ke],et=tt.getViewport(dt),st=g[ke];st.matrix.fromArray(dt.transform.matrix),st.projectionMatrix.fromArray(dt.projectionMatrix),st.viewport.set(et.x,et.y,et.width,et.height),ke===0&&m.matrix.copy(st.matrix),ft===!0&&m.cameras.push(st)}}const Xe=r.inputSources;for(let He=0;He<c.length;He++){const tt=c[He],ft=Xe[He];tt.update(ft,xe,o)}ge&&ge(Ae,xe)}),this.setAnimationLoop=function(Ae){ge=Ae},this.dispose=function(){}}function am(e){function t(r,i){r.opacity.value=i.opacity,i.color&&r.diffuse.value.copy(i.color),i.emissive&&r.emissive.value.copy(i.emissive).multiplyScalar(i.emissiveIntensity),i.map&&(r.map.value=i.map),i.alphaMap&&(r.alphaMap.value=i.alphaMap),i.specularMap&&(r.specularMap.value=i.specularMap);const o=e.get(i).envMap;if(o){r.envMap.value=o,r.flipEnvMap.value=o.isCubeTexture&&o._needsFlipEnvMap?-1:1,r.reflectivity.value=i.reflectivity,r.refractionRatio.value=i.refractionRatio;const c=e.get(o).__maxMipLevel;c!==void 0&&(r.maxMipLevel.value=c)}let a,s;i.lightMap&&(r.lightMap.value=i.lightMap,r.lightMapIntensity.value=i.lightMapIntensity),i.aoMap&&(r.aoMap.value=i.aoMap,r.aoMapIntensity.value=i.aoMapIntensity),i.map?a=i.map:i.specularMap?a=i.specularMap:i.displacementMap?a=i.displacementMap:i.normalMap?a=i.normalMap:i.bumpMap?a=i.bumpMap:i.roughnessMap?a=i.roughnessMap:i.metalnessMap?a=i.metalnessMap:i.alphaMap?a=i.alphaMap:i.emissiveMap?a=i.emissiveMap:i.clearcoatMap?a=i.clearcoatMap:i.clearcoatNormalMap?a=i.clearcoatNormalMap:i.clearcoatRoughnessMap&&(a=i.clearcoatRoughnessMap),a!==void 0&&(a.isWebGLRenderTarget&&(a=a.texture),a.matrixAutoUpdate===!0&&a.updateMatrix(),r.uvTransform.value.copy(a.matrix)),i.aoMap?s=i.aoMap:i.lightMap&&(s=i.lightMap),s!==void 0&&(s.isWebGLRenderTarget&&(s=s.texture),s.matrixAutoUpdate===!0&&s.updateMatrix(),r.uv2Transform.value.copy(s.matrix))}function n(r,i){r.roughness.value=i.roughness,r.metalness.value=i.metalness,i.roughnessMap&&(r.roughnessMap.value=i.roughnessMap),i.metalnessMap&&(r.metalnessMap.value=i.metalnessMap),i.emissiveMap&&(r.emissiveMap.value=i.emissiveMap),i.bumpMap&&(r.bumpMap.value=i.bumpMap,r.bumpScale.value=i.bumpScale,i.side===Z&&(r.bumpScale.value*=-1)),i.normalMap&&(r.normalMap.value=i.normalMap,r.normalScale.value.copy(i.normalScale),i.side===Z&&r.normalScale.value.negate()),i.displacementMap&&(r.displacementMap.value=i.displacementMap,r.displacementScale.value=i.displacementScale,r.displacementBias.value=i.displacementBias),e.get(i).envMap&&(r.envMapIntensity.value=i.envMapIntensity)}return{refreshFogUniforms:function(r,i){r.fogColor.value.copy(i.color),i.isFog?(r.fogNear.value=i.near,r.fogFar.value=i.far):i.isFogExp2&&(r.fogDensity.value=i.density)},refreshMaterialUniforms:function(r,i,o,a){i.isMeshBasicMaterial?t(r,i):i.isMeshLambertMaterial?(t(r,i),function(s,c){c.emissiveMap&&(s.emissiveMap.value=c.emissiveMap)}(r,i)):i.isMeshToonMaterial?(t(r,i),function(s,c){c.gradientMap&&(s.gradientMap.value=c.gradientMap),c.emissiveMap&&(s.emissiveMap.value=c.emissiveMap),c.bumpMap&&(s.bumpMap.value=c.bumpMap,s.bumpScale.value=c.bumpScale,c.side===Z&&(s.bumpScale.value*=-1)),c.normalMap&&(s.normalMap.value=c.normalMap,s.normalScale.value.copy(c.normalScale),c.side===Z&&s.normalScale.value.negate()),c.displacementMap&&(s.displacementMap.value=c.displacementMap,s.displacementScale.value=c.displacementScale,s.displacementBias.value=c.displacementBias)}(r,i)):i.isMeshPhongMaterial?(t(r,i),function(s,c){s.specular.value.copy(c.specular),s.shininess.value=Math.max(c.shininess,1e-4),c.emissiveMap&&(s.emissiveMap.value=c.emissiveMap),c.bumpMap&&(s.bumpMap.value=c.bumpMap,s.bumpScale.value=c.bumpScale,c.side===Z&&(s.bumpScale.value*=-1)),c.normalMap&&(s.normalMap.value=c.normalMap,s.normalScale.value.copy(c.normalScale),c.side===Z&&s.normalScale.value.negate()),c.displacementMap&&(s.displacementMap.value=c.displacementMap,s.displacementScale.value=c.displacementScale,s.displacementBias.value=c.displacementBias)}(r,i)):i.isMeshStandardMaterial?(t(r,i),i.isMeshPhysicalMaterial?function(s,c){n(s,c),s.reflectivity.value=c.reflectivity,s.clearcoat.value=c.clearcoat,s.clearcoatRoughness.value=c.clearcoatRoughness,c.sheen&&s.sheen.value.copy(c.sheen),c.clearcoatMap&&(s.clearcoatMap.value=c.clearcoatMap),c.clearcoatRoughnessMap&&(s.clearcoatRoughnessMap.value=c.clearcoatRoughnessMap),c.clearcoatNormalMap&&(s.clearcoatNormalScale.value.copy(c.clearcoatNormalScale),s.clearcoatNormalMap.value=c.clearcoatNormalMap,c.side===Z&&s.clearcoatNormalScale.value.negate()),s.transmission.value=c.transmission,c.transmissionMap&&(s.transmissionMap.value=c.transmissionMap)}(r,i):n(r,i)):i.isMeshMatcapMaterial?(t(r,i),function(s,c){c.matcap&&(s.matcap.value=c.matcap),c.bumpMap&&(s.bumpMap.value=c.bumpMap,s.bumpScale.value=c.bumpScale,c.side===Z&&(s.bumpScale.value*=-1)),c.normalMap&&(s.normalMap.value=c.normalMap,s.normalScale.value.copy(c.normalScale),c.side===Z&&s.normalScale.value.negate()),c.displacementMap&&(s.displacementMap.value=c.displacementMap,s.displacementScale.value=c.displacementScale,s.displacementBias.value=c.displacementBias)}(r,i)):i.isMeshDepthMaterial?(t(r,i),function(s,c){c.displacementMap&&(s.displacementMap.value=c.displacementMap,s.displacementScale.value=c.displacementScale,s.displacementBias.value=c.displacementBias)}(r,i)):i.isMeshDistanceMaterial?(t(r,i),function(s,c){c.displacementMap&&(s.displacementMap.value=c.displacementMap,s.displacementScale.value=c.displacementScale,s.displacementBias.value=c.displacementBias),s.referencePosition.value.copy(c.referencePosition),s.nearDistance.value=c.nearDistance,s.farDistance.value=c.farDistance}(r,i)):i.isMeshNormalMaterial?(t(r,i),function(s,c){c.bumpMap&&(s.bumpMap.value=c.bumpMap,s.bumpScale.value=c.bumpScale,c.side===Z&&(s.bumpScale.value*=-1)),c.normalMap&&(s.normalMap.value=c.normalMap,s.normalScale.value.copy(c.normalScale),c.side===Z&&s.normalScale.value.negate()),c.displacementMap&&(s.displacementMap.value=c.displacementMap,s.displacementScale.value=c.displacementScale,s.displacementBias.value=c.displacementBias)}(r,i)):i.isLineBasicMaterial?(function(s,c){s.diffuse.value.copy(c.color),s.opacity.value=c.opacity}(r,i),i.isLineDashedMaterial&&function(s,c){s.dashSize.value=c.dashSize,s.totalSize.value=c.dashSize+c.gapSize,s.scale.value=c.scale}(r,i)):i.isPointsMaterial?function(s,c,u,p){s.diffuse.value.copy(c.color),s.opacity.value=c.opacity,s.size.value=c.size*u,s.scale.value=.5*p,c.map&&(s.map.value=c.map),c.alphaMap&&(s.alphaMap.value=c.alphaMap);let d;c.map?d=c.map:c.alphaMap&&(d=c.alphaMap),d!==void 0&&(d.matrixAutoUpdate===!0&&d.updateMatrix(),s.uvTransform.value.copy(d.matrix))}(r,i,o,a):i.isSpriteMaterial?function(s,c){s.diffuse.value.copy(c.color),s.opacity.value=c.opacity,s.rotation.value=c.rotation,c.map&&(s.map.value=c.map),c.alphaMap&&(s.alphaMap.value=c.alphaMap);let u;c.map?u=c.map:c.alphaMap&&(u=c.alphaMap),u!==void 0&&(u.matrixAutoUpdate===!0&&u.updateMatrix(),s.uvTransform.value.copy(u.matrix))}(r,i):i.isShadowMaterial?(r.color.value.copy(i.color),r.opacity.value=i.opacity):i.isShaderMaterial&&(i.uniformsNeedUpdate=!1)}}}function Qo(e){const t=(e=e||{}).canvas!==void 0?e.canvas:function(){const te=document.createElementNS("http://www.w3.org/1999/xhtml","canvas");return te.style.display="block",te}(),n=e.context!==void 0?e.context:null,r=e.alpha!==void 0&&e.alpha,i=e.depth===void 0||e.depth,o=e.stencil===void 0||e.stencil,a=e.antialias!==void 0&&e.antialias,s=e.premultipliedAlpha===void 0||e.premultipliedAlpha,c=e.preserveDrawingBuffer!==void 0&&e.preserveDrawingBuffer,u=e.powerPreference!==void 0?e.powerPreference:"default",p=e.failIfMajorPerformanceCaveat!==void 0&&e.failIfMajorPerformanceCaveat;let d=null,g=null;this.domElement=t,this.debug={checkShaderErrors:!0},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.gammaFactor=2,this.outputEncoding=Gn,this.physicallyCorrectLights=!1,this.toneMapping=C,this.toneMappingExposure=1,this.maxMorphTargets=8,this.maxMorphNormals=4;const m=this;let x=!1,S=null,b=0,R=0,F=null,ee=null,k=-1,K=null,le=null;const ge=new nn,Le=new nn;let Ae=null,xe=t.width,Xe=t.height,He=1,tt=null,ft=null;const ke=new nn(0,0,xe,Xe),dt=new nn(0,0,xe,Xe);let et=!1;const st=new Yo;let Mt=!1,Dt=!1;const Jt=new Ht,ce=new z,ve={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function ht(){return F===null?He:1}let Ve,ne,je,De,Ge,Ie,ct,nt,wt,xt,St,jt,Pt,un,hn,kn,Ma,Sa,Ta,dr,Hn,gt=n;function Vd(te,qe){for(let ze=0;ze<te.length;ze++){const Ke=te[ze],vt=t.getContext(Ke,qe);if(vt!==null)return vt}return null}try{const te={alpha:r,depth:i,stencil:o,antialias:a,premultipliedAlpha:s,preserveDrawingBuffer:c,powerPreference:u,failIfMajorPerformanceCaveat:p};if(t.addEventListener("webglcontextlost",Xd,!1),t.addEventListener("webglcontextrestored",qd,!1),gt===null){const qe=["webgl2","webgl","experimental-webgl"];if(m.isWebGL1Renderer===!0&&qe.shift(),gt=Vd(qe,te),gt===null)throw Vd(qe)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}gt.getShaderPrecisionFormat===void 0&&(gt.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(te){throw console.error("THREE.WebGLRenderer: "+te.message),te}function jd(){Ve=new Kp(gt),ne=new Yp(gt,Ve,e),ne.isWebGL2===!1&&(Ve.get("WEBGL_depth_texture"),Ve.get("OES_texture_float"),Ve.get("OES_texture_half_float"),Ve.get("OES_texture_half_float_linear"),Ve.get("OES_standard_derivatives"),Ve.get("OES_element_index_uint"),Ve.get("OES_vertex_array_object"),Ve.get("ANGLE_instanced_arrays")),Ve.get("OES_texture_float_linear"),dr=new _h(gt,Ve,ne),je=new im(gt,Ve,ne),je.scissor(Le.copy(dt).multiplyScalar(He).floor()),je.viewport(ge.copy(ke).multiplyScalar(He).floor()),De=new ef(gt),Ge=new Zf,Ie=new om(gt,Ve,je,Ge,ne,dr,De),ct=new Jp(m),nt=new jp(gt,ne),Hn=new Xp(gt,Ve,nt,ne),wt=new Qp(gt,nt,De,Hn),xt=new of(gt,wt,nt,De),Ma=new rf(gt),hn=new Zp(Ge),St=new Yf(m,ct,Ve,ne,Hn,hn),jt=new am(Ge),Pt=new Qf(Ge),un=new rm(Ve,ne),kn=new Wp(m,ct,je,xt,s),Sa=new qp(gt,Ve,De,ne),Ta=new $p(gt,Ve,De,ne),De.programs=St.programs,m.capabilities=ne,m.extensions=Ve,m.properties=Ge,m.renderLists=Pt,m.state=je,m.info=De}jd();const fi=new Mh(m,gt);this.xr=fi;const Wd=new wh(m,xt,ne.maxTextureSize);function Xd(te){te.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),x=!0}function qd(){console.log("THREE.WebGLRenderer: Context Restored."),x=!1,jd()}function Yd(te){const qe=te.target;qe.removeEventListener("dispose",Yd),function(ze){Zd(ze),Ge.remove(ze)}(qe)}function Zd(te){const qe=Ge.get(te).program;qe!==void 0&&St.releaseProgram(qe)}this.shadowMap=Wd,this.getContext=function(){return gt},this.getContextAttributes=function(){return gt.getContextAttributes()},this.forceContextLoss=function(){const te=Ve.get("WEBGL_lose_context");te&&te.loseContext()},this.forceContextRestore=function(){const te=Ve.get("WEBGL_lose_context");te&&te.restoreContext()},this.getPixelRatio=function(){return He},this.setPixelRatio=function(te){te!==void 0&&(He=te,this.setSize(xe,Xe,!1))},this.getSize=function(te){return te===void 0&&(console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"),te=new Je),te.set(xe,Xe)},this.setSize=function(te,qe,ze){fi.isPresenting?console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting."):(xe=te,Xe=qe,t.width=Math.floor(te*He),t.height=Math.floor(qe*He),ze!==!1&&(t.style.width=te+"px",t.style.height=qe+"px"),this.setViewport(0,0,te,qe))},this.getDrawingBufferSize=function(te){return te===void 0&&(console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"),te=new Je),te.set(xe*He,Xe*He).floor()},this.setDrawingBufferSize=function(te,qe,ze){xe=te,Xe=qe,He=ze,t.width=Math.floor(te*ze),t.height=Math.floor(qe*ze),this.setViewport(0,0,te,qe)},this.getCurrentViewport=function(te){return te===void 0&&(console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"),te=new nn),te.copy(ge)},this.getViewport=function(te){return te.copy(ke)},this.setViewport=function(te,qe,ze,Ke){te.isVector4?ke.set(te.x,te.y,te.z,te.w):ke.set(te,qe,ze,Ke),je.viewport(ge.copy(ke).multiplyScalar(He).floor())},this.getScissor=function(te){return te.copy(dt)},this.setScissor=function(te,qe,ze,Ke){te.isVector4?dt.set(te.x,te.y,te.z,te.w):dt.set(te,qe,ze,Ke),je.scissor(Le.copy(dt).multiplyScalar(He).floor())},this.getScissorTest=function(){return et},this.setScissorTest=function(te){je.setScissorTest(et=te)},this.setOpaqueSort=function(te){tt=te},this.setTransparentSort=function(te){ft=te},this.getClearColor=function(){return kn.getClearColor()},this.setClearColor=function(){kn.setClearColor.apply(kn,arguments)},this.getClearAlpha=function(){return kn.getClearAlpha()},this.setClearAlpha=function(){kn.setClearAlpha.apply(kn,arguments)},this.clear=function(te,qe,ze){let Ke=0;(te===void 0||te)&&(Ke|=16384),(qe===void 0||qe)&&(Ke|=256),(ze===void 0||ze)&&(Ke|=1024),gt.clear(Ke)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){t.removeEventListener("webglcontextlost",Xd,!1),t.removeEventListener("webglcontextrestored",qd,!1),Pt.dispose(),un.dispose(),Ge.dispose(),ct.dispose(),xt.dispose(),Hn.dispose(),fi.dispose(),Ea.stop()},this.renderBufferImmediate=function(te,qe){Hn.initAttributes();const ze=Ge.get(te);te.hasPositions&&!ze.position&&(ze.position=gt.createBuffer()),te.hasNormals&&!ze.normal&&(ze.normal=gt.createBuffer()),te.hasUvs&&!ze.uv&&(ze.uv=gt.createBuffer()),te.hasColors&&!ze.color&&(ze.color=gt.createBuffer());const Ke=qe.getAttributes();te.hasPositions&&(gt.bindBuffer(34962,ze.position),gt.bufferData(34962,te.positionArray,35048),Hn.enableAttribute(Ke.position),gt.vertexAttribPointer(Ke.position,3,5126,!1,0,0)),te.hasNormals&&(gt.bindBuffer(34962,ze.normal),gt.bufferData(34962,te.normalArray,35048),Hn.enableAttribute(Ke.normal),gt.vertexAttribPointer(Ke.normal,3,5126,!1,0,0)),te.hasUvs&&(gt.bindBuffer(34962,ze.uv),gt.bufferData(34962,te.uvArray,35048),Hn.enableAttribute(Ke.uv),gt.vertexAttribPointer(Ke.uv,2,5126,!1,0,0)),te.hasColors&&(gt.bindBuffer(34962,ze.color),gt.bufferData(34962,te.colorArray,35048),Hn.enableAttribute(Ke.color),gt.vertexAttribPointer(Ke.color,3,5126,!1,0,0)),Hn.disableUnusedAttributes(),gt.drawArrays(4,0,te.count),te.count=0},this.renderBufferDirect=function(te,qe,ze,Ke,vt,zt){qe===null&&(qe=ve);const Gt=vt.isMesh&&vt.matrixWorld.determinant()<0,$t=$d(te,qe,Ke,vt);je.setMaterial(Ke,Gt);let kt=ze.index;const Mn=ze.attributes.position;if(kt===null){if(Mn===void 0||Mn.count===0)return}else if(kt.count===0)return;let An,Ut=1;Ke.wireframe===!0&&(kt=wt.getWireframeAttribute(ze),Ut=2),(Ke.morphTargets||Ke.morphNormals)&&Ma.update(vt,ze,Ke,$t),Hn.setup(vt,Ke,$t,ze,kt);let xn=Sa;kt!==null&&(An=nt.get(kt),xn=Ta,xn.setIndex(An));const Yr=kt!==null?kt.count:Mn.count,qt=ze.drawRange.start*Ut,Gi=ze.drawRange.count*Ut,or=zt!==null?zt.start*Ut:0,ar=zt!==null?zt.count*Ut:1/0,Sn=Math.max(qt,or),Xl=Math.min(Yr,qt+Gi,or+ar)-1,Yn=Math.max(0,Xl-Sn+1);if(Yn!==0){if(vt.isMesh)Ke.wireframe===!0?(je.setLineWidth(Ke.wireframeLinewidth*ht()),xn.setMode(1)):xn.setMode(4);else if(vt.isLine){let Zr=Ke.linewidth;Zr===void 0&&(Zr=1),je.setLineWidth(Zr*ht()),vt.isLineSegments?xn.setMode(1):vt.isLineLoop?xn.setMode(2):xn.setMode(3)}else vt.isPoints?xn.setMode(0):vt.isSprite&&xn.setMode(4);if(vt.isInstancedMesh)xn.renderInstances(Sn,Yn,vt.count);else if(ze.isInstancedBufferGeometry){const Zr=Math.min(ze.instanceCount,ze._maxInstanceCount);xn.renderInstances(Sn,Yn,Zr)}else xn.render(Sn,Yn)}},this.compile=function(te,qe){g=un.get(te,qe),g.init(),te.traverseVisible(function(Ke){Ke.isLight&&Ke.layers.test(qe.layers)&&(g.pushLight(Ke),Ke.castShadow&&g.pushShadow(Ke))}),g.setupLights(qe);const ze=new WeakMap;te.traverse(function(Ke){const vt=Ke.material;if(vt)if(Array.isArray(vt))for(let zt=0;zt<vt.length;zt++){const Gt=vt[zt];ze.has(Gt)===!1&&(To(Gt,te,Ke),ze.set(Gt))}else ze.has(vt)===!1&&(To(vt,te,Ke),ze.set(vt))})};let Wl=null;const Ea=new $u;function Jd(te,qe,ze,Ke){if(te.visible===!1)return;if(te.layers.test(qe.layers)){if(te.isGroup)ze=te.renderOrder;else if(te.isLOD)te.autoUpdate===!0&&te.update(qe);else if(te.isLight)g.pushLight(te),te.castShadow&&g.pushShadow(te);else if(te.isSprite){if(!te.frustumCulled||st.intersectsSprite(te)){Ke&&ce.setFromMatrixPosition(te.matrixWorld).applyMatrix4(Jt);const zt=xt.update(te),Gt=te.material;Gt.visible&&d.push(te,zt,Gt,ze,ce.z,null)}}else if(te.isImmediateRenderObject)Ke&&ce.setFromMatrixPosition(te.matrixWorld).applyMatrix4(Jt),d.push(te,null,te.material,ze,ce.z,null);else if((te.isMesh||te.isLine||te.isPoints)&&(te.isSkinnedMesh&&te.skeleton.frame!==De.render.frame&&(te.skeleton.update(),te.skeleton.frame=De.render.frame),!te.frustumCulled||st.intersectsObject(te))){Ke&&ce.setFromMatrixPosition(te.matrixWorld).applyMatrix4(Jt);const zt=xt.update(te),Gt=te.material;if(Array.isArray(Gt)){const $t=zt.groups;for(let kt=0,Mn=$t.length;kt<Mn;kt++){const An=$t[kt],Ut=Gt[An.materialIndex];Ut&&Ut.visible&&d.push(te,zt,Ut,ze,ce.z,An)}}else Gt.visible&&d.push(te,zt,Gt,ze,ce.z,null)}}const vt=te.children;for(let zt=0,Gt=vt.length;zt<Gt;zt++)Jd(vt[zt],qe,ze,Ke)}function Kd(te,qe,ze){const Ke=qe.isScene===!0?qe.overrideMaterial:null;for(let vt=0,zt=te.length;vt<zt;vt++){const Gt=te[vt],$t=Gt.object,kt=Gt.geometry,Mn=Ke===null?Gt.material:Ke,An=Gt.group;if(ze.isArrayCamera){le=ze;const Ut=ze.cameras;for(let xn=0,Yr=Ut.length;xn<Yr;xn++){const qt=Ut[xn];$t.layers.test(qt.layers)&&(je.viewport(ge.copy(qt.viewport)),g.setupLights(qt),Qd($t,qe,qt,kt,Mn,An))}}else le=null,Qd($t,qe,ze,kt,Mn,An)}}function Qd(te,qe,ze,Ke,vt,zt){if(te.onBeforeRender(m,qe,ze,Ke,vt,zt),g=un.get(qe,le||ze),te.modelViewMatrix.multiplyMatrices(ze.matrixWorldInverse,te.matrixWorld),te.normalMatrix.getNormalMatrix(te.modelViewMatrix),te.isImmediateRenderObject){const Gt=$d(ze,qe,vt,te);je.setMaterial(vt),Hn.reset(),function($t,kt){$t.render(function(Mn){m.renderBufferImmediate(Mn,kt)})}(te,Gt)}else m.renderBufferDirect(ze,qe,Ke,vt,te,zt);te.onAfterRender(m,qe,ze,Ke,vt,zt),g=un.get(qe,le||ze)}function To(te,qe,ze){qe.isScene!==!0&&(qe=ve);const Ke=Ge.get(te),vt=g.state.lights,zt=g.state.shadowsArray,Gt=vt.state.version,$t=St.getParameters(te,vt.state,zt,qe,ze),kt=St.getProgramCacheKey($t);let Mn=Ke.program,An=!0;if(Mn===void 0)te.addEventListener("dispose",Yd);else if(Mn.cacheKey!==kt)Zd(te);else if(Ke.lightsStateVersion!==Gt)An=!1;else{if($t.shaderID!==void 0){const qt=te.isMeshStandardMaterial?qe.environment:null;return void(Ke.envMap=ct.get(te.envMap||qt))}An=!1}An&&($t.uniforms=St.getUniforms(te),te.onBeforeCompile($t,m),Mn=St.acquireProgram($t,kt),Ke.program=Mn,Ke.uniforms=$t.uniforms,Ke.outputEncoding=$t.outputEncoding);const Ut=Ke.uniforms;(te.isShaderMaterial||te.isRawShaderMaterial)&&te.clipping!==!0||(Ke.numClippingPlanes=hn.numPlanes,Ke.numIntersection=hn.numIntersection,Ut.clippingPlanes=hn.uniform),Ke.environment=te.isMeshStandardMaterial?qe.environment:null,Ke.fog=qe.fog,Ke.envMap=ct.get(te.envMap||Ke.environment),Ke.needsLights=function(qt){return qt.isMeshLambertMaterial||qt.isMeshToonMaterial||qt.isMeshPhongMaterial||qt.isMeshStandardMaterial||qt.isShadowMaterial||qt.isShaderMaterial&&qt.lights===!0}(te),Ke.lightsStateVersion=Gt,Ke.needsLights&&(Ut.ambientLightColor.value=vt.state.ambient,Ut.lightProbe.value=vt.state.probe,Ut.directionalLights.value=vt.state.directional,Ut.directionalLightShadows.value=vt.state.directionalShadow,Ut.spotLights.value=vt.state.spot,Ut.spotLightShadows.value=vt.state.spotShadow,Ut.rectAreaLights.value=vt.state.rectArea,Ut.ltc_1.value=vt.state.rectAreaLTC1,Ut.ltc_2.value=vt.state.rectAreaLTC2,Ut.pointLights.value=vt.state.point,Ut.pointLightShadows.value=vt.state.pointShadow,Ut.hemisphereLights.value=vt.state.hemi,Ut.directionalShadowMap.value=vt.state.directionalShadowMap,Ut.directionalShadowMatrix.value=vt.state.directionalShadowMatrix,Ut.spotShadowMap.value=vt.state.spotShadowMap,Ut.spotShadowMatrix.value=vt.state.spotShadowMatrix,Ut.pointShadowMap.value=vt.state.pointShadowMap,Ut.pointShadowMatrix.value=vt.state.pointShadowMatrix);const xn=Ke.program.getUniforms(),Yr=ri.seqWithValue(xn.seq,Ut);Ke.uniformsList=Yr}function $d(te,qe,ze,Ke){qe.isScene!==!0&&(qe=ve),Ie.resetTextureUnits();const vt=qe.fog,zt=ze.isMeshStandardMaterial?qe.environment:null,Gt=F===null?m.outputEncoding:F.texture.encoding,$t=ct.get(ze.envMap||zt),kt=Ge.get(ze),Mn=g.state.lights;if(Mt===!0&&(Dt===!0||te!==K)){const Sn=te===K&&ze.id===k;hn.setState(ze,te,Sn)}ze.version===kt.__version?ze.fog&&kt.fog!==vt||kt.environment!==zt||kt.needsLights&&kt.lightsStateVersion!==Mn.state.version?To(ze,qe,Ke):kt.numClippingPlanes===void 0||kt.numClippingPlanes===hn.numPlanes&&kt.numIntersection===hn.numIntersection?(kt.outputEncoding!==Gt||kt.envMap!==$t)&&To(ze,qe,Ke):To(ze,qe,Ke):(To(ze,qe,Ke),kt.__version=ze.version);let An=!1,Ut=!1,xn=!1;const Yr=kt.program,qt=Yr.getUniforms(),Gi=kt.uniforms;if(je.useProgram(Yr.program)&&(An=!0,Ut=!0,xn=!0),ze.id!==k&&(k=ze.id,Ut=!0),An||K!==te){if(qt.setValue(gt,"projectionMatrix",te.projectionMatrix),ne.logarithmicDepthBuffer&&qt.setValue(gt,"logDepthBufFC",2/(Math.log(te.far+1)/Math.LN2)),K!==te&&(K=te,Ut=!0,xn=!0),ze.isShaderMaterial||ze.isMeshPhongMaterial||ze.isMeshToonMaterial||ze.isMeshStandardMaterial||ze.envMap){const Sn=qt.map.cameraPosition;Sn!==void 0&&Sn.setValue(gt,ce.setFromMatrixPosition(te.matrixWorld))}(ze.isMeshPhongMaterial||ze.isMeshToonMaterial||ze.isMeshLambertMaterial||ze.isMeshBasicMaterial||ze.isMeshStandardMaterial||ze.isShaderMaterial)&&qt.setValue(gt,"isOrthographic",te.isOrthographicCamera===!0),(ze.isMeshPhongMaterial||ze.isMeshToonMaterial||ze.isMeshLambertMaterial||ze.isMeshBasicMaterial||ze.isMeshStandardMaterial||ze.isShaderMaterial||ze.isShadowMaterial||ze.skinning)&&qt.setValue(gt,"viewMatrix",te.matrixWorldInverse)}if(ze.skinning){qt.setOptional(gt,Ke,"bindMatrix"),qt.setOptional(gt,Ke,"bindMatrixInverse");const Sn=Ke.skeleton;if(Sn){const Xl=Sn.bones;if(ne.floatVertexTextures){if(Sn.boneTexture===null){let Yn=Math.sqrt(4*Xl.length);Yn=Ft.ceilPowerOfTwo(Yn),Yn=Math.max(Yn,4);const Zr=new Float32Array(Yn*Yn*4);Zr.set(Sn.boneMatrices);const Ug=new Vr(Zr,Yn,Yn,In,sn);Sn.boneMatrices=Zr,Sn.boneTexture=Ug,Sn.boneTextureSize=Yn}qt.setValue(gt,"boneTexture",Sn.boneTexture,Ie),qt.setValue(gt,"boneTextureSize",Sn.boneTextureSize)}else qt.setOptional(gt,Sn,"boneMatrices")}}var or,ar;return(Ut||kt.receiveShadow!==Ke.receiveShadow)&&(kt.receiveShadow=Ke.receiveShadow,qt.setValue(gt,"receiveShadow",Ke.receiveShadow)),Ut&&(qt.setValue(gt,"toneMappingExposure",m.toneMappingExposure),kt.needsLights&&(ar=xn,(or=Gi).ambientLightColor.needsUpdate=ar,or.lightProbe.needsUpdate=ar,or.directionalLights.needsUpdate=ar,or.directionalLightShadows.needsUpdate=ar,or.pointLights.needsUpdate=ar,or.pointLightShadows.needsUpdate=ar,or.spotLights.needsUpdate=ar,or.spotLightShadows.needsUpdate=ar,or.rectAreaLights.needsUpdate=ar,or.hemisphereLights.needsUpdate=ar),vt&&ze.fog&&jt.refreshFogUniforms(Gi,vt),jt.refreshMaterialUniforms(Gi,ze,He,Xe),ri.upload(gt,kt.uniformsList,Gi,Ie)),ze.isShaderMaterial&&ze.uniformsNeedUpdate===!0&&(ri.upload(gt,kt.uniformsList,Gi,Ie),ze.uniformsNeedUpdate=!1),ze.isSpriteMaterial&&qt.setValue(gt,"center",Ke.center),qt.setValue(gt,"modelViewMatrix",Ke.modelViewMatrix),qt.setValue(gt,"normalMatrix",Ke.normalMatrix),qt.setValue(gt,"modelMatrix",Ke.matrixWorld),Yr}Ea.setAnimationLoop(function(te){fi.isPresenting||Wl&&Wl(te)}),typeof window!="undefined"&&Ea.setContext(window),this.setAnimationLoop=function(te){Wl=te,fi.setAnimationLoop(te),te===null?Ea.stop():Ea.start()},this.render=function(te,qe){let ze,Ke;if(arguments[2]!==void 0&&(console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."),ze=arguments[2]),arguments[3]!==void 0&&(console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."),Ke=arguments[3]),qe!==void 0&&qe.isCamera!==!0)return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");if(x===!0)return;Hn.resetDefaultState(),k=-1,K=null,te.autoUpdate===!0&&te.updateMatrixWorld(),qe.parent===null&&qe.updateMatrixWorld(),fi.enabled===!0&&fi.isPresenting===!0&&(qe=fi.getCamera(qe)),te.isScene===!0&&te.onBeforeRender(m,te,qe,ze||F),g=un.get(te,qe),g.init(),Jt.multiplyMatrices(qe.projectionMatrix,qe.matrixWorldInverse),st.setFromProjectionMatrix(Jt),Dt=this.localClippingEnabled,Mt=hn.init(this.clippingPlanes,Dt,qe),d=Pt.get(te,qe),d.init(),Jd(te,qe,0,m.sortObjects),d.finish(),m.sortObjects===!0&&d.sort(tt,ft),Mt===!0&&hn.beginShadows();const vt=g.state.shadowsArray;Wd.render(vt,te,qe),g.setupLights(qe),Mt===!0&&hn.endShadows(),this.info.autoReset===!0&&this.info.reset(),ze!==void 0&&this.setRenderTarget(ze),kn.render(d,te,qe,Ke);const zt=d.opaque,Gt=d.transparent;zt.length>0&&Kd(zt,te,qe),Gt.length>0&&Kd(Gt,te,qe),te.isScene===!0&&te.onAfterRender(m,te,qe),F!==null&&(Ie.updateRenderTargetMipmap(F),Ie.updateMultisampleRenderTarget(F)),je.buffers.depth.setTest(!0),je.buffers.depth.setMask(!0),je.buffers.color.setMask(!0),je.setPolygonOffset(!1),d=null,g=null},this.setFramebuffer=function(te){S!==te&&F===null&&gt.bindFramebuffer(36160,te),S=te},this.getActiveCubeFace=function(){return b},this.getActiveMipmapLevel=function(){return R},this.getRenderList=function(){return d},this.setRenderList=function(te){d=te},this.getRenderState=function(){return g},this.setRenderState=function(te){g=te},this.getRenderTarget=function(){return F},this.setRenderTarget=function(te,qe=0,ze=0){F=te,b=qe,R=ze,te&&Ge.get(te).__webglFramebuffer===void 0&&Ie.setupRenderTarget(te);let Ke=S,vt=!1;if(te){const zt=Ge.get(te).__webglFramebuffer;te.isWebGLCubeRenderTarget?(Ke=zt[qe],vt=!0):Ke=te.isWebGLMultisampleRenderTarget?Ge.get(te).__webglMultisampledFramebuffer:zt,ge.copy(te.viewport),Le.copy(te.scissor),Ae=te.scissorTest}else ge.copy(ke).multiplyScalar(He).floor(),Le.copy(dt).multiplyScalar(He).floor(),Ae=et;if(ee!==Ke&&(gt.bindFramebuffer(36160,Ke),ee=Ke),je.viewport(ge),je.scissor(Le),je.setScissorTest(Ae),vt){const zt=Ge.get(te.texture);gt.framebufferTexture2D(36160,36064,34069+qe,zt.__webglTexture,ze)}},this.readRenderTargetPixels=function(te,qe,ze,Ke,vt,zt,Gt){if(!te||!te.isWebGLRenderTarget)return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");let $t=Ge.get(te).__webglFramebuffer;if(te.isWebGLCubeRenderTarget&&Gt!==void 0&&($t=$t[Gt]),$t){let kt=!1;$t!==ee&&(gt.bindFramebuffer(36160,$t),kt=!0);try{const Mn=te.texture,An=Mn.format,Ut=Mn.type;if(An!==In&&dr.convert(An)!==gt.getParameter(35739))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");if(!(Ut===bt||dr.convert(Ut)===gt.getParameter(35738)||Ut===sn&&(ne.isWebGL2||Ve.get("OES_texture_float")||Ve.get("WEBGL_color_buffer_float"))||Ut===On&&(ne.isWebGL2?Ve.get("EXT_color_buffer_float"):Ve.get("EXT_color_buffer_half_float"))))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");gt.checkFramebufferStatus(36160)===36053?qe>=0&&qe<=te.width-Ke&&ze>=0&&ze<=te.height-vt&&gt.readPixels(qe,ze,Ke,vt,dr.convert(An),dr.convert(Ut),zt):console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")}finally{kt&&gt.bindFramebuffer(36160,ee)}}},this.copyFramebufferToTexture=function(te,qe,ze=0){const Ke=Math.pow(2,-ze),vt=Math.floor(qe.image.width*Ke),zt=Math.floor(qe.image.height*Ke),Gt=dr.convert(qe.format);Ie.setTexture2D(qe,0),gt.copyTexImage2D(3553,ze,Gt,te.x,te.y,vt,zt,0),je.unbindTexture()},this.copyTextureToTexture=function(te,qe,ze,Ke=0){const vt=qe.image.width,zt=qe.image.height,Gt=dr.convert(ze.format),$t=dr.convert(ze.type);Ie.setTexture2D(ze,0),gt.pixelStorei(37440,ze.flipY),gt.pixelStorei(37441,ze.premultiplyAlpha),gt.pixelStorei(3317,ze.unpackAlignment),qe.isDataTexture?gt.texSubImage2D(3553,Ke,te.x,te.y,vt,zt,Gt,$t,qe.image.data):qe.isCompressedTexture?gt.compressedTexSubImage2D(3553,Ke,te.x,te.y,qe.mipmaps[0].width,qe.mipmaps[0].height,Gt,qe.mipmaps[0].data):gt.texSubImage2D(3553,Ke,te.x,te.y,Gt,$t,qe.image),Ke===0&&ze.generateMipmaps&&gt.generateMipmap(3553),je.unbindTexture()},this.initTexture=function(te){Ie.setTexture2D(te,0),je.unbindTexture()},typeof __THREE_DEVTOOLS__!="undefined"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}function Bc(e){Qo.call(this,e)}Ka.prototype=Object.assign(Object.create(_n.prototype),{constructor:Ka,isArrayCamera:!0}),ai.prototype=Object.assign(Object.create(At.prototype),{constructor:ai,isGroup:!0}),Object.assign(Ko.prototype,{constructor:Ko,getHandSpace:function(){if(this._hand===null&&(this._hand=new ai,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints=[],this._hand.inputState={pinching:!1},window.XRHand))for(let e=0;e<=window.XRHand.LITTLE_PHALANX_TIP;e++){const t=new ai;t.matrixAutoUpdate=!1,t.visible=!1,this._hand.joints.push(t),this._hand.add(t)}return this._hand},getTargetRaySpace:function(){return this._targetRay===null&&(this._targetRay=new ai,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1),this._targetRay},getGripSpace:function(){return this._grip===null&&(this._grip=new ai,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1),this._grip},dispatchEvent:function(e){return this._targetRay!==null&&this._targetRay.dispatchEvent(e),this._grip!==null&&this._grip.dispatchEvent(e),this._hand!==null&&this._hand.dispatchEvent(e),this},disconnect:function(e){return this.dispatchEvent({type:"disconnected",data:e}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this},update:function(e,t,n){let r=null,i=null,o=null;const a=this._targetRay,s=this._grip,c=this._hand;if(e&&t.session.visibilityState!=="visible-blurred")if(c&&e.hand){o=!0;for(let u=0;u<=window.XRHand.LITTLE_PHALANX_TIP;u++)if(e.hand[u]){const p=t.getJointPose(e.hand[u],n),d=c.joints[u];p!==null&&(d.matrix.fromArray(p.transform.matrix),d.matrix.decompose(d.position,d.rotation,d.scale),d.jointRadius=p.radius),d.visible=p!==null;const g=c.joints[window.XRHand.INDEX_PHALANX_TIP],m=c.joints[window.XRHand.THUMB_PHALANX_TIP],x=g.position.distanceTo(m.position),S=.02,b=.005;c.inputState.pinching&&x>S+b?(c.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:e.handedness,target:this})):!c.inputState.pinching&&x<=S-b&&(c.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:e.handedness,target:this}))}}else a!==null&&(r=t.getPose(e.targetRaySpace,n),r!==null&&(a.matrix.fromArray(r.transform.matrix),a.matrix.decompose(a.position,a.rotation,a.scale))),s!==null&&e.gripSpace&&(i=t.getPose(e.gripSpace,n),i!==null&&(s.matrix.fromArray(i.transform.matrix),s.matrix.decompose(s.position,s.rotation,s.scale)));return a!==null&&(a.visible=r!==null),s!==null&&(s.visible=i!==null),c!==null&&(c.visible=o!==null),this}}),Object.assign(Mh.prototype,Sr.prototype),Bc.prototype=Object.assign(Object.create(Qo.prototype),{constructor:Bc,isWebGL1Renderer:!0});class Fc{constructor(e,t){Object.defineProperty(this,"isFogExp2",{value:!0}),this.name="",this.color=new _t(e),this.density=t!==void 0?t:25e-5}clone(){return new Fc(this.color,this.density)}toJSON(){return{type:"FogExp2",color:this.color.getHex(),density:this.density}}}class Uc{constructor(e,t,n){Object.defineProperty(this,"isFog",{value:!0}),this.name="",this.color=new _t(e),this.near=t!==void 0?t:1,this.far=n!==void 0?n:1e3}clone(){return new Uc(this.color,this.near,this.far)}toJSON(){return{type:"Fog",color:this.color.getHex(),near:this.near,far:this.far}}}class zc extends At{constructor(){super(),Object.defineProperty(this,"isScene",{value:!0}),this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.overrideMaterial=null,this.autoUpdate=!0,typeof __THREE_DEVTOOLS__!="undefined"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(e,t){return super.copy(e,t),e.background!==null&&(this.background=e.background.clone()),e.environment!==null&&(this.environment=e.environment.clone()),e.fog!==null&&(this.fog=e.fog.clone()),e.overrideMaterial!==null&&(this.overrideMaterial=e.overrideMaterial.clone()),this.autoUpdate=e.autoUpdate,this.matrixAutoUpdate=e.matrixAutoUpdate,this}toJSON(e){const t=super.toJSON(e);return this.background!==null&&(t.object.background=this.background.toJSON(e)),this.environment!==null&&(t.object.environment=this.environment.toJSON(e)),this.fog!==null&&(t.object.fog=this.fog.toJSON()),t}}function tr(e,t){this.array=e,this.stride=t,this.count=e!==void 0?e.length/t:0,this.usage=Ro,this.updateRange={offset:0,count:-1},this.version=0,this.uuid=Ft.generateUUID()}Object.defineProperty(tr.prototype,"needsUpdate",{set:function(e){e===!0&&this.version++}}),Object.assign(tr.prototype,{isInterleavedBuffer:!0,onUploadCallback:function(){},setUsage:function(e){return this.usage=e,this},copy:function(e){return this.array=new e.array.constructor(e.array),this.count=e.count,this.stride=e.stride,this.usage=e.usage,this},copyAt:function(e,t,n){e*=this.stride,n*=t.stride;for(let r=0,i=this.stride;r<i;r++)this.array[e+r]=t.array[n+r];return this},set:function(e,t=0){return this.array.set(e,t),this},clone:function(e){e.arrayBuffers===void 0&&(e.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=Ft.generateUUID()),e.arrayBuffers[this.array.buffer._uuid]===void 0&&(e.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const t=new tr(new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),this.stride);return t.setUsage(this.usage),t},onUpload:function(e){return this.onUploadCallback=e,this},toJSON:function(e){return e.arrayBuffers===void 0&&(e.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=Ft.generateUUID()),e.arrayBuffers[this.array.buffer._uuid]===void 0&&(e.arrayBuffers[this.array.buffer._uuid]=Array.prototype.slice.call(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}});const Li=new z;function si(e,t,n,r){this.name="",this.data=e,this.itemSize=t,this.offset=n,this.normalized=r===!0}function ci(e){Nt.call(this),this.type="SpriteMaterial",this.color=new _t(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.setValues(e)}let uo;Object.defineProperties(si.prototype,{count:{get:function(){return this.data.count}},array:{get:function(){return this.data.array}},needsUpdate:{set:function(e){this.data.needsUpdate=e}}}),Object.assign(si.prototype,{isInterleavedBufferAttribute:!0,applyMatrix4:function(e){for(let t=0,n=this.data.count;t<n;t++)Li.x=this.getX(t),Li.y=this.getY(t),Li.z=this.getZ(t),Li.applyMatrix4(e),this.setXYZ(t,Li.x,Li.y,Li.z);return this},setX:function(e,t){return this.data.array[e*this.data.stride+this.offset]=t,this},setY:function(e,t){return this.data.array[e*this.data.stride+this.offset+1]=t,this},setZ:function(e,t){return this.data.array[e*this.data.stride+this.offset+2]=t,this},setW:function(e,t){return this.data.array[e*this.data.stride+this.offset+3]=t,this},getX:function(e){return this.data.array[e*this.data.stride+this.offset]},getY:function(e){return this.data.array[e*this.data.stride+this.offset+1]},getZ:function(e){return this.data.array[e*this.data.stride+this.offset+2]},getW:function(e){return this.data.array[e*this.data.stride+this.offset+3]},setXY:function(e,t,n){return e=e*this.data.stride+this.offset,this.data.array[e+0]=t,this.data.array[e+1]=n,this},setXYZ:function(e,t,n,r){return e=e*this.data.stride+this.offset,this.data.array[e+0]=t,this.data.array[e+1]=n,this.data.array[e+2]=r,this},setXYZW:function(e,t,n,r,i){return e=e*this.data.stride+this.offset,this.data.array[e+0]=t,this.data.array[e+1]=n,this.data.array[e+2]=r,this.data.array[e+3]=i,this},clone:function(e){if(e===void 0){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");const t=[];for(let n=0;n<this.count;n++){const r=n*this.data.stride+this.offset;for(let i=0;i<this.itemSize;i++)t.push(this.data.array[r+i])}return new Rt(new this.array.constructor(t),this.itemSize,this.normalized)}return e.interleavedBuffers===void 0&&(e.interleavedBuffers={}),e.interleavedBuffers[this.data.uuid]===void 0&&(e.interleavedBuffers[this.data.uuid]=this.data.clone(e)),new si(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)},toJSON:function(e){if(e===void 0){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");const t=[];for(let n=0;n<this.count;n++){const r=n*this.data.stride+this.offset;for(let i=0;i<this.itemSize;i++)t.push(this.data.array[r+i])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:t,normalized:this.normalized}}return e.interleavedBuffers===void 0&&(e.interleavedBuffers={}),e.interleavedBuffers[this.data.uuid]===void 0&&(e.interleavedBuffers[this.data.uuid]=this.data.toJSON(e)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}),ci.prototype=Object.create(Nt.prototype),ci.prototype.constructor=ci,ci.prototype.isSpriteMaterial=!0,ci.prototype.copy=function(e){return Nt.prototype.copy.call(this,e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.rotation=e.rotation,this.sizeAttenuation=e.sizeAttenuation,this};const $o=new z,ho=new z,po=new z,fo=new Je,ea=new Je,Sh=new Ht,Qa=new z,ta=new z,$a=new z,Th=new Je,kc=new Je,Eh=new Je;function na(e){if(At.call(this),this.type="Sprite",uo===void 0){uo=new Ct;const t=new tr(new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),5);uo.setIndex([0,1,2,0,2,3]),uo.setAttribute("position",new si(t,3,0,!1)),uo.setAttribute("uv",new si(t,2,3,!1))}this.geometry=uo,this.material=e!==void 0?e:new ci,this.center=new Je(.5,.5)}function es(e,t,n,r,i,o){fo.subVectors(e,n).addScalar(.5).multiply(r),i!==void 0?(ea.x=o*fo.x-i*fo.y,ea.y=i*fo.x+o*fo.y):ea.copy(fo),e.copy(t),e.x+=ea.x,e.y+=ea.y,e.applyMatrix4(Sh)}na.prototype=Object.assign(Object.create(At.prototype),{constructor:na,isSprite:!0,raycast:function(e,t){e.camera===null&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),ho.setFromMatrixScale(this.matrixWorld),Sh.copy(e.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse,this.matrixWorld),po.setFromMatrixPosition(this.modelViewMatrix),e.camera.isPerspectiveCamera&&this.material.sizeAttenuation===!1&&ho.multiplyScalar(-po.z);const n=this.material.rotation;let r,i;n!==0&&(i=Math.cos(n),r=Math.sin(n));const o=this.center;es(Qa.set(-.5,-.5,0),po,o,ho,r,i),es(ta.set(.5,-.5,0),po,o,ho,r,i),es($a.set(.5,.5,0),po,o,ho,r,i),Th.set(0,0),kc.set(1,0),Eh.set(1,1);let a=e.ray.intersectTriangle(Qa,ta,$a,!1,$o);if(a===null&&(es(ta.set(-.5,.5,0),po,o,ho,r,i),kc.set(0,1),a=e.ray.intersectTriangle(Qa,$a,ta,!1,$o),a===null))return;const s=e.ray.origin.distanceTo($o);s<e.near||s>e.far||t.push({distance:s,point:$o.clone(),uv:Bn.getUV($o,Qa,ta,$a,Th,kc,Eh,new Je),face:null,object:this})},copy:function(e){return At.prototype.copy.call(this,e),e.center!==void 0&&this.center.copy(e.center),this.material=e.material,this}});const ts=new z,Ah=new z;function ra(){At.call(this),this._currentLevel=0,this.type="LOD",Object.defineProperties(this,{levels:{enumerable:!0,value:[]}}),this.autoUpdate=!0}function ia(e,t){e&&e.isGeometry&&console.error("THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."),pn.call(this,e,t),this.type="SkinnedMesh",this.bindMode="attached",this.bindMatrix=new Ht,this.bindMatrixInverse=new Ht}function oa(){At.call(this),this.type="Bone"}ra.prototype=Object.assign(Object.create(At.prototype),{constructor:ra,isLOD:!0,copy:function(e){At.prototype.copy.call(this,e,!1);const t=e.levels;for(let n=0,r=t.length;n<r;n++){const i=t[n];this.addLevel(i.object.clone(),i.distance)}return this.autoUpdate=e.autoUpdate,this},addLevel:function(e,t=0){t=Math.abs(t);const n=this.levels;let r;for(r=0;r<n.length&&!(t<n[r].distance);r++);return n.splice(r,0,{distance:t,object:e}),this.add(e),this},getCurrentLevel:function(){return this._currentLevel},getObjectForDistance:function(e){const t=this.levels;if(t.length>0){let n,r;for(n=1,r=t.length;n<r&&!(e<t[n].distance);n++);return t[n-1].object}return null},raycast:function(e,t){if(this.levels.length>0){ts.setFromMatrixPosition(this.matrixWorld);const n=e.ray.origin.distanceTo(ts);this.getObjectForDistance(n).raycast(e,t)}},update:function(e){const t=this.levels;if(t.length>1){ts.setFromMatrixPosition(e.matrixWorld),Ah.setFromMatrixPosition(this.matrixWorld);const n=ts.distanceTo(Ah)/e.zoom;let r,i;for(t[0].object.visible=!0,r=1,i=t.length;r<i&&n>=t[r].distance;r++)t[r-1].object.visible=!1,t[r].object.visible=!0;for(this._currentLevel=r-1;r<i;r++)t[r].object.visible=!1}},toJSON:function(e){const t=At.prototype.toJSON.call(this,e);this.autoUpdate===!1&&(t.object.autoUpdate=!1),t.object.levels=[];const n=this.levels;for(let r=0,i=n.length;r<i;r++){const o=n[r];t.object.levels.push({object:o.object.uuid,distance:o.distance})}return t}}),ia.prototype=Object.assign(Object.create(pn.prototype),{constructor:ia,isSkinnedMesh:!0,copy:function(e){return pn.prototype.copy.call(this,e),this.bindMode=e.bindMode,this.bindMatrix.copy(e.bindMatrix),this.bindMatrixInverse.copy(e.bindMatrixInverse),this.skeleton=e.skeleton,this},bind:function(e,t){this.skeleton=e,t===void 0&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),t=this.matrixWorld),this.bindMatrix.copy(t),this.bindMatrixInverse.copy(t).invert()},pose:function(){this.skeleton.pose()},normalizeSkinWeights:function(){const e=new nn,t=this.geometry.attributes.skinWeight;for(let n=0,r=t.count;n<r;n++){e.x=t.getX(n),e.y=t.getY(n),e.z=t.getZ(n),e.w=t.getW(n);const i=1/e.manhattanLength();i!==1/0?e.multiplyScalar(i):e.set(1,0,0,0),t.setXYZW(n,e.x,e.y,e.z,e.w)}},updateMatrixWorld:function(e){pn.prototype.updateMatrixWorld.call(this,e),this.bindMode==="attached"?this.bindMatrixInverse.copy(this.matrixWorld).invert():this.bindMode==="detached"?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)},boneTransform:function(){const e=new z,t=new nn,n=new nn,r=new z,i=new Ht;return function(o,a){const s=this.skeleton,c=this.geometry;t.fromBufferAttribute(c.attributes.skinIndex,o),n.fromBufferAttribute(c.attributes.skinWeight,o),e.fromBufferAttribute(c.attributes.position,o).applyMatrix4(this.bindMatrix),a.set(0,0,0);for(let u=0;u<4;u++){const p=n.getComponent(u);if(p!==0){const d=t.getComponent(u);i.multiplyMatrices(s.bones[d].matrixWorld,s.boneInverses[d]),a.addScaledVector(r.copy(e).applyMatrix4(i),p)}}return a.applyMatrix4(this.bindMatrixInverse)}}()}),oa.prototype=Object.assign(Object.create(At.prototype),{constructor:oa,isBone:!0});const Lh=new Ht,sm=new Ht;function aa(e=[],t=[]){this.uuid=Ft.generateUUID(),this.bones=e.slice(0),this.boneInverses=t,this.boneMatrices=null,this.boneTexture=null,this.boneTextureSize=0,this.frame=-1,this.init()}Object.assign(aa.prototype,{init:function(){const e=this.bones,t=this.boneInverses;if(this.boneMatrices=new Float32Array(16*e.length),t.length===0)this.calculateInverses();else if(e.length!==t.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let n=0,r=this.bones.length;n<r;n++)this.boneInverses.push(new Ht)}},calculateInverses:function(){this.boneInverses.length=0;for(let e=0,t=this.bones.length;e<t;e++){const n=new Ht;this.bones[e]&&n.copy(this.bones[e].matrixWorld).invert(),this.boneInverses.push(n)}},pose:function(){for(let e=0,t=this.bones.length;e<t;e++){const n=this.bones[e];n&&n.matrixWorld.copy(this.boneInverses[e]).invert()}for(let e=0,t=this.bones.length;e<t;e++){const n=this.bones[e];n&&(n.parent&&n.parent.isBone?(n.matrix.copy(n.parent.matrixWorld).invert(),n.matrix.multiply(n.matrixWorld)):n.matrix.copy(n.matrixWorld),n.matrix.decompose(n.position,n.quaternion,n.scale))}},update:function(){const e=this.bones,t=this.boneInverses,n=this.boneMatrices,r=this.boneTexture;for(let i=0,o=e.length;i<o;i++){const a=e[i]?e[i].matrixWorld:sm;Lh.multiplyMatrices(a,t[i]),Lh.toArray(n,16*i)}r!==null&&(r.needsUpdate=!0)},clone:function(){return new aa(this.bones,this.boneInverses)},getBoneByName:function(e){for(let t=0,n=this.bones.length;t<n;t++){const r=this.bones[t];if(r.name===e)return r}},dispose:function(){this.boneTexture!==null&&(this.boneTexture.dispose(),this.boneTexture=null)},fromJSON:function(e,t){this.uuid=e.uuid;for(let n=0,r=e.bones.length;n<r;n++){const i=e.bones[n];let o=t[i];o===void 0&&(console.warn("THREE.Skeleton: No bone found with UUID:",i),o=new oa),this.bones.push(o),this.boneInverses.push(new Ht().fromArray(e.boneInverses[n]))}return this.init(),this},toJSON:function(){const e={metadata:{version:4.5,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};e.uuid=this.uuid;const t=this.bones,n=this.boneInverses;for(let r=0,i=t.length;r<i;r++){const o=t[r];e.bones.push(o.uuid);const a=n[r];e.boneInverses.push(a.toArray())}return e}});const Ch=new Ht,Ph=new Ht,ns=[],sa=new pn;function rs(e,t,n){pn.call(this,e,t),this.instanceMatrix=new Rt(new Float32Array(16*n),16),this.instanceColor=null,this.count=n,this.frustumCulled=!1}function mn(e){Nt.call(this),this.type="LineBasicMaterial",this.color=new _t(16777215),this.linewidth=1,this.linecap="round",this.linejoin="round",this.morphTargets=!1,this.setValues(e)}rs.prototype=Object.assign(Object.create(pn.prototype),{constructor:rs,isInstancedMesh:!0,copy:function(e){return pn.prototype.copy.call(this,e),this.instanceMatrix.copy(e.instanceMatrix),this.count=e.count,this},getColorAt:function(e,t){t.fromArray(this.instanceColor.array,3*e)},getMatrixAt:function(e,t){t.fromArray(this.instanceMatrix.array,16*e)},raycast:function(e,t){const n=this.matrixWorld,r=this.count;if(sa.geometry=this.geometry,sa.material=this.material,sa.material!==void 0)for(let i=0;i<r;i++){this.getMatrixAt(i,Ch),Ph.multiplyMatrices(n,Ch),sa.matrixWorld=Ph,sa.raycast(e,ns);for(let o=0,a=ns.length;o<a;o++){const s=ns[o];s.instanceId=i,s.object=this,t.push(s)}ns.length=0}},setColorAt:function(e,t){this.instanceColor===null&&(this.instanceColor=new Rt(new Float32Array(3*this.count),3)),t.toArray(this.instanceColor.array,3*e)},setMatrixAt:function(e,t){t.toArray(this.instanceMatrix.array,16*e)},updateMorphTargets:function(){}}),mn.prototype=Object.create(Nt.prototype),mn.prototype.constructor=mn,mn.prototype.isLineBasicMaterial=!0,mn.prototype.copy=function(e){return Nt.prototype.copy.call(this,e),this.color.copy(e.color),this.linewidth=e.linewidth,this.linecap=e.linecap,this.linejoin=e.linejoin,this.morphTargets=e.morphTargets,this};const Rh=new z,Oh=new z,Dh=new Ht,is=new Ji,os=new Fr;function lr(e,t,n){n===1&&console.error("THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead."),At.call(this),this.type="Line",this.geometry=e!==void 0?e:new Ct,this.material=t!==void 0?t:new mn,this.updateMorphTargets()}lr.prototype=Object.assign(Object.create(At.prototype),{constructor:lr,isLine:!0,copy:function(e){return At.prototype.copy.call(this,e),this.material=e.material,this.geometry=e.geometry,this},computeLineDistances:function(){const e=this.geometry;if(e.isBufferGeometry)if(e.index===null){const t=e.attributes.position,n=[0];for(let r=1,i=t.count;r<i;r++)Rh.fromBufferAttribute(t,r-1),Oh.fromBufferAttribute(t,r),n[r]=n[r-1],n[r]+=Rh.distanceTo(Oh);e.setAttribute("lineDistance",new yt(n,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else if(e.isGeometry){const t=e.vertices,n=e.lineDistances;n[0]=0;for(let r=1,i=t.length;r<i;r++)n[r]=n[r-1],n[r]+=t[r-1].distanceTo(t[r])}return this},raycast:function(e,t){const n=this.geometry,r=this.matrixWorld,i=e.params.Line.threshold;if(n.boundingSphere===null&&n.computeBoundingSphere(),os.copy(n.boundingSphere),os.applyMatrix4(r),os.radius+=i,e.ray.intersectsSphere(os)===!1)return;Dh.copy(r).invert(),is.copy(e.ray).applyMatrix4(Dh);const o=i/((this.scale.x+this.scale.y+this.scale.z)/3),a=o*o,s=new z,c=new z,u=new z,p=new z,d=this.isLineSegments?2:1;if(n.isBufferGeometry){const g=n.index,m=n.attributes.position;if(g!==null){const x=g.array;for(let S=0,b=x.length-1;S<b;S+=d){const R=x[S],F=x[S+1];if(s.fromBufferAttribute(m,R),c.fromBufferAttribute(m,F),is.distanceSqToSegment(s,c,p,u)>a)continue;p.applyMatrix4(this.matrixWorld);const ee=e.ray.origin.distanceTo(p);ee<e.near||ee>e.far||t.push({distance:ee,point:u.clone().applyMatrix4(this.matrixWorld),index:S,face:null,faceIndex:null,object:this})}}else for(let x=0,S=m.count-1;x<S;x+=d){if(s.fromBufferAttribute(m,x),c.fromBufferAttribute(m,x+1),is.distanceSqToSegment(s,c,p,u)>a)continue;p.applyMatrix4(this.matrixWorld);const b=e.ray.origin.distanceTo(p);b<e.near||b>e.far||t.push({distance:b,point:u.clone().applyMatrix4(this.matrixWorld),index:x,face:null,faceIndex:null,object:this})}}else if(n.isGeometry){const g=n.vertices,m=g.length;for(let x=0;x<m-1;x+=d){if(is.distanceSqToSegment(g[x],g[x+1],p,u)>a)continue;p.applyMatrix4(this.matrixWorld);const S=e.ray.origin.distanceTo(p);S<e.near||S>e.far||t.push({distance:S,point:u.clone().applyMatrix4(this.matrixWorld),index:x,face:null,faceIndex:null,object:this})}}},updateMorphTargets:function(){const e=this.geometry;if(e.isBufferGeometry){const t=e.morphAttributes,n=Object.keys(t);if(n.length>0){const r=t[n[0]];if(r!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let i=0,o=r.length;i<o;i++){const a=r[i].name||String(i);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=i}}}}else{const t=e.morphTargets;t!==void 0&&t.length>0&&console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}});const as=new z,ss=new z;function Wn(e,t){lr.call(this,e,t),this.type="LineSegments"}function cs(e,t){lr.call(this,e,t),this.type="LineLoop"}function vr(e){Nt.call(this),this.type="PointsMaterial",this.color=new _t(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.morphTargets=!1,this.setValues(e)}Wn.prototype=Object.assign(Object.create(lr.prototype),{constructor:Wn,isLineSegments:!0,computeLineDistances:function(){const e=this.geometry;if(e.isBufferGeometry)if(e.index===null){const t=e.attributes.position,n=[];for(let r=0,i=t.count;r<i;r+=2)as.fromBufferAttribute(t,r),ss.fromBufferAttribute(t,r+1),n[r]=r===0?0:n[r-1],n[r+1]=n[r]+as.distanceTo(ss);e.setAttribute("lineDistance",new yt(n,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else if(e.isGeometry){const t=e.vertices,n=e.lineDistances;for(let r=0,i=t.length;r<i;r+=2)as.copy(t[r]),ss.copy(t[r+1]),n[r]=r===0?0:n[r-1],n[r+1]=n[r]+as.distanceTo(ss)}return this}}),cs.prototype=Object.assign(Object.create(lr.prototype),{constructor:cs,isLineLoop:!0}),vr.prototype=Object.create(Nt.prototype),vr.prototype.constructor=vr,vr.prototype.isPointsMaterial=!0,vr.prototype.copy=function(e){return Nt.prototype.copy.call(this,e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.size=e.size,this.sizeAttenuation=e.sizeAttenuation,this.morphTargets=e.morphTargets,this};const Ih=new Ht,Hc=new Ji,ls=new Fr,us=new z;function mo(e,t){At.call(this),this.type="Points",this.geometry=e!==void 0?e:new Ct,this.material=t!==void 0?t:new vr,this.updateMorphTargets()}function Gc(e,t,n,r,i,o,a){const s=Hc.distanceSqToPoint(e);if(s<n){const c=new z;Hc.closestPointToPoint(e,c),c.applyMatrix4(r);const u=i.ray.origin.distanceTo(c);if(u<i.near||u>i.far)return;o.push({distance:u,distanceToRay:Math.sqrt(s),point:c,index:t,face:null,object:a})}}function Vc(e,t,n,r,i,o,a,s,c){tn.call(this,e,t,n,r,i,o,a,s,c),this.format=a!==void 0?a:En,this.minFilter=o!==void 0?o:se,this.magFilter=i!==void 0?i:se,this.generateMipmaps=!1;const u=this;"requestVideoFrameCallback"in e&&e.requestVideoFrameCallback(function p(){u.needsUpdate=!0,e.requestVideoFrameCallback(p)})}function go(e,t,n,r,i,o,a,s,c,u,p,d){tn.call(this,null,o,a,s,c,u,r,i,p,d),this.image={width:t,height:n},this.mipmaps=e,this.flipY=!1,this.generateMipmaps=!1}function ca(e,t,n,r,i,o,a,s,c){tn.call(this,e,t,n,r,i,o,a,s,c),this.needsUpdate=!0}function la(e,t,n,r,i,o,a,s,c,u){if((u=u!==void 0?u:gi)!==gi&&u!==Wi)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");n===void 0&&u===gi&&(n=Xt),n===void 0&&u===Wi&&(n=Tn),tn.call(this,null,r,i,o,a,s,u,n,c),this.image={width:e,height:t},this.magFilter=a!==void 0?a:y,this.minFilter=s!==void 0?s:y,this.flipY=!1,this.generateMipmaps=!1}mo.prototype=Object.assign(Object.create(At.prototype),{constructor:mo,isPoints:!0,copy:function(e){return At.prototype.copy.call(this,e),this.material=e.material,this.geometry=e.geometry,this},raycast:function(e,t){const n=this.geometry,r=this.matrixWorld,i=e.params.Points.threshold;if(n.boundingSphere===null&&n.computeBoundingSphere(),ls.copy(n.boundingSphere),ls.applyMatrix4(r),ls.radius+=i,e.ray.intersectsSphere(ls)===!1)return;Ih.copy(r).invert(),Hc.copy(e.ray).applyMatrix4(Ih);const o=i/((this.scale.x+this.scale.y+this.scale.z)/3),a=o*o;if(n.isBufferGeometry){const s=n.index,c=n.attributes.position;if(s!==null){const u=s.array;for(let p=0,d=u.length;p<d;p++){const g=u[p];us.fromBufferAttribute(c,g),Gc(us,g,a,r,e,t,this)}}else for(let u=0,p=c.count;u<p;u++)us.fromBufferAttribute(c,u),Gc(us,u,a,r,e,t,this)}else{const s=n.vertices;for(let c=0,u=s.length;c<u;c++)Gc(s[c],c,a,r,e,t,this)}},updateMorphTargets:function(){const e=this.geometry;if(e.isBufferGeometry){const t=e.morphAttributes,n=Object.keys(t);if(n.length>0){const r=t[n[0]];if(r!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let i=0,o=r.length;i<o;i++){const a=r[i].name||String(i);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=i}}}}else{const t=e.morphTargets;t!==void 0&&t.length>0&&console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}}),Vc.prototype=Object.assign(Object.create(tn.prototype),{constructor:Vc,clone:function(){return new this.constructor(this.image).copy(this)},isVideoTexture:!0,update:function(){const e=this.image;"requestVideoFrameCallback"in e===!1&&e.readyState>=e.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}}),go.prototype=Object.create(tn.prototype),go.prototype.constructor=go,go.prototype.isCompressedTexture=!0,ca.prototype=Object.create(tn.prototype),ca.prototype.constructor=ca,ca.prototype.isCanvasTexture=!0,la.prototype=Object.create(tn.prototype),la.prototype.constructor=la,la.prototype.isDepthTexture=!0;let cm=0;const Pr=new Ht,jc=new At,hs=new z;function rn(){Object.defineProperty(this,"id",{value:cm+=2}),this.uuid=Ft.generateUUID(),this.name="",this.type="Geometry",this.vertices=[],this.colors=[],this.faces=[],this.faceVertexUvs=[[]],this.morphTargets=[],this.morphNormals=[],this.skinWeights=[],this.skinIndices=[],this.lineDistances=[],this.boundingBox=null,this.boundingSphere=null,this.elementsNeedUpdate=!1,this.verticesNeedUpdate=!1,this.uvsNeedUpdate=!1,this.normalsNeedUpdate=!1,this.colorsNeedUpdate=!1,this.lineDistancesNeedUpdate=!1,this.groupsNeedUpdate=!1}rn.prototype=Object.assign(Object.create(Sr.prototype),{constructor:rn,isGeometry:!0,applyMatrix4:function(e){const t=new Vn().getNormalMatrix(e);for(let n=0,r=this.vertices.length;n<r;n++)this.vertices[n].applyMatrix4(e);for(let n=0,r=this.faces.length;n<r;n++){const i=this.faces[n];i.normal.applyMatrix3(t).normalize();for(let o=0,a=i.vertexNormals.length;o<a;o++)i.vertexNormals[o].applyMatrix3(t).normalize()}return this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this.verticesNeedUpdate=!0,this.normalsNeedUpdate=!0,this},rotateX:function(e){return Pr.makeRotationX(e),this.applyMatrix4(Pr),this},rotateY:function(e){return Pr.makeRotationY(e),this.applyMatrix4(Pr),this},rotateZ:function(e){return Pr.makeRotationZ(e),this.applyMatrix4(Pr),this},translate:function(e,t,n){return Pr.makeTranslation(e,t,n),this.applyMatrix4(Pr),this},scale:function(e,t,n){return Pr.makeScale(e,t,n),this.applyMatrix4(Pr),this},lookAt:function(e){return jc.lookAt(e),jc.updateMatrix(),this.applyMatrix4(jc.matrix),this},fromBufferGeometry:function(e){const t=this,n=e.index!==null?e.index:void 0,r=e.attributes;if(r.position===void 0)return console.error("THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion."),this;const i=r.position,o=r.normal,a=r.color,s=r.uv,c=r.uv2;c!==void 0&&(this.faceVertexUvs[1]=[]);for(let d=0;d<i.count;d++)t.vertices.push(new z().fromBufferAttribute(i,d)),a!==void 0&&t.colors.push(new _t().fromBufferAttribute(a,d));function u(d,g,m,x){const S=a===void 0?[]:[t.colors[d].clone(),t.colors[g].clone(),t.colors[m].clone()],b=o===void 0?[]:[new z().fromBufferAttribute(o,d),new z().fromBufferAttribute(o,g),new z().fromBufferAttribute(o,m)],R=new Bo(d,g,m,b,S,x);t.faces.push(R),s!==void 0&&t.faceVertexUvs[0].push([new Je().fromBufferAttribute(s,d),new Je().fromBufferAttribute(s,g),new Je().fromBufferAttribute(s,m)]),c!==void 0&&t.faceVertexUvs[1].push([new Je().fromBufferAttribute(c,d),new Je().fromBufferAttribute(c,g),new Je().fromBufferAttribute(c,m)])}const p=e.groups;if(p.length>0)for(let d=0;d<p.length;d++){const g=p[d],m=g.start;for(let x=m,S=m+g.count;x<S;x+=3)n!==void 0?u(n.getX(x),n.getX(x+1),n.getX(x+2),g.materialIndex):u(x,x+1,x+2,g.materialIndex)}else if(n!==void 0)for(let d=0;d<n.count;d+=3)u(n.getX(d),n.getX(d+1),n.getX(d+2));else for(let d=0;d<i.count;d+=3)u(d,d+1,d+2);return this.computeFaceNormals(),e.boundingBox!==null&&(this.boundingBox=e.boundingBox.clone()),e.boundingSphere!==null&&(this.boundingSphere=e.boundingSphere.clone()),this},center:function(){return this.computeBoundingBox(),this.boundingBox.getCenter(hs).negate(),this.translate(hs.x,hs.y,hs.z),this},normalize:function(){this.computeBoundingSphere();const e=this.boundingSphere.center,t=this.boundingSphere.radius,n=t===0?1:1/t,r=new Ht;return r.set(n,0,0,-n*e.x,0,n,0,-n*e.y,0,0,n,-n*e.z,0,0,0,1),this.applyMatrix4(r),this},computeFaceNormals:function(){const e=new z,t=new z;for(let n=0,r=this.faces.length;n<r;n++){const i=this.faces[n],o=this.vertices[i.a],a=this.vertices[i.b],s=this.vertices[i.c];e.subVectors(s,a),t.subVectors(o,a),e.cross(t),e.normalize(),i.normal.copy(e)}},computeVertexNormals:function(e=!0){const t=new Array(this.vertices.length);for(let n=0,r=this.vertices.length;n<r;n++)t[n]=new z;if(e){const n=new z,r=new z;for(let i=0,o=this.faces.length;i<o;i++){const a=this.faces[i],s=this.vertices[a.a],c=this.vertices[a.b],u=this.vertices[a.c];n.subVectors(u,c),r.subVectors(s,c),n.cross(r),t[a.a].add(n),t[a.b].add(n),t[a.c].add(n)}}else{this.computeFaceNormals();for(let n=0,r=this.faces.length;n<r;n++){const i=this.faces[n];t[i.a].add(i.normal),t[i.b].add(i.normal),t[i.c].add(i.normal)}}for(let n=0,r=this.vertices.length;n<r;n++)t[n].normalize();for(let n=0,r=this.faces.length;n<r;n++){const i=this.faces[n],o=i.vertexNormals;o.length===3?(o[0].copy(t[i.a]),o[1].copy(t[i.b]),o[2].copy(t[i.c])):(o[0]=t[i.a].clone(),o[1]=t[i.b].clone(),o[2]=t[i.c].clone())}this.faces.length>0&&(this.normalsNeedUpdate=!0)},computeFlatVertexNormals:function(){this.computeFaceNormals();for(let e=0,t=this.faces.length;e<t;e++){const n=this.faces[e],r=n.vertexNormals;r.length===3?(r[0].copy(n.normal),r[1].copy(n.normal),r[2].copy(n.normal)):(r[0]=n.normal.clone(),r[1]=n.normal.clone(),r[2]=n.normal.clone())}this.faces.length>0&&(this.normalsNeedUpdate=!0)},computeMorphNormals:function(){for(let t=0,n=this.faces.length;t<n;t++){const r=this.faces[t];r.__originalFaceNormal?r.__originalFaceNormal.copy(r.normal):r.__originalFaceNormal=r.normal.clone(),r.__originalVertexNormals||(r.__originalVertexNormals=[]);for(let i=0,o=r.vertexNormals.length;i<o;i++)r.__originalVertexNormals[i]?r.__originalVertexNormals[i].copy(r.vertexNormals[i]):r.__originalVertexNormals[i]=r.vertexNormals[i].clone()}const e=new rn;e.faces=this.faces;for(let t=0,n=this.morphTargets.length;t<n;t++){if(!this.morphNormals[t]){this.morphNormals[t]={},this.morphNormals[t].faceNormals=[],this.morphNormals[t].vertexNormals=[];const i=this.morphNormals[t].faceNormals,o=this.morphNormals[t].vertexNormals;for(let a=0,s=this.faces.length;a<s;a++){const c=new z,u={a:new z,b:new z,c:new z};i.push(c),o.push(u)}}const r=this.morphNormals[t];e.vertices=this.morphTargets[t].vertices,e.computeFaceNormals(),e.computeVertexNormals();for(let i=0,o=this.faces.length;i<o;i++){const a=this.faces[i],s=r.faceNormals[i],c=r.vertexNormals[i];s.copy(a.normal),c.a.copy(a.vertexNormals[0]),c.b.copy(a.vertexNormals[1]),c.c.copy(a.vertexNormals[2])}}for(let t=0,n=this.faces.length;t<n;t++){const r=this.faces[t];r.normal=r.__originalFaceNormal,r.vertexNormals=r.__originalVertexNormals}},computeBoundingBox:function(){this.boundingBox===null&&(this.boundingBox=new Tr),this.boundingBox.setFromPoints(this.vertices)},computeBoundingSphere:function(){this.boundingSphere===null&&(this.boundingSphere=new Fr),this.boundingSphere.setFromPoints(this.vertices)},merge:function(e,t,n=0){if(!e||!e.isGeometry)return void console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.",e);let r;const i=this.vertices.length,o=this.vertices,a=e.vertices,s=this.faces,c=e.faces,u=this.colors,p=e.colors;t!==void 0&&(r=new Vn().getNormalMatrix(t));for(let d=0,g=a.length;d<g;d++){const m=a[d].clone();t!==void 0&&m.applyMatrix4(t),o.push(m)}for(let d=0,g=p.length;d<g;d++)u.push(p[d].clone());for(let d=0,g=c.length;d<g;d++){const m=c[d];let x,S;const b=m.vertexNormals,R=m.vertexColors,F=new Bo(m.a+i,m.b+i,m.c+i);F.normal.copy(m.normal),r!==void 0&&F.normal.applyMatrix3(r).normalize();for(let ee=0,k=b.length;ee<k;ee++)x=b[ee].clone(),r!==void 0&&x.applyMatrix3(r).normalize(),F.vertexNormals.push(x);F.color.copy(m.color);for(let ee=0,k=R.length;ee<k;ee++)S=R[ee],F.vertexColors.push(S.clone());F.materialIndex=m.materialIndex+n,s.push(F)}for(let d=0,g=e.faceVertexUvs.length;d<g;d++){const m=e.faceVertexUvs[d];this.faceVertexUvs[d]===void 0&&(this.faceVertexUvs[d]=[]);for(let x=0,S=m.length;x<S;x++){const b=m[x],R=[];for(let F=0,ee=b.length;F<ee;F++)R.push(b[F].clone());this.faceVertexUvs[d].push(R)}}},mergeMesh:function(e){e&&e.isMesh?(e.matrixAutoUpdate&&e.updateMatrix(),this.merge(e.geometry,e.matrix)):console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.",e)},mergeVertices:function(e=4){const t={},n=[],r=[],i=Math.pow(10,e);for(let s=0,c=this.vertices.length;s<c;s++){const u=this.vertices[s],p=Math.round(u.x*i)+"_"+Math.round(u.y*i)+"_"+Math.round(u.z*i);t[p]===void 0?(t[p]=s,n.push(this.vertices[s]),r[s]=n.length-1):r[s]=r[t[p]]}const o=[];for(let s=0,c=this.faces.length;s<c;s++){const u=this.faces[s];u.a=r[u.a],u.b=r[u.b],u.c=r[u.c];const p=[u.a,u.b,u.c];for(let d=0;d<3;d++)if(p[d]===p[(d+1)%3]){o.push(s);break}}for(let s=o.length-1;s>=0;s--){const c=o[s];this.faces.splice(c,1);for(let u=0,p=this.faceVertexUvs.length;u<p;u++)this.faceVertexUvs[u].splice(c,1)}const a=this.vertices.length-n.length;return this.vertices=n,a},setFromPoints:function(e){this.vertices=[];for(let t=0,n=e.length;t<n;t++){const r=e[t];this.vertices.push(new z(r.x,r.y,r.z||0))}return this},sortFacesByMaterialIndex:function(){const e=this.faces,t=e.length;for(let a=0;a<t;a++)e[a]._id=a;e.sort(function(a,s){return a.materialIndex-s.materialIndex});const n=this.faceVertexUvs[0],r=this.faceVertexUvs[1];let i,o;n&&n.length===t&&(i=[]),r&&r.length===t&&(o=[]);for(let a=0;a<t;a++){const s=e[a]._id;i&&i.push(n[s]),o&&o.push(r[s])}i&&(this.faceVertexUvs[0]=i),o&&(this.faceVertexUvs[1]=o)},toJSON:function(){const e={metadata:{version:4.5,type:"Geometry",generator:"Geometry.toJSON"}};if(e.uuid=this.uuid,e.type=this.type,this.name!==""&&(e.name=this.name),this.parameters!==void 0){const m=this.parameters;for(const x in m)m[x]!==void 0&&(e[x]=m[x]);return e}const t=[];for(let m=0;m<this.vertices.length;m++){const x=this.vertices[m];t.push(x.x,x.y,x.z)}const n=[],r=[],i={},o=[],a={},s=[],c={};for(let m=0;m<this.faces.length;m++){const x=this.faces[m],S=!0,b=!1,R=this.faceVertexUvs[0][m]!==void 0,F=x.normal.length()>0,ee=x.vertexNormals.length>0,k=x.color.r!==1||x.color.g!==1||x.color.b!==1,K=x.vertexColors.length>0;let le=0;if(le=u(le,0,0),le=u(le,1,S),le=u(le,2,b),le=u(le,3,R),le=u(le,4,F),le=u(le,5,ee),le=u(le,6,k),le=u(le,7,K),n.push(le),n.push(x.a,x.b,x.c),n.push(x.materialIndex),R){const ge=this.faceVertexUvs[0][m];n.push(g(ge[0]),g(ge[1]),g(ge[2]))}if(F&&n.push(p(x.normal)),ee){const ge=x.vertexNormals;n.push(p(ge[0]),p(ge[1]),p(ge[2]))}if(k&&n.push(d(x.color)),K){const ge=x.vertexColors;n.push(d(ge[0]),d(ge[1]),d(ge[2]))}}function u(m,x,S){return S?m|1<<x:m&~(1<<x)}function p(m){const x=m.x.toString()+m.y.toString()+m.z.toString();return i[x]!==void 0||(i[x]=r.length/3,r.push(m.x,m.y,m.z)),i[x]}function d(m){const x=m.r.toString()+m.g.toString()+m.b.toString();return a[x]!==void 0||(a[x]=o.length,o.push(m.getHex())),a[x]}function g(m){const x=m.x.toString()+m.y.toString();return c[x]!==void 0||(c[x]=s.length/2,s.push(m.x,m.y)),c[x]}return e.data={},e.data.vertices=t,e.data.normals=r,o.length>0&&(e.data.colors=o),s.length>0&&(e.data.uvs=[s]),e.data.faces=n,e},clone:function(){return new rn().copy(this)},copy:function(e){this.vertices=[],this.colors=[],this.faces=[],this.faceVertexUvs=[[]],this.morphTargets=[],this.morphNormals=[],this.skinWeights=[],this.skinIndices=[],this.lineDistances=[],this.boundingBox=null,this.boundingSphere=null,this.name=e.name;const t=e.vertices;for(let d=0,g=t.length;d<g;d++)this.vertices.push(t[d].clone());const n=e.colors;for(let d=0,g=n.length;d<g;d++)this.colors.push(n[d].clone());const r=e.faces;for(let d=0,g=r.length;d<g;d++)this.faces.push(r[d].clone());for(let d=0,g=e.faceVertexUvs.length;d<g;d++){const m=e.faceVertexUvs[d];this.faceVertexUvs[d]===void 0&&(this.faceVertexUvs[d]=[]);for(let x=0,S=m.length;x<S;x++){const b=m[x],R=[];for(let F=0,ee=b.length;F<ee;F++){const k=b[F];R.push(k.clone())}this.faceVertexUvs[d].push(R)}}const i=e.morphTargets;for(let d=0,g=i.length;d<g;d++){const m={};if(m.name=i[d].name,i[d].vertices!==void 0){m.vertices=[];for(let x=0,S=i[d].vertices.length;x<S;x++)m.vertices.push(i[d].vertices[x].clone())}if(i[d].normals!==void 0){m.normals=[];for(let x=0,S=i[d].normals.length;x<S;x++)m.normals.push(i[d].normals[x].clone())}this.morphTargets.push(m)}const o=e.morphNormals;for(let d=0,g=o.length;d<g;d++){const m={};if(o[d].vertexNormals!==void 0){m.vertexNormals=[];for(let x=0,S=o[d].vertexNormals.length;x<S;x++){const b=o[d].vertexNormals[x],R={};R.a=b.a.clone(),R.b=b.b.clone(),R.c=b.c.clone(),m.vertexNormals.push(R)}}if(o[d].faceNormals!==void 0){m.faceNormals=[];for(let x=0,S=o[d].faceNormals.length;x<S;x++)m.faceNormals.push(o[d].faceNormals[x].clone())}this.morphNormals.push(m)}const a=e.skinWeights;for(let d=0,g=a.length;d<g;d++)this.skinWeights.push(a[d].clone());const s=e.skinIndices;for(let d=0,g=s.length;d<g;d++)this.skinIndices.push(s[d].clone());const c=e.lineDistances;for(let d=0,g=c.length;d<g;d++)this.lineDistances.push(c[d]);const u=e.boundingBox;u!==null&&(this.boundingBox=u.clone());const p=e.boundingSphere;return p!==null&&(this.boundingSphere=p.clone()),this.elementsNeedUpdate=e.elementsNeedUpdate,this.verticesNeedUpdate=e.verticesNeedUpdate,this.uvsNeedUpdate=e.uvsNeedUpdate,this.normalsNeedUpdate=e.normalsNeedUpdate,this.colorsNeedUpdate=e.colorsNeedUpdate,this.lineDistancesNeedUpdate=e.lineDistancesNeedUpdate,this.groupsNeedUpdate=e.groupsNeedUpdate,this},dispose:function(){this.dispatchEvent({type:"dispose"})}});class Wc extends rn{constructor(e,t,n,r,i,o){super(),this.type="BoxGeometry",this.parameters={width:e,height:t,depth:n,widthSegments:r,heightSegments:i,depthSegments:o},this.fromBufferGeometry(new qo(e,t,n,r,i,o)),this.mergeVertices()}}class Xc extends Ct{constructor(e=1,t=8,n=0,r=2*Math.PI){super(),this.type="CircleBufferGeometry",this.parameters={radius:e,segments:t,thetaStart:n,thetaLength:r},t=Math.max(3,t);const i=[],o=[],a=[],s=[],c=new z,u=new Je;o.push(0,0,0),a.push(0,0,1),s.push(.5,.5);for(let p=0,d=3;p<=t;p++,d+=3){const g=n+p/t*r;c.x=e*Math.cos(g),c.y=e*Math.sin(g),o.push(c.x,c.y,c.z),a.push(0,0,1),u.x=(o[d]/e+1)/2,u.y=(o[d+1]/e+1)/2,s.push(u.x,u.y)}for(let p=1;p<=t;p++)i.push(p,p+1,0);this.setIndex(i),this.setAttribute("position",new yt(o,3)),this.setAttribute("normal",new yt(a,3)),this.setAttribute("uv",new yt(s,2))}}class Nh extends rn{constructor(e,t,n,r){super(),this.type="CircleGeometry",this.parameters={radius:e,segments:t,thetaStart:n,thetaLength:r},this.fromBufferGeometry(new Xc(e,t,n,r)),this.mergeVertices()}}class ua extends Ct{constructor(e=1,t=1,n=1,r=8,i=1,o=!1,a=0,s=2*Math.PI){super(),this.type="CylinderBufferGeometry",this.parameters={radiusTop:e,radiusBottom:t,height:n,radialSegments:r,heightSegments:i,openEnded:o,thetaStart:a,thetaLength:s};const c=this;r=Math.floor(r),i=Math.floor(i);const u=[],p=[],d=[],g=[];let m=0;const x=[],S=n/2;let b=0;function R(F){const ee=m,k=new Je,K=new z;let le=0;const ge=F===!0?e:t,Le=F===!0?1:-1;for(let xe=1;xe<=r;xe++)p.push(0,S*Le,0),d.push(0,Le,0),g.push(.5,.5),m++;const Ae=m;for(let xe=0;xe<=r;xe++){const Xe=xe/r*s+a,He=Math.cos(Xe),tt=Math.sin(Xe);K.x=ge*tt,K.y=S*Le,K.z=ge*He,p.push(K.x,K.y,K.z),d.push(0,Le,0),k.x=.5*He+.5,k.y=.5*tt*Le+.5,g.push(k.x,k.y),m++}for(let xe=0;xe<r;xe++){const Xe=ee+xe,He=Ae+xe;F===!0?u.push(He,He+1,Xe):u.push(He+1,He,Xe),le+=3}c.addGroup(b,le,F===!0?1:2),b+=le}!function(){const F=new z,ee=new z;let k=0;const K=(t-e)/n;for(let le=0;le<=i;le++){const ge=[],Le=le/i,Ae=Le*(t-e)+e;for(let xe=0;xe<=r;xe++){const Xe=xe/r,He=Xe*s+a,tt=Math.sin(He),ft=Math.cos(He);ee.x=Ae*tt,ee.y=-Le*n+S,ee.z=Ae*ft,p.push(ee.x,ee.y,ee.z),F.set(tt,K,ft).normalize(),d.push(F.x,F.y,F.z),g.push(Xe,1-Le),ge.push(m++)}x.push(ge)}for(let le=0;le<r;le++)for(let ge=0;ge<i;ge++){const Le=x[ge][le],Ae=x[ge+1][le],xe=x[ge+1][le+1],Xe=x[ge][le+1];u.push(Le,Ae,Xe),u.push(Ae,xe,Xe),k+=6}c.addGroup(b,k,0),b+=k}(),o===!1&&(e>0&&R(!0),t>0&&R(!1)),this.setIndex(u),this.setAttribute("position",new yt(p,3)),this.setAttribute("normal",new yt(d,3)),this.setAttribute("uv",new yt(g,2))}}class qc extends rn{constructor(e,t,n,r,i,o,a,s){super(),this.type="CylinderGeometry",this.parameters={radiusTop:e,radiusBottom:t,height:n,radialSegments:r,heightSegments:i,openEnded:o,thetaStart:a,thetaLength:s},this.fromBufferGeometry(new ua(e,t,n,r,i,o,a,s)),this.mergeVertices()}}class Bh extends qc{constructor(e,t,n,r,i,o,a){super(0,e,t,n,r,i,o,a),this.type="ConeGeometry",this.parameters={radius:e,height:t,radialSegments:n,heightSegments:r,openEnded:i,thetaStart:o,thetaLength:a}}}class Fh extends ua{constructor(e=1,t=1,n=8,r=1,i=!1,o=0,a=2*Math.PI){super(0,e,t,n,r,i,o,a),this.type="ConeBufferGeometry",this.parameters={radius:e,height:t,radialSegments:n,heightSegments:r,openEnded:i,thetaStart:o,thetaLength:a}}}class Ci extends Ct{constructor(e,t,n=1,r=0){super(),this.type="PolyhedronBufferGeometry",this.parameters={vertices:e,indices:t,radius:n,detail:r};const i=[],o=[];function a(d,g,m,x){const S=x+1,b=[];for(let R=0;R<=S;R++){b[R]=[];const F=d.clone().lerp(m,R/S),ee=g.clone().lerp(m,R/S),k=S-R;for(let K=0;K<=k;K++)b[R][K]=K===0&&R===S?F:F.clone().lerp(ee,K/k)}for(let R=0;R<S;R++)for(let F=0;F<2*(S-R)-1;F++){const ee=Math.floor(F/2);F%2==0?(s(b[R][ee+1]),s(b[R+1][ee]),s(b[R][ee])):(s(b[R][ee+1]),s(b[R+1][ee+1]),s(b[R+1][ee]))}}function s(d){i.push(d.x,d.y,d.z)}function c(d,g){const m=3*d;g.x=e[m+0],g.y=e[m+1],g.z=e[m+2]}function u(d,g,m,x){x<0&&d.x===1&&(o[g]=d.x-1),m.x===0&&m.z===0&&(o[g]=x/2/Math.PI+.5)}function p(d){return Math.atan2(d.z,-d.x)}!function(d){const g=new z,m=new z,x=new z;for(let S=0;S<t.length;S+=3)c(t[S+0],g),c(t[S+1],m),c(t[S+2],x),a(g,m,x,d)}(r),function(d){const g=new z;for(let m=0;m<i.length;m+=3)g.x=i[m+0],g.y=i[m+1],g.z=i[m+2],g.normalize().multiplyScalar(d),i[m+0]=g.x,i[m+1]=g.y,i[m+2]=g.z}(n),function(){const d=new z;for(let m=0;m<i.length;m+=3){d.x=i[m+0],d.y=i[m+1],d.z=i[m+2];const x=p(d)/2/Math.PI+.5,S=(g=d,Math.atan2(-g.y,Math.sqrt(g.x*g.x+g.z*g.z))/Math.PI+.5);o.push(x,1-S)}var g;(function(){const m=new z,x=new z,S=new z,b=new z,R=new Je,F=new Je,ee=new Je;for(let k=0,K=0;k<i.length;k+=9,K+=6){m.set(i[k+0],i[k+1],i[k+2]),x.set(i[k+3],i[k+4],i[k+5]),S.set(i[k+6],i[k+7],i[k+8]),R.set(o[K+0],o[K+1]),F.set(o[K+2],o[K+3]),ee.set(o[K+4],o[K+5]),b.copy(m).add(x).add(S).divideScalar(3);const le=p(b);u(R,K+0,m,le),u(F,K+2,x,le),u(ee,K+4,S,le)}})(),function(){for(let m=0;m<o.length;m+=6){const x=o[m+0],S=o[m+2],b=o[m+4],R=Math.max(x,S,b),F=Math.min(x,S,b);R>.9&&F<.1&&(x<.2&&(o[m+0]+=1),S<.2&&(o[m+2]+=1),b<.2&&(o[m+4]+=1))}}()}(),this.setAttribute("position",new yt(i,3)),this.setAttribute("normal",new yt(i.slice(),3)),this.setAttribute("uv",new yt(o,2)),r===0?this.computeVertexNormals():this.normalizeNormals()}}class Yc extends Ci{constructor(e=1,t=0){const n=(1+Math.sqrt(5))/2,r=1/n;super([-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,0,-r,-n,0,-r,n,0,r,-n,0,r,n,-r,-n,0,-r,n,0,r,-n,0,r,n,0,-n,0,-r,n,0,-r,-n,0,r,n,0,r],[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9],e,t),this.type="DodecahedronBufferGeometry",this.parameters={radius:e,detail:t}}}class Uh extends rn{constructor(e,t){super(),this.type="DodecahedronGeometry",this.parameters={radius:e,detail:t},this.fromBufferGeometry(new Yc(e,t)),this.mergeVertices()}}const ds=new z,ps=new z,Zc=new z,fs=new Bn;class Jc extends Ct{constructor(e,t){super(),this.type="EdgesGeometry",this.parameters={thresholdAngle:t},t=t!==void 0?t:1,e.isGeometry&&(e=new Ct().fromGeometry(e));const n=Math.pow(10,4),r=Math.cos(Ft.DEG2RAD*t),i=e.getIndex(),o=e.getAttribute("position"),a=i?i.count:o.count,s=[0,0,0],c=["a","b","c"],u=new Array(3),p={},d=[];for(let g=0;g<a;g+=3){i?(s[0]=i.getX(g),s[1]=i.getX(g+1),s[2]=i.getX(g+2)):(s[0]=g,s[1]=g+1,s[2]=g+2);const{a:m,b:x,c:S}=fs;if(m.fromBufferAttribute(o,s[0]),x.fromBufferAttribute(o,s[1]),S.fromBufferAttribute(o,s[2]),fs.getNormal(Zc),u[0]=`${Math.round(m.x*n)},${Math.round(m.y*n)},${Math.round(m.z*n)}`,u[1]=`${Math.round(x.x*n)},${Math.round(x.y*n)},${Math.round(x.z*n)}`,u[2]=`${Math.round(S.x*n)},${Math.round(S.y*n)},${Math.round(S.z*n)}`,u[0]!==u[1]&&u[1]!==u[2]&&u[2]!==u[0])for(let b=0;b<3;b++){const R=(b+1)%3,F=u[b],ee=u[R],k=fs[c[b]],K=fs[c[R]],le=`${F}_${ee}`,ge=`${ee}_${F}`;ge in p&&p[ge]?(Zc.dot(p[ge].normal)<=r&&(d.push(k.x,k.y,k.z),d.push(K.x,K.y,K.z)),p[ge]=null):le in p||(p[le]={index0:s[b],index1:s[R],normal:Zc.clone()})}}for(const g in p)if(p[g]){const{index0:m,index1:x}=p[g];ds.fromBufferAttribute(o,m),ps.fromBufferAttribute(o,x),d.push(ds.x,ds.y,ds.z),d.push(ps.x,ps.y,ps.z)}this.setAttribute("position",new yt(d,3))}}const lm=function(e,t,n){n=n||2;const r=t&&t.length,i=r?t[0]*n:e.length;let o=zh(e,0,i,n,!0);const a=[];if(!o||o.next===o.prev)return a;let s,c,u,p,d,g,m;if(r&&(o=function(x,S,b,R){const F=[];let ee,k,K,le,ge;for(ee=0,k=S.length;ee<k;ee++)K=S[ee]*R,le=ee<k-1?S[ee+1]*R:x.length,ge=zh(x,K,le,R,!1),ge===ge.next&&(ge.steiner=!0),F.push(vm(ge));for(F.sort(fm),ee=0;ee<F.length;ee++)mm(F[ee],b),b=li(b,b.next);return b}(e,t,o,n)),e.length>80*n){s=u=e[0],c=p=e[1];for(let x=n;x<i;x+=n)d=e[x],g=e[x+1],d<s&&(s=d),g<c&&(c=g),d>u&&(u=d),g>p&&(p=g);m=Math.max(u-s,p-c),m=m!==0?1/m:0}return ha(o,a,n,s,c,m),a};function zh(e,t,n,r,i){let o,a;if(i===function(s,c,u,p){let d=0;for(let g=c,m=u-p;g<u;g+=p)d+=(s[m]-s[g])*(s[g+1]+s[m+1]),m=g;return d}(e,t,n,r)>0)for(o=t;o<n;o+=r)a=Gh(o,e[o],e[o+1],a);else for(o=n-r;o>=t;o-=r)a=Gh(o,e[o],e[o+1],a);return a&&ms(a,a.next)&&(pa(a),a=a.next),a}function li(e,t){if(!e)return e;t||(t=e);let n,r=e;do if(n=!1,r.steiner||!ms(r,r.next)&&vn(r.prev,r,r.next)!==0)r=r.next;else{if(pa(r),r=t=r.prev,r===r.next)break;n=!0}while(n||r!==t);return t}function ha(e,t,n,r,i,o,a){if(!e)return;!a&&o&&function(p,d,g,m){let x=p;do x.z===null&&(x.z=Kc(x.x,x.y,d,g,m)),x.prevZ=x.prev,x.nextZ=x.next,x=x.next;while(x!==p);x.prevZ.nextZ=null,x.prevZ=null,function(S){let b,R,F,ee,k,K,le,ge,Le=1;do{for(R=S,S=null,k=null,K=0;R;){for(K++,F=R,le=0,b=0;b<Le&&(le++,F=F.nextZ,F);b++);for(ge=Le;le>0||ge>0&&F;)le!==0&&(ge===0||!F||R.z<=F.z)?(ee=R,R=R.nextZ,le--):(ee=F,F=F.nextZ,ge--),k?k.nextZ=ee:S=ee,ee.prevZ=k,k=ee;R=F}k.nextZ=null,Le*=2}while(K>1)}(x)}(e,r,i,o);let s,c,u=e;for(;e.prev!==e.next;)if(s=e.prev,c=e.next,o?hm(e,r,i,o):um(e))t.push(s.i/n),t.push(e.i/n),t.push(c.i/n),pa(e),e=c.next,u=c.next;else if((e=c)===u){a?a===1?ha(e=dm(li(e),t,n),t,n,r,i,o,2):a===2&&pm(e,t,n,r,i,o):ha(li(e),t,n,r,i,o,1);break}}function um(e){const t=e.prev,n=e,r=e.next;if(vn(t,n,r)>=0)return!1;let i=e.next.next;for(;i!==e.prev;){if(vo(t.x,t.y,n.x,n.y,r.x,r.y,i.x,i.y)&&vn(i.prev,i,i.next)>=0)return!1;i=i.next}return!0}function hm(e,t,n,r){const i=e.prev,o=e,a=e.next;if(vn(i,o,a)>=0)return!1;const s=i.x<o.x?i.x<a.x?i.x:a.x:o.x<a.x?o.x:a.x,c=i.y<o.y?i.y<a.y?i.y:a.y:o.y<a.y?o.y:a.y,u=i.x>o.x?i.x>a.x?i.x:a.x:o.x>a.x?o.x:a.x,p=i.y>o.y?i.y>a.y?i.y:a.y:o.y>a.y?o.y:a.y,d=Kc(s,c,t,n,r),g=Kc(u,p,t,n,r);let m=e.prevZ,x=e.nextZ;for(;m&&m.z>=d&&x&&x.z<=g;){if(m!==e.prev&&m!==e.next&&vo(i.x,i.y,o.x,o.y,a.x,a.y,m.x,m.y)&&vn(m.prev,m,m.next)>=0)return!1;if(m=m.prevZ,x!==e.prev&&x!==e.next&&vo(i.x,i.y,o.x,o.y,a.x,a.y,x.x,x.y)&&vn(x.prev,x,x.next)>=0)return!1;x=x.nextZ}for(;m&&m.z>=d;){if(m!==e.prev&&m!==e.next&&vo(i.x,i.y,o.x,o.y,a.x,a.y,m.x,m.y)&&vn(m.prev,m,m.next)>=0)return!1;m=m.prevZ}for(;x&&x.z<=g;){if(x!==e.prev&&x!==e.next&&vo(i.x,i.y,o.x,o.y,a.x,a.y,x.x,x.y)&&vn(x.prev,x,x.next)>=0)return!1;x=x.nextZ}return!0}function dm(e,t,n){let r=e;do{const i=r.prev,o=r.next.next;!ms(i,o)&&kh(i,r,r.next,o)&&da(i,o)&&da(o,i)&&(t.push(i.i/n),t.push(r.i/n),t.push(o.i/n),pa(r),pa(r.next),r=e=o),r=r.next}while(r!==e);return li(r)}function pm(e,t,n,r,i,o){let a=e;do{let s=a.next.next;for(;s!==a.prev;){if(a.i!==s.i&&ym(a,s)){let c=Hh(a,s);return a=li(a,a.next),c=li(c,c.next),ha(a,t,n,r,i,o),void ha(c,t,n,r,i,o)}s=s.next}a=a.next}while(a!==e)}function fm(e,t){return e.x-t.x}function mm(e,t){if(t=function(n,r){let i=r;const o=n.x,a=n.y;let s,c=-1/0;do{if(a<=i.y&&a>=i.next.y&&i.next.y!==i.y){const x=i.x+(a-i.y)*(i.next.x-i.x)/(i.next.y-i.y);if(x<=o&&x>c){if(c=x,x===o){if(a===i.y)return i;if(a===i.next.y)return i.next}s=i.x<i.next.x?i:i.next}}i=i.next}while(i!==r);if(!s)return null;if(o===c)return s;const u=s,p=s.x,d=s.y;let g,m=1/0;i=s;do o>=i.x&&i.x>=p&&o!==i.x&&vo(a<d?o:c,a,p,d,a<d?c:o,a,i.x,i.y)&&(g=Math.abs(a-i.y)/(o-i.x),da(i,n)&&(g<m||g===m&&(i.x>s.x||i.x===s.x&&gm(s,i)))&&(s=i,m=g)),i=i.next;while(i!==u);return s}(e,t)){const n=Hh(t,e);li(t,t.next),li(n,n.next)}}function gm(e,t){return vn(e.prev,e,t.prev)<0&&vn(t.next,e,e.next)<0}function Kc(e,t,n,r,i){return(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=32767*(e-n)*i)|e<<8))|e<<4))|e<<2))|e<<1))|(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=32767*(t-r)*i)|t<<8))|t<<4))|t<<2))|t<<1))<<1}function vm(e){let t=e,n=e;do(t.x<n.x||t.x===n.x&&t.y<n.y)&&(n=t),t=t.next;while(t!==e);return n}function vo(e,t,n,r,i,o,a,s){return(i-a)*(t-s)-(e-a)*(o-s)>=0&&(e-a)*(r-s)-(n-a)*(t-s)>=0&&(n-a)*(o-s)-(i-a)*(r-s)>=0}function ym(e,t){return e.next.i!==t.i&&e.prev.i!==t.i&&!function(n,r){let i=n;do{if(i.i!==n.i&&i.next.i!==n.i&&i.i!==r.i&&i.next.i!==r.i&&kh(i,i.next,n,r))return!0;i=i.next}while(i!==n);return!1}(e,t)&&(da(e,t)&&da(t,e)&&function(n,r){let i=n,o=!1;const a=(n.x+r.x)/2,s=(n.y+r.y)/2;do i.y>s!=i.next.y>s&&i.next.y!==i.y&&a<(i.next.x-i.x)*(s-i.y)/(i.next.y-i.y)+i.x&&(o=!o),i=i.next;while(i!==n);return o}(e,t)&&(vn(e.prev,e,t.prev)||vn(e,t.prev,t))||ms(e,t)&&vn(e.prev,e,e.next)>0&&vn(t.prev,t,t.next)>0)}function vn(e,t,n){return(t.y-e.y)*(n.x-t.x)-(t.x-e.x)*(n.y-t.y)}function ms(e,t){return e.x===t.x&&e.y===t.y}function kh(e,t,n,r){const i=vs(vn(e,t,n)),o=vs(vn(e,t,r)),a=vs(vn(n,r,e)),s=vs(vn(n,r,t));return i!==o&&a!==s||(!(i!==0||!gs(e,n,t))||(!(o!==0||!gs(e,r,t))||!(a!==0||!gs(n,e,r))))||!(s!==0||!gs(n,t,r))}function gs(e,t,n){return t.x<=Math.max(e.x,n.x)&&t.x>=Math.min(e.x,n.x)&&t.y<=Math.max(e.y,n.y)&&t.y>=Math.min(e.y,n.y)}function vs(e){return e>0?1:e<0?-1:0}function da(e,t){return vn(e.prev,e,e.next)<0?vn(e,t,e.next)>=0&&vn(e,e.prev,t)>=0:vn(e,t,e.prev)<0||vn(e,e.next,t)<0}function Hh(e,t){const n=new Qc(e.i,e.x,e.y),r=new Qc(t.i,t.x,t.y),i=e.next,o=t.prev;return e.next=t,t.prev=e,n.next=i,i.prev=n,r.next=n,n.prev=r,o.next=r,r.prev=o,r}function Gh(e,t,n,r){const i=new Qc(e,t,n);return r?(i.next=r.next,i.prev=r,r.next.prev=i,r.next=i):(i.prev=i,i.next=i),i}function pa(e){e.next.prev=e.prev,e.prev.next=e.next,e.prevZ&&(e.prevZ.nextZ=e.nextZ),e.nextZ&&(e.nextZ.prevZ=e.prevZ)}function Qc(e,t,n){this.i=e,this.x=t,this.y=n,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}const jr={area:function(e){const t=e.length;let n=0;for(let r=t-1,i=0;i<t;r=i++)n+=e[r].x*e[i].y-e[i].x*e[r].y;return .5*n},isClockWise:function(e){return jr.area(e)<0},triangulateShape:function(e,t){const n=[],r=[],i=[];Vh(e),jh(n,e);let o=e.length;t.forEach(Vh);for(let s=0;s<t.length;s++)r.push(o),o+=t[s].length,jh(n,t[s]);const a=lm(n,r);for(let s=0;s<a.length;s+=3)i.push(a.slice(s,s+3));return i}};function Vh(e){const t=e.length;t>2&&e[t-1].equals(e[0])&&e.pop()}function jh(e,t){for(let n=0;n<t.length;n++)e.push(t[n].x),e.push(t[n].y)}class fa extends Ct{constructor(e,t){super(),this.type="ExtrudeBufferGeometry",this.parameters={shapes:e,options:t},e=Array.isArray(e)?e:[e];const n=this,r=[],i=[];for(let a=0,s=e.length;a<s;a++)o(e[a]);function o(a){const s=[],c=t.curveSegments!==void 0?t.curveSegments:12,u=t.steps!==void 0?t.steps:1;let p=t.depth!==void 0?t.depth:100,d=t.bevelEnabled===void 0||t.bevelEnabled,g=t.bevelThickness!==void 0?t.bevelThickness:6,m=t.bevelSize!==void 0?t.bevelSize:g-2,x=t.bevelOffset!==void 0?t.bevelOffset:0,S=t.bevelSegments!==void 0?t.bevelSegments:3;const b=t.extrudePath,R=t.UVGenerator!==void 0?t.UVGenerator:xm;t.amount!==void 0&&(console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."),p=t.amount);let F,ee,k,K,le,ge=!1;b&&(F=b.getSpacedPoints(u),ge=!0,d=!1,ee=b.computeFrenetFrames(u,!1),k=new z,K=new z,le=new z),d||(S=0,g=0,m=0,x=0);const Le=a.extractPoints(c);let Ae=Le.shape;const xe=Le.holes;if(!jr.isClockWise(Ae)){Ae=Ae.reverse();for(let De=0,Ge=xe.length;De<Ge;De++){const Ie=xe[De];jr.isClockWise(Ie)&&(xe[De]=Ie.reverse())}}const Xe=jr.triangulateShape(Ae,xe),He=Ae;for(let De=0,Ge=xe.length;De<Ge;De++){const Ie=xe[De];Ae=Ae.concat(Ie)}function tt(De,Ge,Ie){return Ge||console.error("THREE.ExtrudeGeometry: vec does not exist"),Ge.clone().multiplyScalar(Ie).add(De)}const ft=Ae.length,ke=Xe.length;function dt(De,Ge,Ie){let ct,nt,wt;const xt=De.x-Ge.x,St=De.y-Ge.y,jt=Ie.x-De.x,Pt=Ie.y-De.y,un=xt*xt+St*St,hn=xt*Pt-St*jt;if(Math.abs(hn)>Number.EPSILON){const kn=Math.sqrt(un),Ma=Math.sqrt(jt*jt+Pt*Pt),Sa=Ge.x-St/kn,Ta=Ge.y+xt/kn,dr=((Ie.x-Pt/Ma-Sa)*Pt-(Ie.y+jt/Ma-Ta)*jt)/(xt*Pt-St*jt);ct=Sa+xt*dr-De.x,nt=Ta+St*dr-De.y;const Hn=ct*ct+nt*nt;if(Hn<=2)return new Je(ct,nt);wt=Math.sqrt(Hn/2)}else{let kn=!1;xt>Number.EPSILON?jt>Number.EPSILON&&(kn=!0):xt<-Number.EPSILON?jt<-Number.EPSILON&&(kn=!0):Math.sign(St)===Math.sign(Pt)&&(kn=!0),kn?(ct=-St,nt=xt,wt=Math.sqrt(un)):(ct=xt,nt=St,wt=Math.sqrt(un/2))}return new Je(ct/wt,nt/wt)}const et=[];for(let De=0,Ge=He.length,Ie=Ge-1,ct=De+1;De<Ge;De++,Ie++,ct++)Ie===Ge&&(Ie=0),ct===Ge&&(ct=0),et[De]=dt(He[De],He[Ie],He[ct]);const st=[];let Mt,Dt=et.concat();for(let De=0,Ge=xe.length;De<Ge;De++){const Ie=xe[De];Mt=[];for(let ct=0,nt=Ie.length,wt=nt-1,xt=ct+1;ct<nt;ct++,wt++,xt++)wt===nt&&(wt=0),xt===nt&&(xt=0),Mt[ct]=dt(Ie[ct],Ie[wt],Ie[xt]);st.push(Mt),Dt=Dt.concat(Mt)}for(let De=0;De<S;De++){const Ge=De/S,Ie=g*Math.cos(Ge*Math.PI/2),ct=m*Math.sin(Ge*Math.PI/2)+x;for(let nt=0,wt=He.length;nt<wt;nt++){const xt=tt(He[nt],et[nt],ct);ve(xt.x,xt.y,-Ie)}for(let nt=0,wt=xe.length;nt<wt;nt++){const xt=xe[nt];Mt=st[nt];for(let St=0,jt=xt.length;St<jt;St++){const Pt=tt(xt[St],Mt[St],ct);ve(Pt.x,Pt.y,-Ie)}}}const Jt=m+x;for(let De=0;De<ft;De++){const Ge=d?tt(Ae[De],Dt[De],Jt):Ae[De];ge?(K.copy(ee.normals[0]).multiplyScalar(Ge.x),k.copy(ee.binormals[0]).multiplyScalar(Ge.y),le.copy(F[0]).add(K).add(k),ve(le.x,le.y,le.z)):ve(Ge.x,Ge.y,0)}for(let De=1;De<=u;De++)for(let Ge=0;Ge<ft;Ge++){const Ie=d?tt(Ae[Ge],Dt[Ge],Jt):Ae[Ge];ge?(K.copy(ee.normals[De]).multiplyScalar(Ie.x),k.copy(ee.binormals[De]).multiplyScalar(Ie.y),le.copy(F[De]).add(K).add(k),ve(le.x,le.y,le.z)):ve(Ie.x,Ie.y,p/u*De)}for(let De=S-1;De>=0;De--){const Ge=De/S,Ie=g*Math.cos(Ge*Math.PI/2),ct=m*Math.sin(Ge*Math.PI/2)+x;for(let nt=0,wt=He.length;nt<wt;nt++){const xt=tt(He[nt],et[nt],ct);ve(xt.x,xt.y,p+Ie)}for(let nt=0,wt=xe.length;nt<wt;nt++){const xt=xe[nt];Mt=st[nt];for(let St=0,jt=xt.length;St<jt;St++){const Pt=tt(xt[St],Mt[St],ct);ge?ve(Pt.x,Pt.y+F[u-1].y,F[u-1].x+Ie):ve(Pt.x,Pt.y,p+Ie)}}}function ce(De,Ge){let Ie=De.length;for(;--Ie>=0;){const ct=Ie;let nt=Ie-1;nt<0&&(nt=De.length-1);for(let wt=0,xt=u+2*S;wt<xt;wt++){const St=ft*wt,jt=ft*(wt+1);Ve(Ge+ct+St,Ge+nt+St,Ge+nt+jt,Ge+ct+jt)}}}function ve(De,Ge,Ie){s.push(De),s.push(Ge),s.push(Ie)}function ht(De,Ge,Ie){ne(De),ne(Ge),ne(Ie);const ct=r.length/3,nt=R.generateTopUV(n,r,ct-3,ct-2,ct-1);je(nt[0]),je(nt[1]),je(nt[2])}function Ve(De,Ge,Ie,ct){ne(De),ne(Ge),ne(ct),ne(Ge),ne(Ie),ne(ct);const nt=r.length/3,wt=R.generateSideWallUV(n,r,nt-6,nt-3,nt-2,nt-1);je(wt[0]),je(wt[1]),je(wt[3]),je(wt[1]),je(wt[2]),je(wt[3])}function ne(De){r.push(s[3*De+0]),r.push(s[3*De+1]),r.push(s[3*De+2])}function je(De){i.push(De.x),i.push(De.y)}!function(){const De=r.length/3;if(d){let Ge=0,Ie=ft*Ge;for(let ct=0;ct<ke;ct++){const nt=Xe[ct];ht(nt[2]+Ie,nt[1]+Ie,nt[0]+Ie)}Ge=u+2*S,Ie=ft*Ge;for(let ct=0;ct<ke;ct++){const nt=Xe[ct];ht(nt[0]+Ie,nt[1]+Ie,nt[2]+Ie)}}else{for(let Ge=0;Ge<ke;Ge++){const Ie=Xe[Ge];ht(Ie[2],Ie[1],Ie[0])}for(let Ge=0;Ge<ke;Ge++){const Ie=Xe[Ge];ht(Ie[0]+ft*u,Ie[1]+ft*u,Ie[2]+ft*u)}}n.addGroup(De,r.length/3-De,0)}(),function(){const De=r.length/3;let Ge=0;ce(He,Ge),Ge+=He.length;for(let Ie=0,ct=xe.length;Ie<ct;Ie++){const nt=xe[Ie];ce(nt,Ge),Ge+=nt.length}n.addGroup(De,r.length/3-De,1)}()}this.setAttribute("position",new yt(r,3)),this.setAttribute("uv",new yt(i,2)),this.computeVertexNormals()}toJSON(){const e=Ct.prototype.toJSON.call(this);return function(t,n,r){if(r.shapes=[],Array.isArray(t))for(let i=0,o=t.length;i<o;i++){const a=t[i];r.shapes.push(a.uuid)}else r.shapes.push(t.uuid);return n.extrudePath!==void 0&&(r.options.extrudePath=n.extrudePath.toJSON()),r}(this.parameters.shapes,this.parameters.options,e)}}const xm={generateTopUV:function(e,t,n,r,i){const o=t[3*n],a=t[3*n+1],s=t[3*r],c=t[3*r+1],u=t[3*i],p=t[3*i+1];return[new Je(o,a),new Je(s,c),new Je(u,p)]},generateSideWallUV:function(e,t,n,r,i,o){const a=t[3*n],s=t[3*n+1],c=t[3*n+2],u=t[3*r],p=t[3*r+1],d=t[3*r+2],g=t[3*i],m=t[3*i+1],x=t[3*i+2],S=t[3*o],b=t[3*o+1],R=t[3*o+2];return Math.abs(s-p)<.01?[new Je(a,1-c),new Je(u,1-d),new Je(g,1-x),new Je(S,1-R)]:[new Je(s,1-c),new Je(p,1-d),new Je(m,1-x),new Je(b,1-R)]}};class $c extends rn{constructor(e,t){super(),this.type="ExtrudeGeometry",this.parameters={shapes:e,options:t},this.fromBufferGeometry(new fa(e,t)),this.mergeVertices()}toJSON(){const e=super.toJSON();return function(t,n,r){if(r.shapes=[],Array.isArray(t))for(let i=0,o=t.length;i<o;i++){const a=t[i];r.shapes.push(a.uuid)}else r.shapes.push(t.uuid);return n.extrudePath!==void 0&&(r.options.extrudePath=n.extrudePath.toJSON()),r}(this.parameters.shapes,this.parameters.options,e)}}class el extends Ci{constructor(e=1,t=0){const n=(1+Math.sqrt(5))/2;super([-1,n,0,1,n,0,-1,-n,0,1,-n,0,0,-1,n,0,1,n,0,-1,-n,0,1,-n,n,0,-1,n,0,1,-n,0,-1,-n,0,1],[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1],e,t),this.type="IcosahedronBufferGeometry",this.parameters={radius:e,detail:t}}}class Wh extends rn{constructor(e,t){super(),this.type="IcosahedronGeometry",this.parameters={radius:e,detail:t},this.fromBufferGeometry(new el(e,t)),this.mergeVertices()}}class tl extends Ct{constructor(e,t=12,n=0,r=2*Math.PI){super(),this.type="LatheBufferGeometry",this.parameters={points:e,segments:t,phiStart:n,phiLength:r},t=Math.floor(t),r=Ft.clamp(r,0,2*Math.PI);const i=[],o=[],a=[],s=1/t,c=new z,u=new Je;for(let p=0;p<=t;p++){const d=n+p*s*r,g=Math.sin(d),m=Math.cos(d);for(let x=0;x<=e.length-1;x++)c.x=e[x].x*g,c.y=e[x].y,c.z=e[x].x*m,o.push(c.x,c.y,c.z),u.x=p/t,u.y=x/(e.length-1),a.push(u.x,u.y)}for(let p=0;p<t;p++)for(let d=0;d<e.length-1;d++){const g=d+p*e.length,m=g,x=g+e.length,S=g+e.length+1,b=g+1;i.push(m,x,b),i.push(x,S,b)}if(this.setIndex(i),this.setAttribute("position",new yt(o,3)),this.setAttribute("uv",new yt(a,2)),this.computeVertexNormals(),r===2*Math.PI){const p=this.attributes.normal.array,d=new z,g=new z,m=new z,x=t*e.length*3;for(let S=0,b=0;S<e.length;S++,b+=3)d.x=p[b+0],d.y=p[b+1],d.z=p[b+2],g.x=p[x+b+0],g.y=p[x+b+1],g.z=p[x+b+2],m.addVectors(d,g).normalize(),p[b+0]=p[x+b+0]=m.x,p[b+1]=p[x+b+1]=m.y,p[b+2]=p[x+b+2]=m.z}}}class Xh extends rn{constructor(e,t,n,r){super(),this.type="LatheGeometry",this.parameters={points:e,segments:t,phiStart:n,phiLength:r},this.fromBufferGeometry(new tl(e,t,n,r)),this.mergeVertices()}}class ys extends Ci{constructor(e=1,t=0){super([1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1],[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2],e,t),this.type="OctahedronBufferGeometry",this.parameters={radius:e,detail:t}}}class qh extends rn{constructor(e,t){super(),this.type="OctahedronGeometry",this.parameters={radius:e,detail:t},this.fromBufferGeometry(new ys(e,t)),this.mergeVertices()}}function yo(e,t,n){Ct.call(this),this.type="ParametricBufferGeometry",this.parameters={func:e,slices:t,stacks:n};const r=[],i=[],o=[],a=[],s=1e-5,c=new z,u=new z,p=new z,d=new z,g=new z;e.length<3&&console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");const m=t+1;for(let x=0;x<=n;x++){const S=x/n;for(let b=0;b<=t;b++){const R=b/t;e(R,S,u),i.push(u.x,u.y,u.z),R-s>=0?(e(R-s,S,p),d.subVectors(u,p)):(e(R+s,S,p),d.subVectors(p,u)),S-s>=0?(e(R,S-s,p),g.subVectors(u,p)):(e(R,S+s,p),g.subVectors(p,u)),c.crossVectors(d,g).normalize(),o.push(c.x,c.y,c.z),a.push(R,S)}}for(let x=0;x<n;x++)for(let S=0;S<t;S++){const b=x*m+S,R=x*m+S+1,F=(x+1)*m+S+1,ee=(x+1)*m+S;r.push(b,R,ee),r.push(R,F,ee)}this.setIndex(r),this.setAttribute("position",new yt(i,3)),this.setAttribute("normal",new yt(o,3)),this.setAttribute("uv",new yt(a,2))}function ma(e,t,n){rn.call(this),this.type="ParametricGeometry",this.parameters={func:e,slices:t,stacks:n},this.fromBufferGeometry(new yo(e,t,n)),this.mergeVertices()}yo.prototype=Object.create(Ct.prototype),yo.prototype.constructor=yo,ma.prototype=Object.create(rn.prototype),ma.prototype.constructor=ma;class Yh extends rn{constructor(e,t,n,r){super(),this.type="PlaneGeometry",this.parameters={width:e,height:t,widthSegments:n,heightSegments:r},this.fromBufferGeometry(new Ja(e,t,n,r)),this.mergeVertices()}}class Zh extends rn{constructor(e,t,n,r){super(),this.type="PolyhedronGeometry",this.parameters={vertices:e,indices:t,radius:n,detail:r},this.fromBufferGeometry(new Ci(e,t,n,r)),this.mergeVertices()}}class nl extends Ct{constructor(e=.5,t=1,n=8,r=1,i=0,o=2*Math.PI){super(),this.type="RingBufferGeometry",this.parameters={innerRadius:e,outerRadius:t,thetaSegments:n,phiSegments:r,thetaStart:i,thetaLength:o},n=Math.max(3,n);const a=[],s=[],c=[],u=[];let p=e;const d=(t-e)/(r=Math.max(1,r)),g=new z,m=new Je;for(let x=0;x<=r;x++){for(let S=0;S<=n;S++){const b=i+S/n*o;g.x=p*Math.cos(b),g.y=p*Math.sin(b),s.push(g.x,g.y,g.z),c.push(0,0,1),m.x=(g.x/t+1)/2,m.y=(g.y/t+1)/2,u.push(m.x,m.y)}p+=d}for(let x=0;x<r;x++){const S=x*(n+1);for(let b=0;b<n;b++){const R=b+S,F=R,ee=R+n+1,k=R+n+2,K=R+1;a.push(F,ee,K),a.push(ee,k,K)}}this.setIndex(a),this.setAttribute("position",new yt(s,3)),this.setAttribute("normal",new yt(c,3)),this.setAttribute("uv",new yt(u,2))}}class Jh extends rn{constructor(e,t,n,r,i,o){super(),this.type="RingGeometry",this.parameters={innerRadius:e,outerRadius:t,thetaSegments:n,phiSegments:r,thetaStart:i,thetaLength:o},this.fromBufferGeometry(new nl(e,t,n,r,i,o)),this.mergeVertices()}}class rl extends Ct{constructor(e,t=12){super(),this.type="ShapeBufferGeometry",this.parameters={shapes:e,curveSegments:t};const n=[],r=[],i=[],o=[];let a=0,s=0;if(Array.isArray(e)===!1)c(e);else for(let u=0;u<e.length;u++)c(e[u]),this.addGroup(a,s,u),a+=s,s=0;function c(u){const p=r.length/3,d=u.extractPoints(t);let g=d.shape;const m=d.holes;jr.isClockWise(g)===!1&&(g=g.reverse());for(let S=0,b=m.length;S<b;S++){const R=m[S];jr.isClockWise(R)===!0&&(m[S]=R.reverse())}const x=jr.triangulateShape(g,m);for(let S=0,b=m.length;S<b;S++){const R=m[S];g=g.concat(R)}for(let S=0,b=g.length;S<b;S++){const R=g[S];r.push(R.x,R.y,0),i.push(0,0,1),o.push(R.x,R.y)}for(let S=0,b=x.length;S<b;S++){const R=x[S],F=R[0]+p,ee=R[1]+p,k=R[2]+p;n.push(F,ee,k),s+=3}}this.setIndex(n),this.setAttribute("position",new yt(r,3)),this.setAttribute("normal",new yt(i,3)),this.setAttribute("uv",new yt(o,2))}toJSON(){const e=Ct.prototype.toJSON.call(this);return function(t,n){if(n.shapes=[],Array.isArray(t))for(let r=0,i=t.length;r<i;r++){const o=t[r];n.shapes.push(o.uuid)}else n.shapes.push(t.uuid);return n}(this.parameters.shapes,e)}}class il extends rn{constructor(e,t){super(),this.type="ShapeGeometry",typeof t=="object"&&(console.warn("THREE.ShapeGeometry: Options parameter has been removed."),t=t.curveSegments),this.parameters={shapes:e,curveSegments:t},this.fromBufferGeometry(new rl(e,t)),this.mergeVertices()}toJSON(){const e=rn.prototype.toJSON.call(this);return function(t,n){if(n.shapes=[],Array.isArray(t))for(let r=0,i=t.length;r<i;r++){const o=t[r];n.shapes.push(o.uuid)}else n.shapes.push(t.uuid);return n}(this.parameters.shapes,e)}}class xs extends Ct{constructor(e=1,t=8,n=6,r=0,i=2*Math.PI,o=0,a=Math.PI){super(),this.type="SphereBufferGeometry",this.parameters={radius:e,widthSegments:t,heightSegments:n,phiStart:r,phiLength:i,thetaStart:o,thetaLength:a},t=Math.max(3,Math.floor(t)),n=Math.max(2,Math.floor(n));const s=Math.min(o+a,Math.PI);let c=0;const u=[],p=new z,d=new z,g=[],m=[],x=[],S=[];for(let b=0;b<=n;b++){const R=[],F=b/n;let ee=0;b==0&&o==0?ee=.5/t:b==n&&s==Math.PI&&(ee=-.5/t);for(let k=0;k<=t;k++){const K=k/t;p.x=-e*Math.cos(r+K*i)*Math.sin(o+F*a),p.y=e*Math.cos(o+F*a),p.z=e*Math.sin(r+K*i)*Math.sin(o+F*a),m.push(p.x,p.y,p.z),d.copy(p).normalize(),x.push(d.x,d.y,d.z),S.push(K+ee,1-F),R.push(c++)}u.push(R)}for(let b=0;b<n;b++)for(let R=0;R<t;R++){const F=u[b][R+1],ee=u[b][R],k=u[b+1][R],K=u[b+1][R+1];(b!==0||o>0)&&g.push(F,ee,K),(b!==n-1||s<Math.PI)&&g.push(ee,k,K)}this.setIndex(g),this.setAttribute("position",new yt(m,3)),this.setAttribute("normal",new yt(x,3)),this.setAttribute("uv",new yt(S,2))}}class Kh extends rn{constructor(e,t,n,r,i,o,a){super(),this.type="SphereGeometry",this.parameters={radius:e,widthSegments:t,heightSegments:n,phiStart:r,phiLength:i,thetaStart:o,thetaLength:a},this.fromBufferGeometry(new xs(e,t,n,r,i,o,a)),this.mergeVertices()}}class ol extends Ci{constructor(e=1,t=0){super([1,1,1,-1,-1,1,-1,1,-1,1,-1,-1],[2,1,0,0,3,2,1,3,0,2,3,1],e,t),this.type="TetrahedronBufferGeometry",this.parameters={radius:e,detail:t}}}class Qh extends rn{constructor(e,t){super(),this.type="TetrahedronGeometry",this.parameters={radius:e,detail:t},this.fromBufferGeometry(new ol(e,t)),this.mergeVertices()}}class al extends fa{constructor(e,t={}){const n=t.font;if(!n||!n.isFont)return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."),new Ct;const r=n.generateShapes(e,t.size);t.depth=t.height!==void 0?t.height:50,t.bevelThickness===void 0&&(t.bevelThickness=10),t.bevelSize===void 0&&(t.bevelSize=8),t.bevelEnabled===void 0&&(t.bevelEnabled=!1),super(r,t),this.type="TextBufferGeometry"}}class $h extends rn{constructor(e,t){super(),this.type="TextGeometry",this.parameters={text:e,parameters:t},this.fromBufferGeometry(new al(e,t)),this.mergeVertices()}}class sl extends Ct{constructor(e=1,t=.4,n=8,r=6,i=2*Math.PI){super(),this.type="TorusBufferGeometry",this.parameters={radius:e,tube:t,radialSegments:n,tubularSegments:r,arc:i},n=Math.floor(n),r=Math.floor(r);const o=[],a=[],s=[],c=[],u=new z,p=new z,d=new z;for(let g=0;g<=n;g++)for(let m=0;m<=r;m++){const x=m/r*i,S=g/n*Math.PI*2;p.x=(e+t*Math.cos(S))*Math.cos(x),p.y=(e+t*Math.cos(S))*Math.sin(x),p.z=t*Math.sin(S),a.push(p.x,p.y,p.z),u.x=e*Math.cos(x),u.y=e*Math.sin(x),d.subVectors(p,u).normalize(),s.push(d.x,d.y,d.z),c.push(m/r),c.push(g/n)}for(let g=1;g<=n;g++)for(let m=1;m<=r;m++){const x=(r+1)*g+m-1,S=(r+1)*(g-1)+m-1,b=(r+1)*(g-1)+m,R=(r+1)*g+m;o.push(x,S,R),o.push(S,b,R)}this.setIndex(o),this.setAttribute("position",new yt(a,3)),this.setAttribute("normal",new yt(s,3)),this.setAttribute("uv",new yt(c,2))}}class ed extends rn{constructor(e,t,n,r,i){super(),this.type="TorusGeometry",this.parameters={radius:e,tube:t,radialSegments:n,tubularSegments:r,arc:i},this.fromBufferGeometry(new sl(e,t,n,r,i)),this.mergeVertices()}}class cl extends Ct{constructor(e=1,t=.4,n=64,r=8,i=2,o=3){super(),this.type="TorusKnotBufferGeometry",this.parameters={radius:e,tube:t,tubularSegments:n,radialSegments:r,p:i,q:o},n=Math.floor(n),r=Math.floor(r);const a=[],s=[],c=[],u=[],p=new z,d=new z,g=new z,m=new z,x=new z,S=new z,b=new z;for(let F=0;F<=n;++F){const ee=F/n*i*Math.PI*2;R(ee,i,o,e,g),R(ee+.01,i,o,e,m),S.subVectors(m,g),b.addVectors(m,g),x.crossVectors(S,b),b.crossVectors(x,S),x.normalize(),b.normalize();for(let k=0;k<=r;++k){const K=k/r*Math.PI*2,le=-t*Math.cos(K),ge=t*Math.sin(K);p.x=g.x+(le*b.x+ge*x.x),p.y=g.y+(le*b.y+ge*x.y),p.z=g.z+(le*b.z+ge*x.z),s.push(p.x,p.y,p.z),d.subVectors(p,g).normalize(),c.push(d.x,d.y,d.z),u.push(F/n),u.push(k/r)}}for(let F=1;F<=n;F++)for(let ee=1;ee<=r;ee++){const k=(r+1)*(F-1)+(ee-1),K=(r+1)*F+(ee-1),le=(r+1)*F+ee,ge=(r+1)*(F-1)+ee;a.push(k,K,ge),a.push(K,le,ge)}function R(F,ee,k,K,le){const ge=Math.cos(F),Le=Math.sin(F),Ae=k/ee*F,xe=Math.cos(Ae);le.x=K*(2+xe)*.5*ge,le.y=K*(2+xe)*Le*.5,le.z=K*Math.sin(Ae)*.5}this.setIndex(a),this.setAttribute("position",new yt(s,3)),this.setAttribute("normal",new yt(c,3)),this.setAttribute("uv",new yt(u,2))}}class td extends rn{constructor(e,t,n,r,i,o,a){super(),this.type="TorusKnotGeometry",this.parameters={radius:e,tube:t,tubularSegments:n,radialSegments:r,p:i,q:o},a!==void 0&&console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."),this.fromBufferGeometry(new cl(e,t,n,r,i,o)),this.mergeVertices()}}class ll extends Ct{constructor(e,t=64,n=1,r=8,i=!1){super(),this.type="TubeBufferGeometry",this.parameters={path:e,tubularSegments:t,radius:n,radialSegments:r,closed:i};const o=e.computeFrenetFrames(t,i);this.tangents=o.tangents,this.normals=o.normals,this.binormals=o.binormals;const a=new z,s=new z,c=new Je;let u=new z;const p=[],d=[],g=[],m=[];function x(S){u=e.getPointAt(S/t,u);const b=o.normals[S],R=o.binormals[S];for(let F=0;F<=r;F++){const ee=F/r*Math.PI*2,k=Math.sin(ee),K=-Math.cos(ee);s.x=K*b.x+k*R.x,s.y=K*b.y+k*R.y,s.z=K*b.z+k*R.z,s.normalize(),d.push(s.x,s.y,s.z),a.x=u.x+n*s.x,a.y=u.y+n*s.y,a.z=u.z+n*s.z,p.push(a.x,a.y,a.z)}}!function(){for(let S=0;S<t;S++)x(S);x(i===!1?t:0),function(){for(let S=0;S<=t;S++)for(let b=0;b<=r;b++)c.x=S/t,c.y=b/r,g.push(c.x,c.y)}(),function(){for(let S=1;S<=t;S++)for(let b=1;b<=r;b++){const R=(r+1)*(S-1)+(b-1),F=(r+1)*S+(b-1),ee=(r+1)*S+b,k=(r+1)*(S-1)+b;m.push(R,F,k),m.push(F,ee,k)}}()}(),this.setIndex(m),this.setAttribute("position",new yt(p,3)),this.setAttribute("normal",new yt(d,3)),this.setAttribute("uv",new yt(g,2))}toJSON(){const e=Ct.prototype.toJSON.call(this);return e.path=this.parameters.path.toJSON(),e}}class nd extends rn{constructor(e,t,n,r,i,o){super(),this.type="TubeGeometry",this.parameters={path:e,tubularSegments:t,radius:n,radialSegments:r,closed:i},o!==void 0&&console.warn("THREE.TubeGeometry: taper has been removed.");const a=new ll(e,t,n,r,i);this.tangents=a.tangents,this.normals=a.normals,this.binormals=a.binormals,this.fromBufferGeometry(a),this.mergeVertices()}}class ul extends Ct{constructor(e){super(),this.type="WireframeGeometry";const t=[],n=[0,0],r={},i=["a","b","c"];if(e&&e.isGeometry){const o=e.faces;for(let a=0,s=o.length;a<s;a++){const c=o[a];for(let u=0;u<3;u++){const p=c[i[u]],d=c[i[(u+1)%3]];n[0]=Math.min(p,d),n[1]=Math.max(p,d);const g=n[0]+","+n[1];r[g]===void 0&&(r[g]={index1:n[0],index2:n[1]})}}for(const a in r){const s=r[a];let c=e.vertices[s.index1];t.push(c.x,c.y,c.z),c=e.vertices[s.index2],t.push(c.x,c.y,c.z)}}else if(e&&e.isBufferGeometry){const o=new z;if(e.index!==null){const a=e.attributes.position,s=e.index;let c=e.groups;c.length===0&&(c=[{start:0,count:s.count,materialIndex:0}]);for(let u=0,p=c.length;u<p;++u){const d=c[u],g=d.start;for(let m=g,x=g+d.count;m<x;m+=3)for(let S=0;S<3;S++){const b=s.getX(m+S),R=s.getX(m+(S+1)%3);n[0]=Math.min(b,R),n[1]=Math.max(b,R);const F=n[0]+","+n[1];r[F]===void 0&&(r[F]={index1:n[0],index2:n[1]})}}for(const u in r){const p=r[u];o.fromBufferAttribute(a,p.index1),t.push(o.x,o.y,o.z),o.fromBufferAttribute(a,p.index2),t.push(o.x,o.y,o.z)}}else{const a=e.attributes.position;for(let s=0,c=a.count/3;s<c;s++)for(let u=0;u<3;u++){const p=3*s+u;o.fromBufferAttribute(a,p),t.push(o.x,o.y,o.z);const d=3*s+(u+1)%3;o.fromBufferAttribute(a,d),t.push(o.x,o.y,o.z)}}}this.setAttribute("position",new yt(t,3))}}var Xn=Object.freeze({__proto__:null,BoxGeometry:Wc,BoxBufferGeometry:qo,CircleGeometry:Nh,CircleBufferGeometry:Xc,ConeGeometry:Bh,ConeBufferGeometry:Fh,CylinderGeometry:qc,CylinderBufferGeometry:ua,DodecahedronGeometry:Uh,DodecahedronBufferGeometry:Yc,EdgesGeometry:Jc,ExtrudeGeometry:$c,ExtrudeBufferGeometry:fa,IcosahedronGeometry:Wh,IcosahedronBufferGeometry:el,LatheGeometry:Xh,LatheBufferGeometry:tl,OctahedronGeometry:qh,OctahedronBufferGeometry:ys,ParametricGeometry:ma,ParametricBufferGeometry:yo,PlaneGeometry:Yh,PlaneBufferGeometry:Ja,PolyhedronGeometry:Zh,PolyhedronBufferGeometry:Ci,RingGeometry:Jh,RingBufferGeometry:nl,ShapeGeometry:il,ShapeBufferGeometry:rl,SphereGeometry:Kh,SphereBufferGeometry:xs,TetrahedronGeometry:Qh,TetrahedronBufferGeometry:ol,TextGeometry:$h,TextBufferGeometry:al,TorusGeometry:ed,TorusBufferGeometry:sl,TorusKnotGeometry:td,TorusKnotBufferGeometry:cl,TubeGeometry:nd,TubeBufferGeometry:ll,WireframeGeometry:ul});function Pi(e){Nt.call(this),this.type="ShadowMaterial",this.color=new _t(0),this.transparent=!0,this.setValues(e)}function Wr(e){jn.call(this,e),this.type="RawShaderMaterial"}function Rr(e){Nt.call(this),this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new _t(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new _t(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=xi,this.normalScale=new Je(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.vertexTangents=!1,this.setValues(e)}function ui(e){Rr.call(this),this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.clearcoat=0,this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new Je(1,1),this.clearcoatNormalMap=null,this.reflectivity=.5,Object.defineProperty(this,"ior",{get:function(){return(1+.4*this.reflectivity)/(1-.4*this.reflectivity)},set:function(t){this.reflectivity=Ft.clamp(2.5*(t-1)/(t+1),0,1)}}),this.sheen=null,this.transmission=0,this.transmissionMap=null,this.setValues(e)}function hi(e){Nt.call(this),this.type="MeshPhongMaterial",this.color=new _t(16777215),this.specular=new _t(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new _t(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=xi,this.normalScale=new Je(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=Ze,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(e)}function Ri(e){Nt.call(this),this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new _t(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new _t(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=xi,this.normalScale=new Je(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(e)}function Oi(e){Nt.call(this),this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=xi,this.normalScale=new Je(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(e)}function Di(e){Nt.call(this),this.type="MeshLambertMaterial",this.color=new _t(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new _t(0),this.emissiveIntensity=1,this.emissiveMap=null,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=Ze,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(e)}function Ii(e){Nt.call(this),this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new _t(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=xi,this.normalScale=new Je(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(e)}function Ni(e){mn.call(this),this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(e)}Pi.prototype=Object.create(Nt.prototype),Pi.prototype.constructor=Pi,Pi.prototype.isShadowMaterial=!0,Pi.prototype.copy=function(e){return Nt.prototype.copy.call(this,e),this.color.copy(e.color),this},Wr.prototype=Object.create(jn.prototype),Wr.prototype.constructor=Wr,Wr.prototype.isRawShaderMaterial=!0,Rr.prototype=Object.create(Nt.prototype),Rr.prototype.constructor=Rr,Rr.prototype.isMeshStandardMaterial=!0,Rr.prototype.copy=function(e){return Nt.prototype.copy.call(this,e),this.defines={STANDARD:""},this.color.copy(e.color),this.roughness=e.roughness,this.metalness=e.metalness,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.roughnessMap=e.roughnessMap,this.metalnessMap=e.metalnessMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapIntensity=e.envMapIntensity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this.vertexTangents=e.vertexTangents,this},ui.prototype=Object.create(Rr.prototype),ui.prototype.constructor=ui,ui.prototype.isMeshPhysicalMaterial=!0,ui.prototype.copy=function(e){return Rr.prototype.copy.call(this,e),this.defines={STANDARD:"",PHYSICAL:""},this.clearcoat=e.clearcoat,this.clearcoatMap=e.clearcoatMap,this.clearcoatRoughness=e.clearcoatRoughness,this.clearcoatRoughnessMap=e.clearcoatRoughnessMap,this.clearcoatNormalMap=e.clearcoatNormalMap,this.clearcoatNormalScale.copy(e.clearcoatNormalScale),this.reflectivity=e.reflectivity,e.sheen?this.sheen=(this.sheen||new _t).copy(e.sheen):this.sheen=null,this.transmission=e.transmission,this.transmissionMap=e.transmissionMap,this},hi.prototype=Object.create(Nt.prototype),hi.prototype.constructor=hi,hi.prototype.isMeshPhongMaterial=!0,hi.prototype.copy=function(e){return Nt.prototype.copy.call(this,e),this.color.copy(e.color),this.specular.copy(e.specular),this.shininess=e.shininess,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this},Ri.prototype=Object.create(Nt.prototype),Ri.prototype.constructor=Ri,Ri.prototype.isMeshToonMaterial=!0,Ri.prototype.copy=function(e){return Nt.prototype.copy.call(this,e),this.color.copy(e.color),this.map=e.map,this.gradientMap=e.gradientMap,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this},Oi.prototype=Object.create(Nt.prototype),Oi.prototype.constructor=Oi,Oi.prototype.isMeshNormalMaterial=!0,Oi.prototype.copy=function(e){return Nt.prototype.copy.call(this,e),this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this},Di.prototype=Object.create(Nt.prototype),Di.prototype.constructor=Di,Di.prototype.isMeshLambertMaterial=!0,Di.prototype.copy=function(e){return Nt.prototype.copy.call(this,e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this},Ii.prototype=Object.create(Nt.prototype),Ii.prototype.constructor=Ii,Ii.prototype.isMeshMatcapMaterial=!0,Ii.prototype.copy=function(e){return Nt.prototype.copy.call(this,e),this.defines={MATCAP:""},this.color.copy(e.color),this.matcap=e.matcap,this.map=e.map,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this},Ni.prototype=Object.create(mn.prototype),Ni.prototype.constructor=Ni,Ni.prototype.isLineDashedMaterial=!0,Ni.prototype.copy=function(e){return mn.prototype.copy.call(this,e),this.scale=e.scale,this.dashSize=e.dashSize,this.gapSize=e.gapSize,this};var bm=Object.freeze({__proto__:null,ShadowMaterial:Pi,SpriteMaterial:ci,RawShaderMaterial:Wr,ShaderMaterial:jn,PointsMaterial:vr,MeshPhysicalMaterial:ui,MeshStandardMaterial:Rr,MeshPhongMaterial:hi,MeshToonMaterial:Ri,MeshNormalMaterial:Oi,MeshLambertMaterial:Di,MeshDepthMaterial:ii,MeshDistanceMaterial:oi,MeshBasicMaterial:sr,MeshMatcapMaterial:Ii,LineDashedMaterial:Ni,LineBasicMaterial:mn,Material:Nt});const fn={arraySlice:function(e,t,n){return fn.isTypedArray(e)?new e.constructor(e.subarray(t,n!==void 0?n:e.length)):e.slice(t,n)},convertArray:function(e,t,n){return!e||!n&&e.constructor===t?e:typeof t.BYTES_PER_ELEMENT=="number"?new t(e):Array.prototype.slice.call(e)},isTypedArray:function(e){return ArrayBuffer.isView(e)&&!(e instanceof DataView)},getKeyframeOrder:function(e){const t=e.length,n=new Array(t);for(let r=0;r!==t;++r)n[r]=r;return n.sort(function(r,i){return e[r]-e[i]}),n},sortedArray:function(e,t,n){const r=e.length,i=new e.constructor(r);for(let o=0,a=0;a!==r;++o){const s=n[o]*t;for(let c=0;c!==t;++c)i[a++]=e[s+c]}return i},flattenJSON:function(e,t,n,r){let i=1,o=e[0];for(;o!==void 0&&o[r]===void 0;)o=e[i++];if(o===void 0)return;let a=o[r];if(a!==void 0)if(Array.isArray(a))do a=o[r],a!==void 0&&(t.push(o.time),n.push.apply(n,a)),o=e[i++];while(o!==void 0);else if(a.toArray!==void 0)do a=o[r],a!==void 0&&(t.push(o.time),a.toArray(n,n.length)),o=e[i++];while(o!==void 0);else do a=o[r],a!==void 0&&(t.push(o.time),n.push(a)),o=e[i++];while(o!==void 0)},subclip:function(e,t,n,r,i=30){const o=e.clone();o.name=t;const a=[];for(let c=0;c<o.tracks.length;++c){const u=o.tracks[c],p=u.getValueSize(),d=[],g=[];for(let m=0;m<u.times.length;++m){const x=u.times[m]*i;if(!(x<n||x>=r)){d.push(u.times[m]);for(let S=0;S<p;++S)g.push(u.values[m*p+S])}}d.length!==0&&(u.times=fn.convertArray(d,u.times.constructor),u.values=fn.convertArray(g,u.values.constructor),a.push(u))}o.tracks=a;let s=1/0;for(let c=0;c<o.tracks.length;++c)s>o.tracks[c].times[0]&&(s=o.tracks[c].times[0]);for(let c=0;c<o.tracks.length;++c)o.tracks[c].shift(-1*s);return o.resetDuration(),o},makeClipAdditive:function(e,t=0,n=e,r=30){r<=0&&(r=30);const i=n.tracks.length,o=t/r;for(let a=0;a<i;++a){const s=n.tracks[a],c=s.ValueTypeName;if(c==="bool"||c==="string")continue;const u=e.tracks.find(function(R){return R.name===s.name&&R.ValueTypeName===c});if(u===void 0)continue;let p=0;const d=s.getValueSize();s.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(p=d/3);let g=0;const m=u.getValueSize();u.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(g=m/3);const x=s.times.length-1;let S;if(o<=s.times[0]){const R=p,F=d-p;S=fn.arraySlice(s.values,R,F)}else if(o>=s.times[x]){const R=x*d+p,F=R+d-p;S=fn.arraySlice(s.values,R,F)}else{const R=s.createInterpolant(),F=p,ee=d-p;R.evaluate(o),S=fn.arraySlice(R.resultBuffer,F,ee)}c==="quaternion"&&new Nn().fromArray(S).normalize().conjugate().toArray(S);const b=u.times.length;for(let R=0;R<b;++R){const F=R*m+g;if(c==="quaternion")Nn.multiplyQuaternionsFlat(u.values,F,S,0,u.values,F);else{const ee=m-2*g;for(let k=0;k<ee;++k)u.values[F+k]-=S[k]}}}return e.blendMode=sc,e}};function nr(e,t,n,r){this.parameterPositions=e,this._cachedIndex=0,this.resultBuffer=r!==void 0?r:new t.constructor(n),this.sampleValues=t,this.valueSize=n}function bs(e,t,n,r){nr.call(this,e,t,n,r),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0}function ga(e,t,n,r){nr.call(this,e,t,n,r)}function ws(e,t,n,r){nr.call(this,e,t,n,r)}function Rn(e,t,n,r){if(e===void 0)throw new Error("THREE.KeyframeTrack: track name is undefined");if(t===void 0||t.length===0)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+e);this.name=e,this.times=fn.convertArray(t,this.TimeBufferType),this.values=fn.convertArray(n,this.ValueBufferType),this.setInterpolation(r||this.DefaultInterpolation)}function _s(e,t,n){Rn.call(this,e,t,n)}function Ms(e,t,n,r){Rn.call(this,e,t,n,r)}function xo(e,t,n,r){Rn.call(this,e,t,n,r)}function Ss(e,t,n,r){nr.call(this,e,t,n,r)}function va(e,t,n,r){Rn.call(this,e,t,n,r)}function Ts(e,t,n,r){Rn.call(this,e,t,n,r)}function bo(e,t,n,r){Rn.call(this,e,t,n,r)}function rr(e,t,n,r){this.name=e,this.tracks=n,this.duration=t!==void 0?t:-1,this.blendMode=r!==void 0?r:Ra,this.uuid=Ft.generateUUID(),this.duration<0&&this.resetDuration()}function wm(e){if(e.type===void 0)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const t=function(n){switch(n.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return xo;case"vector":case"vector2":case"vector3":case"vector4":return bo;case"color":return Ms;case"quaternion":return va;case"bool":case"boolean":return _s;case"string":return Ts}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+n)}(e.type);if(e.times===void 0){const n=[],r=[];fn.flattenJSON(e.keys,n,r,"value"),e.times=n,e.values=r}return t.parse!==void 0?t.parse(e):new t(e.name,e.times,e.values,e.interpolation)}Object.assign(nr.prototype,{evaluate:function(e){const t=this.parameterPositions;let n=this._cachedIndex,r=t[n],i=t[n-1];e:{t:{let o;n:{r:if(!(e<r)){for(let a=n+2;;){if(r===void 0){if(e<i)break r;return n=t.length,this._cachedIndex=n,this.afterEnd_(n-1,e,i)}if(n===a)break;if(i=r,r=t[++n],e<r)break t}o=t.length;break n}if(e>=i)break e;{const a=t[1];e<a&&(n=2,i=a);for(let s=n-2;;){if(i===void 0)return this._cachedIndex=0,this.beforeStart_(0,e,r);if(n===s)break;if(r=i,i=t[--n-1],e>=i)break t}o=n,n=0}}for(;n<o;){const a=n+o>>>1;e<t[a]?o=a:n=a+1}if(r=t[n],i=t[n-1],i===void 0)return this._cachedIndex=0,this.beforeStart_(0,e,r);if(r===void 0)return n=t.length,this._cachedIndex=n,this.afterEnd_(n-1,i,e)}this._cachedIndex=n,this.intervalChanged_(n,i,r)}return this.interpolate_(n,i,e,r)},settings:null,DefaultSettings_:{},getSettings_:function(){return this.settings||this.DefaultSettings_},copySampleValue_:function(e){const t=this.resultBuffer,n=this.sampleValues,r=this.valueSize,i=e*r;for(let o=0;o!==r;++o)t[o]=n[i+o];return t},interpolate_:function(){throw new Error("call to abstract method")},intervalChanged_:function(){}}),Object.assign(nr.prototype,{beforeStart_:nr.prototype.copySampleValue_,afterEnd_:nr.prototype.copySampleValue_}),bs.prototype=Object.assign(Object.create(nr.prototype),{constructor:bs,DefaultSettings_:{endingStart:vi,endingEnd:vi},intervalChanged_:function(e,t,n){const r=this.parameterPositions;let i=e-2,o=e+1,a=r[i],s=r[o];if(a===void 0)switch(this.getSettings_().endingStart){case yi:i=e,a=2*t-n;break;case Co:i=r.length-2,a=t+r[i]-r[i+1];break;default:i=e,a=n}if(s===void 0)switch(this.getSettings_().endingEnd){case yi:o=e,s=2*n-t;break;case Co:o=1,s=n+r[1]-r[0];break;default:o=e-1,s=t}const c=.5*(n-t),u=this.valueSize;this._weightPrev=c/(t-a),this._weightNext=c/(s-n),this._offsetPrev=i*u,this._offsetNext=o*u},interpolate_:function(e,t,n,r){const i=this.resultBuffer,o=this.sampleValues,a=this.valueSize,s=e*a,c=s-a,u=this._offsetPrev,p=this._offsetNext,d=this._weightPrev,g=this._weightNext,m=(n-t)/(r-t),x=m*m,S=x*m,b=-d*S+2*d*x-d*m,R=(1+d)*S+(-1.5-2*d)*x+(-.5+d)*m+1,F=(-1-g)*S+(1.5+g)*x+.5*m,ee=g*S-g*x;for(let k=0;k!==a;++k)i[k]=b*o[u+k]+R*o[c+k]+F*o[s+k]+ee*o[p+k];return i}}),ga.prototype=Object.assign(Object.create(nr.prototype),{constructor:ga,interpolate_:function(e,t,n,r){const i=this.resultBuffer,o=this.sampleValues,a=this.valueSize,s=e*a,c=s-a,u=(n-t)/(r-t),p=1-u;for(let d=0;d!==a;++d)i[d]=o[c+d]*p+o[s+d]*u;return i}}),ws.prototype=Object.assign(Object.create(nr.prototype),{constructor:ws,interpolate_:function(e){return this.copySampleValue_(e-1)}}),Object.assign(Rn,{toJSON:function(e){const t=e.constructor;let n;if(t.toJSON!==void 0)n=t.toJSON(e);else{n={name:e.name,times:fn.convertArray(e.times,Array),values:fn.convertArray(e.values,Array)};const r=e.getInterpolation();r!==e.DefaultInterpolation&&(n.interpolation=r)}return n.type=e.ValueTypeName,n}}),Object.assign(Rn.prototype,{constructor:Rn,TimeBufferType:Float32Array,ValueBufferType:Float32Array,DefaultInterpolation:Lo,InterpolantFactoryMethodDiscrete:function(e){return new ws(this.times,this.values,this.getValueSize(),e)},InterpolantFactoryMethodLinear:function(e){return new ga(this.times,this.values,this.getValueSize(),e)},InterpolantFactoryMethodSmooth:function(e){return new bs(this.times,this.values,this.getValueSize(),e)},setInterpolation:function(e){let t;switch(e){case Ao:t=this.InterpolantFactoryMethodDiscrete;break;case Lo:t=this.InterpolantFactoryMethodLinear;break;case Pa:t=this.InterpolantFactoryMethodSmooth}if(t===void 0){const n="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(this.createInterpolant===void 0){if(e===this.DefaultInterpolation)throw new Error(n);this.setInterpolation(this.DefaultInterpolation)}return console.warn("THREE.KeyframeTrack:",n),this}return this.createInterpolant=t,this},getInterpolation:function(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return Ao;case this.InterpolantFactoryMethodLinear:return Lo;case this.InterpolantFactoryMethodSmooth:return Pa}},getValueSize:function(){return this.values.length/this.times.length},shift:function(e){if(e!==0){const t=this.times;for(let n=0,r=t.length;n!==r;++n)t[n]+=e}return this},scale:function(e){if(e!==1){const t=this.times;for(let n=0,r=t.length;n!==r;++n)t[n]*=e}return this},trim:function(e,t){const n=this.times,r=n.length;let i=0,o=r-1;for(;i!==r&&n[i]<e;)++i;for(;o!==-1&&n[o]>t;)--o;if(++o,i!==0||o!==r){i>=o&&(o=Math.max(o,1),i=o-1);const a=this.getValueSize();this.times=fn.arraySlice(n,i,o),this.values=fn.arraySlice(this.values,i*a,o*a)}return this},validate:function(){let e=!0;const t=this.getValueSize();t-Math.floor(t)!=0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),e=!1);const n=this.times,r=this.values,i=n.length;i===0&&(console.error("THREE.KeyframeTrack: Track is empty.",this),e=!1);let o=null;for(let a=0;a!==i;a++){const s=n[a];if(typeof s=="number"&&isNaN(s)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,a,s),e=!1;break}if(o!==null&&o>s){console.error("THREE.KeyframeTrack: Out of order keys.",this,a,s,o),e=!1;break}o=s}if(r!==void 0&&fn.isTypedArray(r))for(let a=0,s=r.length;a!==s;++a){const c=r[a];if(isNaN(c)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,a,c),e=!1;break}}return e},optimize:function(){const e=fn.arraySlice(this.times),t=fn.arraySlice(this.values),n=this.getValueSize(),r=this.getInterpolation()===Pa,i=e.length-1;let o=1;for(let a=1;a<i;++a){let s=!1;const c=e[a];if(c!==e[a+1]&&(a!==1||c!==c[0]))if(r)s=!0;else{const u=a*n,p=u-n,d=u+n;for(let g=0;g!==n;++g){const m=t[u+g];if(m!==t[p+g]||m!==t[d+g]){s=!0;break}}}if(s){if(a!==o){e[o]=e[a];const u=a*n,p=o*n;for(let d=0;d!==n;++d)t[p+d]=t[u+d]}++o}}if(i>0){e[o]=e[i];for(let a=i*n,s=o*n,c=0;c!==n;++c)t[s+c]=t[a+c];++o}return o!==e.length?(this.times=fn.arraySlice(e,0,o),this.values=fn.arraySlice(t,0,o*n)):(this.times=e,this.values=t),this},clone:function(){const e=fn.arraySlice(this.times,0),t=fn.arraySlice(this.values,0),n=new this.constructor(this.name,e,t);return n.createInterpolant=this.createInterpolant,n}}),_s.prototype=Object.assign(Object.create(Rn.prototype),{constructor:_s,ValueTypeName:"bool",ValueBufferType:Array,DefaultInterpolation:Ao,InterpolantFactoryMethodLinear:void 0,InterpolantFactoryMethodSmooth:void 0}),Ms.prototype=Object.assign(Object.create(Rn.prototype),{constructor:Ms,ValueTypeName:"color"}),xo.prototype=Object.assign(Object.create(Rn.prototype),{constructor:xo,ValueTypeName:"number"}),Ss.prototype=Object.assign(Object.create(nr.prototype),{constructor:Ss,interpolate_:function(e,t,n,r){const i=this.resultBuffer,o=this.sampleValues,a=this.valueSize,s=(n-t)/(r-t);let c=e*a;for(let u=c+a;c!==u;c+=4)Nn.slerpFlat(i,0,o,c-a,o,c,s);return i}}),va.prototype=Object.assign(Object.create(Rn.prototype),{constructor:va,ValueTypeName:"quaternion",DefaultInterpolation:Lo,InterpolantFactoryMethodLinear:function(e){return new Ss(this.times,this.values,this.getValueSize(),e)},InterpolantFactoryMethodSmooth:void 0}),Ts.prototype=Object.assign(Object.create(Rn.prototype),{constructor:Ts,ValueTypeName:"string",ValueBufferType:Array,DefaultInterpolation:Ao,InterpolantFactoryMethodLinear:void 0,InterpolantFactoryMethodSmooth:void 0}),bo.prototype=Object.assign(Object.create(Rn.prototype),{constructor:bo,ValueTypeName:"vector"}),Object.assign(rr,{parse:function(e){const t=[],n=e.tracks,r=1/(e.fps||1);for(let o=0,a=n.length;o!==a;++o)t.push(wm(n[o]).scale(r));const i=new rr(e.name,e.duration,t,e.blendMode);return i.uuid=e.uuid,i},toJSON:function(e){const t=[],n=e.tracks,r={name:e.name,duration:e.duration,tracks:t,uuid:e.uuid,blendMode:e.blendMode};for(let i=0,o=n.length;i!==o;++i)t.push(Rn.toJSON(n[i]));return r},CreateFromMorphTargetSequence:function(e,t,n,r){const i=t.length,o=[];for(let a=0;a<i;a++){let s=[],c=[];s.push((a+i-1)%i,a,(a+1)%i),c.push(0,1,0);const u=fn.getKeyframeOrder(s);s=fn.sortedArray(s,1,u),c=fn.sortedArray(c,1,u),r||s[0]!==0||(s.push(i),c.push(c[0])),o.push(new xo(".morphTargetInfluences["+t[a].name+"]",s,c).scale(1/n))}return new rr(e,-1,o)},findByName:function(e,t){let n=e;if(!Array.isArray(e)){const r=e;n=r.geometry&&r.geometry.animations||r.animations}for(let r=0;r<n.length;r++)if(n[r].name===t)return n[r];return null},CreateClipsFromMorphTargetSequences:function(e,t,n){const r={},i=/^([\w-]*?)([\d]+)$/;for(let a=0,s=e.length;a<s;a++){const c=e[a],u=c.name.match(i);if(u&&u.length>1){const p=u[1];let d=r[p];d||(r[p]=d=[]),d.push(c)}}const o=[];for(const a in r)o.push(rr.CreateFromMorphTargetSequence(a,r[a],t,n));return o},parseAnimation:function(e,t){if(!e)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const n=function(u,p,d,g,m){if(d.length!==0){const x=[],S=[];fn.flattenJSON(d,x,S,g),x.length!==0&&m.push(new u(p,x,S))}},r=[],i=e.name||"default",o=e.fps||30,a=e.blendMode;let s=e.length||-1;const c=e.hierarchy||[];for(let u=0;u<c.length;u++){const p=c[u].keys;if(p&&p.length!==0)if(p[0].morphTargets){const d={};let g;for(g=0;g<p.length;g++)if(p[g].morphTargets)for(let m=0;m<p[g].morphTargets.length;m++)d[p[g].morphTargets[m]]=-1;for(const m in d){const x=[],S=[];for(let b=0;b!==p[g].morphTargets.length;++b){const R=p[g];x.push(R.time),S.push(R.morphTarget===m?1:0)}r.push(new xo(".morphTargetInfluence["+m+"]",x,S))}s=d.length*(o||1)}else{const d=".bones["+t[u].name+"]";n(bo,d+".position",p,"pos",r),n(va,d+".quaternion",p,"rot",r),n(bo,d+".scale",p,"scl",r)}}return r.length===0?null:new rr(i,s,r,a)}}),Object.assign(rr.prototype,{resetDuration:function(){let e=0;for(let t=0,n=this.tracks.length;t!==n;++t){const r=this.tracks[t];e=Math.max(e,r.times[r.times.length-1])}return this.duration=e,this},trim:function(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].trim(0,this.duration);return this},validate:function(){let e=!0;for(let t=0;t<this.tracks.length;t++)e=e&&this.tracks[t].validate();return e},optimize:function(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].optimize();return this},clone:function(){const e=[];for(let t=0;t<this.tracks.length;t++)e.push(this.tracks[t].clone());return new rr(this.name,this.duration,e,this.blendMode)},toJSON:function(){return rr.toJSON(this)}});const Bi={enabled:!1,files:{},add:function(e,t){this.enabled!==!1&&(this.files[e]=t)},get:function(e){if(this.enabled!==!1)return this.files[e]},remove:function(e){delete this.files[e]},clear:function(){this.files={}}};function hl(e,t,n){const r=this;let i=!1,o=0,a=0,s;const c=[];this.onStart=void 0,this.onLoad=e,this.onProgress=t,this.onError=n,this.itemStart=function(u){a++,i===!1&&r.onStart!==void 0&&r.onStart(u,o,a),i=!0},this.itemEnd=function(u){o++,r.onProgress!==void 0&&r.onProgress(u,o,a),o===a&&(i=!1,r.onLoad!==void 0&&r.onLoad())},this.itemError=function(u){r.onError!==void 0&&r.onError(u)},this.resolveURL=function(u){return s?s(u):u},this.setURLModifier=function(u){return s=u,this},this.addHandler=function(u,p){return c.push(u,p),this},this.removeHandler=function(u){const p=c.indexOf(u);return p!==-1&&c.splice(p,2),this},this.getHandler=function(u){for(let p=0,d=c.length;p<d;p+=2){const g=c[p],m=c[p+1];if(g.global&&(g.lastIndex=0),g.test(u))return m}return null}}const rd=new hl;function en(e){this.manager=e!==void 0?e:rd,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}Object.assign(en.prototype,{load:function(){},loadAsync:function(e,t){const n=this;return new Promise(function(r,i){n.load(e,r,t,i)})},parse:function(){},setCrossOrigin:function(e){return this.crossOrigin=e,this},setWithCredentials:function(e){return this.withCredentials=e,this},setPath:function(e){return this.path=e,this},setResourcePath:function(e){return this.resourcePath=e,this},setRequestHeader:function(e){return this.requestHeader=e,this}});const yr={};function ur(e){en.call(this,e)}function dl(e){en.call(this,e)}function pl(e){en.call(this,e)}function wo(e){en.call(this,e)}function Es(e){en.call(this,e)}function As(e){en.call(this,e)}function Ls(e){en.call(this,e)}function Lt(){this.type="Curve",this.arcLengthDivisions=200}function ir(e,t,n,r,i,o,a,s){Lt.call(this),this.type="EllipseCurve",this.aX=e||0,this.aY=t||0,this.xRadius=n||1,this.yRadius=r||1,this.aStartAngle=i||0,this.aEndAngle=o||2*Math.PI,this.aClockwise=a||!1,this.aRotation=s||0}function _o(e,t,n,r,i,o){ir.call(this,e,t,n,n,r,i,o),this.type="ArcCurve"}function fl(){let e=0,t=0,n=0,r=0;function i(o,a,s,c){e=o,t=s,n=-3*o+3*a-2*s-c,r=2*o-2*a+s+c}return{initCatmullRom:function(o,a,s,c,u){i(a,s,u*(s-o),u*(c-a))},initNonuniformCatmullRom:function(o,a,s,c,u,p,d){let g=(a-o)/u-(s-o)/(u+p)+(s-a)/p,m=(s-a)/p-(c-a)/(p+d)+(c-s)/d;g*=p,m*=p,i(a,s,g,m)},calc:function(o){const a=o*o;return e+t*o+n*a+r*(a*o)}}}ur.prototype=Object.assign(Object.create(en.prototype),{constructor:ur,load:function(e,t,n,r){e===void 0&&(e=""),this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const i=this,o=Bi.get(e);if(o!==void 0)return i.manager.itemStart(e),setTimeout(function(){t&&t(o),i.manager.itemEnd(e)},0),o;if(yr[e]!==void 0)return void yr[e].push({onLoad:t,onProgress:n,onError:r});const a=e.match(/^data:(.*?)(;base64)?,(.*)$/);let s;if(a){const c=a[1],u=!!a[2];let p=a[3];p=decodeURIComponent(p),u&&(p=atob(p));try{let d;const g=(this.responseType||"").toLowerCase();switch(g){case"arraybuffer":case"blob":const m=new Uint8Array(p.length);for(let S=0;S<p.length;S++)m[S]=p.charCodeAt(S);d=g==="blob"?new Blob([m.buffer],{type:c}):m.buffer;break;case"document":const x=new DOMParser;d=x.parseFromString(p,c);break;case"json":d=JSON.parse(p);break;default:d=p}setTimeout(function(){t&&t(d),i.manager.itemEnd(e)},0)}catch(d){setTimeout(function(){r&&r(d),i.manager.itemError(e),i.manager.itemEnd(e)},0)}}else{yr[e]=[],yr[e].push({onLoad:t,onProgress:n,onError:r}),s=new XMLHttpRequest,s.open("GET",e,!0),s.addEventListener("load",function(c){const u=this.response,p=yr[e];if(delete yr[e],this.status===200||this.status===0){this.status===0&&console.warn("THREE.FileLoader: HTTP Status 0 received."),Bi.add(e,u);for(let d=0,g=p.length;d<g;d++){const m=p[d];m.onLoad&&m.onLoad(u)}i.manager.itemEnd(e)}else{for(let d=0,g=p.length;d<g;d++){const m=p[d];m.onError&&m.onError(c)}i.manager.itemError(e),i.manager.itemEnd(e)}},!1),s.addEventListener("progress",function(c){const u=yr[e];for(let p=0,d=u.length;p<d;p++){const g=u[p];g.onProgress&&g.onProgress(c)}},!1),s.addEventListener("error",function(c){const u=yr[e];delete yr[e];for(let p=0,d=u.length;p<d;p++){const g=u[p];g.onError&&g.onError(c)}i.manager.itemError(e),i.manager.itemEnd(e)},!1),s.addEventListener("abort",function(c){const u=yr[e];delete yr[e];for(let p=0,d=u.length;p<d;p++){const g=u[p];g.onError&&g.onError(c)}i.manager.itemError(e),i.manager.itemEnd(e)},!1),this.responseType!==void 0&&(s.responseType=this.responseType),this.withCredentials!==void 0&&(s.withCredentials=this.withCredentials),s.overrideMimeType&&s.overrideMimeType(this.mimeType!==void 0?this.mimeType:"text/plain");for(const c in this.requestHeader)s.setRequestHeader(c,this.requestHeader[c]);s.send(null)}return i.manager.itemStart(e),s},setResponseType:function(e){return this.responseType=e,this},setMimeType:function(e){return this.mimeType=e,this}}),dl.prototype=Object.assign(Object.create(en.prototype),{constructor:dl,load:function(e,t,n,r){const i=this,o=new ur(i.manager);o.setPath(i.path),o.setRequestHeader(i.requestHeader),o.setWithCredentials(i.withCredentials),o.load(e,function(a){try{t(i.parse(JSON.parse(a)))}catch(s){r?r(s):console.error(s),i.manager.itemError(e)}},n,r)},parse:function(e){const t=[];for(let n=0;n<e.length;n++){const r=rr.parse(e[n]);t.push(r)}return t}}),pl.prototype=Object.assign(Object.create(en.prototype),{constructor:pl,load:function(e,t,n,r){const i=this,o=[],a=new go;a.image=o;const s=new ur(this.manager);s.setPath(this.path),s.setResponseType("arraybuffer"),s.setRequestHeader(this.requestHeader),s.setWithCredentials(i.withCredentials);let c=0;function u(p){s.load(e[p],function(d){const g=i.parse(d,!0);o[p]={width:g.width,height:g.height,format:g.format,mipmaps:g.mipmaps},c+=1,c===6&&(g.mipmapCount===1&&(a.minFilter=se),a.format=g.format,a.needsUpdate=!0,t&&t(a))},n,r)}if(Array.isArray(e))for(let p=0,d=e.length;p<d;++p)u(p);else s.load(e,function(p){const d=i.parse(p,!0);if(d.isCubemap){const g=d.mipmaps.length/d.mipmapCount;for(let m=0;m<g;m++){o[m]={mipmaps:[]};for(let x=0;x<d.mipmapCount;x++)o[m].mipmaps.push(d.mipmaps[m*d.mipmapCount+x]),o[m].format=d.format,o[m].width=d.width,o[m].height=d.height}}else a.image.width=d.width,a.image.height=d.height,a.mipmaps=d.mipmaps;d.mipmapCount===1&&(a.minFilter=se),a.format=d.format,a.needsUpdate=!0,t&&t(a)},n,r);return a}}),wo.prototype=Object.assign(Object.create(en.prototype),{constructor:wo,load:function(e,t,n,r){this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const i=this,o=Bi.get(e);if(o!==void 0)return i.manager.itemStart(e),setTimeout(function(){t&&t(o),i.manager.itemEnd(e)},0),o;const a=document.createElementNS("http://www.w3.org/1999/xhtml","img");function s(){a.removeEventListener("load",s,!1),a.removeEventListener("error",c,!1),Bi.add(e,this),t&&t(this),i.manager.itemEnd(e)}function c(u){a.removeEventListener("load",s,!1),a.removeEventListener("error",c,!1),r&&r(u),i.manager.itemError(e),i.manager.itemEnd(e)}return a.addEventListener("load",s,!1),a.addEventListener("error",c,!1),e.substr(0,5)!=="data:"&&this.crossOrigin!==void 0&&(a.crossOrigin=this.crossOrigin),i.manager.itemStart(e),a.src=e,a}}),Es.prototype=Object.assign(Object.create(en.prototype),{constructor:Es,load:function(e,t,n,r){const i=new Cr,o=new wo(this.manager);o.setCrossOrigin(this.crossOrigin),o.setPath(this.path);let a=0;function s(c){o.load(e[c],function(u){i.images[c]=u,a++,a===6&&(i.needsUpdate=!0,t&&t(i))},void 0,r)}for(let c=0;c<e.length;++c)s(c);return i}}),As.prototype=Object.assign(Object.create(en.prototype),{constructor:As,load:function(e,t,n,r){const i=this,o=new Vr,a=new ur(this.manager);return a.setResponseType("arraybuffer"),a.setRequestHeader(this.requestHeader),a.setPath(this.path),a.setWithCredentials(i.withCredentials),a.load(e,function(s){const c=i.parse(s);c&&(c.image!==void 0?o.image=c.image:c.data!==void 0&&(o.image.width=c.width,o.image.height=c.height,o.image.data=c.data),o.wrapS=c.wrapS!==void 0?c.wrapS:v,o.wrapT=c.wrapT!==void 0?c.wrapT:v,o.magFilter=c.magFilter!==void 0?c.magFilter:se,o.minFilter=c.minFilter!==void 0?c.minFilter:se,o.anisotropy=c.anisotropy!==void 0?c.anisotropy:1,c.format!==void 0&&(o.format=c.format),c.type!==void 0&&(o.type=c.type),c.mipmaps!==void 0&&(o.mipmaps=c.mipmaps,o.minFilter=Be),c.mipmapCount===1&&(o.minFilter=se),o.needsUpdate=!0,t&&t(o,c))},n,r),o}}),Ls.prototype=Object.assign(Object.create(en.prototype),{constructor:Ls,load:function(e,t,n,r){const i=new tn,o=new wo(this.manager);return o.setCrossOrigin(this.crossOrigin),o.setPath(this.path),o.load(e,function(a){i.image=a;const s=e.search(/\.jpe?g($|\?)/i)>0||e.search(/^data\:image\/jpeg/)===0;i.format=s?En:In,i.needsUpdate=!0,t!==void 0&&t(i)},n,r),i}}),Object.assign(Lt.prototype,{getPoint:function(){return console.warn("THREE.Curve: .getPoint() not implemented."),null},getPointAt:function(e,t){const n=this.getUtoTmapping(e);return this.getPoint(n,t)},getPoints:function(e=5){const t=[];for(let n=0;n<=e;n++)t.push(this.getPoint(n/e));return t},getSpacedPoints:function(e=5){const t=[];for(let n=0;n<=e;n++)t.push(this.getPointAt(n/e));return t},getLength:function(){const e=this.getLengths();return e[e.length-1]},getLengths:function(e){if(e===void 0&&(e=this.arcLengthDivisions),this.cacheArcLengths&&this.cacheArcLengths.length===e+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const t=[];let n,r=this.getPoint(0),i=0;t.push(0);for(let o=1;o<=e;o++)n=this.getPoint(o/e),i+=n.distanceTo(r),t.push(i),r=n;return this.cacheArcLengths=t,t},updateArcLengths:function(){this.needsUpdate=!0,this.getLengths()},getUtoTmapping:function(e,t){const n=this.getLengths();let r=0;const i=n.length;let o;o=t||e*n[i-1];let a,s=0,c=i-1;for(;s<=c;)if(r=Math.floor(s+(c-s)/2),a=n[r]-o,a<0)s=r+1;else{if(!(a>0)){c=r;break}c=r-1}if(r=c,n[r]===o)return r/(i-1);const u=n[r];return(r+(o-u)/(n[r+1]-u))/(i-1)},getTangent:function(e,t){let n=e-1e-4,r=e+1e-4;n<0&&(n=0),r>1&&(r=1);const i=this.getPoint(n),o=this.getPoint(r),a=t||(i.isVector2?new Je:new z);return a.copy(o).sub(i).normalize(),a},getTangentAt:function(e,t){const n=this.getUtoTmapping(e);return this.getTangent(n,t)},computeFrenetFrames:function(e,t){const n=new z,r=[],i=[],o=[],a=new z,s=new Ht;for(let g=0;g<=e;g++){const m=g/e;r[g]=this.getTangentAt(m,new z),r[g].normalize()}i[0]=new z,o[0]=new z;let c=Number.MAX_VALUE;const u=Math.abs(r[0].x),p=Math.abs(r[0].y),d=Math.abs(r[0].z);u<=c&&(c=u,n.set(1,0,0)),p<=c&&(c=p,n.set(0,1,0)),d<=c&&n.set(0,0,1),a.crossVectors(r[0],n).normalize(),i[0].crossVectors(r[0],a),o[0].crossVectors(r[0],i[0]);for(let g=1;g<=e;g++){if(i[g]=i[g-1].clone(),o[g]=o[g-1].clone(),a.crossVectors(r[g-1],r[g]),a.length()>Number.EPSILON){a.normalize();const m=Math.acos(Ft.clamp(r[g-1].dot(r[g]),-1,1));i[g].applyMatrix4(s.makeRotationAxis(a,m))}o[g].crossVectors(r[g],i[g])}if(t===!0){let g=Math.acos(Ft.clamp(i[0].dot(i[e]),-1,1));g/=e,r[0].dot(a.crossVectors(i[0],i[e]))>0&&(g=-g);for(let m=1;m<=e;m++)i[m].applyMatrix4(s.makeRotationAxis(r[m],g*m)),o[m].crossVectors(r[m],i[m])}return{tangents:r,normals:i,binormals:o}},clone:function(){return new this.constructor().copy(this)},copy:function(e){return this.arcLengthDivisions=e.arcLengthDivisions,this},toJSON:function(){const e={metadata:{version:4.5,type:"Curve",generator:"Curve.toJSON"}};return e.arcLengthDivisions=this.arcLengthDivisions,e.type=this.type,e},fromJSON:function(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}}),ir.prototype=Object.create(Lt.prototype),ir.prototype.constructor=ir,ir.prototype.isEllipseCurve=!0,ir.prototype.getPoint=function(e,t){const n=t||new Je,r=2*Math.PI;let i=this.aEndAngle-this.aStartAngle;const o=Math.abs(i)<Number.EPSILON;for(;i<0;)i+=r;for(;i>r;)i-=r;i<Number.EPSILON&&(i=o?0:r),this.aClockwise!==!0||o||(i===r?i=-r:i-=r);const a=this.aStartAngle+e*i;let s=this.aX+this.xRadius*Math.cos(a),c=this.aY+this.yRadius*Math.sin(a);if(this.aRotation!==0){const u=Math.cos(this.aRotation),p=Math.sin(this.aRotation),d=s-this.aX,g=c-this.aY;s=d*u-g*p+this.aX,c=d*p+g*u+this.aY}return n.set(s,c)},ir.prototype.copy=function(e){return Lt.prototype.copy.call(this,e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this},ir.prototype.toJSON=function(){const e=Lt.prototype.toJSON.call(this);return e.aX=this.aX,e.aY=this.aY,e.xRadius=this.xRadius,e.yRadius=this.yRadius,e.aStartAngle=this.aStartAngle,e.aEndAngle=this.aEndAngle,e.aClockwise=this.aClockwise,e.aRotation=this.aRotation,e},ir.prototype.fromJSON=function(e){return Lt.prototype.fromJSON.call(this,e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this},_o.prototype=Object.create(ir.prototype),_o.prototype.constructor=_o,_o.prototype.isArcCurve=!0;const Cs=new z,ml=new fl,gl=new fl,vl=new fl;function Un(e=[],t=!1,n="centripetal",r=.5){Lt.call(this),this.type="CatmullRomCurve3",this.points=e,this.closed=t,this.curveType=n,this.tension=r}function id(e,t,n,r,i){const o=.5*(r-t),a=.5*(i-n),s=e*e;return(2*n-2*r+o+a)*(e*s)+(-3*n+3*r-2*o-a)*s+o*e+n}function ya(e,t,n,r){return function(i,o){const a=1-i;return a*a*o}(e,t)+function(i,o){return 2*(1-i)*i*o}(e,n)+function(i,o){return i*i*o}(e,r)}function xa(e,t,n,r,i){return function(o,a){const s=1-o;return s*s*s*a}(e,t)+function(o,a){const s=1-o;return 3*s*s*o*a}(e,n)+function(o,a){return 3*(1-o)*o*o*a}(e,r)+function(o,a){return o*o*o*a}(e,i)}function xr(e=new Je,t=new Je,n=new Je,r=new Je){Lt.call(this),this.type="CubicBezierCurve",this.v0=e,this.v1=t,this.v2=n,this.v3=r}function Or(e=new z,t=new z,n=new z,r=new z){Lt.call(this),this.type="CubicBezierCurve3",this.v0=e,this.v1=t,this.v2=n,this.v3=r}function qn(e=new Je,t=new Je){Lt.call(this),this.type="LineCurve",this.v1=e,this.v2=t}function br(e=new z,t=new z){Lt.call(this),this.type="LineCurve3",this.v1=e,this.v2=t}function wr(e=new Je,t=new Je,n=new Je){Lt.call(this),this.type="QuadraticBezierCurve",this.v0=e,this.v1=t,this.v2=n}function Dr(e=new z,t=new z,n=new z){Lt.call(this),this.type="QuadraticBezierCurve3",this.v0=e,this.v1=t,this.v2=n}function _r(e=[]){Lt.call(this),this.type="SplineCurve",this.points=e}Un.prototype=Object.create(Lt.prototype),Un.prototype.constructor=Un,Un.prototype.isCatmullRomCurve3=!0,Un.prototype.getPoint=function(e,t=new z){const n=t,r=this.points,i=r.length,o=(i-(this.closed?0:1))*e;let a,s,c=Math.floor(o),u=o-c;this.closed?c+=c>0?0:(Math.floor(Math.abs(c)/i)+1)*i:u===0&&c===i-1&&(c=i-2,u=1),this.closed||c>0?a=r[(c-1)%i]:(Cs.subVectors(r[0],r[1]).add(r[0]),a=Cs);const p=r[c%i],d=r[(c+1)%i];if(this.closed||c+2<i?s=r[(c+2)%i]:(Cs.subVectors(r[i-1],r[i-2]).add(r[i-1]),s=Cs),this.curveType==="centripetal"||this.curveType==="chordal"){const g=this.curveType==="chordal"?.5:.25;let m=Math.pow(a.distanceToSquared(p),g),x=Math.pow(p.distanceToSquared(d),g),S=Math.pow(d.distanceToSquared(s),g);x<1e-4&&(x=1),m<1e-4&&(m=x),S<1e-4&&(S=x),ml.initNonuniformCatmullRom(a.x,p.x,d.x,s.x,m,x,S),gl.initNonuniformCatmullRom(a.y,p.y,d.y,s.y,m,x,S),vl.initNonuniformCatmullRom(a.z,p.z,d.z,s.z,m,x,S)}else this.curveType==="catmullrom"&&(ml.initCatmullRom(a.x,p.x,d.x,s.x,this.tension),gl.initCatmullRom(a.y,p.y,d.y,s.y,this.tension),vl.initCatmullRom(a.z,p.z,d.z,s.z,this.tension));return n.set(ml.calc(u),gl.calc(u),vl.calc(u)),n},Un.prototype.copy=function(e){Lt.prototype.copy.call(this,e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const r=e.points[t];this.points.push(r.clone())}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this},Un.prototype.toJSON=function(){const e=Lt.prototype.toJSON.call(this);e.points=[];for(let t=0,n=this.points.length;t<n;t++){const r=this.points[t];e.points.push(r.toArray())}return e.closed=this.closed,e.curveType=this.curveType,e.tension=this.tension,e},Un.prototype.fromJSON=function(e){Lt.prototype.fromJSON.call(this,e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const r=e.points[t];this.points.push(new z().fromArray(r))}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this},xr.prototype=Object.create(Lt.prototype),xr.prototype.constructor=xr,xr.prototype.isCubicBezierCurve=!0,xr.prototype.getPoint=function(e,t=new Je){const n=t,r=this.v0,i=this.v1,o=this.v2,a=this.v3;return n.set(xa(e,r.x,i.x,o.x,a.x),xa(e,r.y,i.y,o.y,a.y)),n},xr.prototype.copy=function(e){return Lt.prototype.copy.call(this,e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this},xr.prototype.toJSON=function(){const e=Lt.prototype.toJSON.call(this);return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e},xr.prototype.fromJSON=function(e){return Lt.prototype.fromJSON.call(this,e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this},Or.prototype=Object.create(Lt.prototype),Or.prototype.constructor=Or,Or.prototype.isCubicBezierCurve3=!0,Or.prototype.getPoint=function(e,t=new z){const n=t,r=this.v0,i=this.v1,o=this.v2,a=this.v3;return n.set(xa(e,r.x,i.x,o.x,a.x),xa(e,r.y,i.y,o.y,a.y),xa(e,r.z,i.z,o.z,a.z)),n},Or.prototype.copy=function(e){return Lt.prototype.copy.call(this,e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this},Or.prototype.toJSON=function(){const e=Lt.prototype.toJSON.call(this);return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e},Or.prototype.fromJSON=function(e){return Lt.prototype.fromJSON.call(this,e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this},qn.prototype=Object.create(Lt.prototype),qn.prototype.constructor=qn,qn.prototype.isLineCurve=!0,qn.prototype.getPoint=function(e,t=new Je){const n=t;return e===1?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(e).add(this.v1)),n},qn.prototype.getPointAt=function(e,t){return this.getPoint(e,t)},qn.prototype.getTangent=function(e,t){const n=t||new Je;return n.copy(this.v2).sub(this.v1).normalize(),n},qn.prototype.copy=function(e){return Lt.prototype.copy.call(this,e),this.v1.copy(e.v1),this.v2.copy(e.v2),this},qn.prototype.toJSON=function(){const e=Lt.prototype.toJSON.call(this);return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e},qn.prototype.fromJSON=function(e){return Lt.prototype.fromJSON.call(this,e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this},br.prototype=Object.create(Lt.prototype),br.prototype.constructor=br,br.prototype.isLineCurve3=!0,br.prototype.getPoint=function(e,t=new z){const n=t;return e===1?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(e).add(this.v1)),n},br.prototype.getPointAt=function(e,t){return this.getPoint(e,t)},br.prototype.copy=function(e){return Lt.prototype.copy.call(this,e),this.v1.copy(e.v1),this.v2.copy(e.v2),this},br.prototype.toJSON=function(){const e=Lt.prototype.toJSON.call(this);return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e},br.prototype.fromJSON=function(e){return Lt.prototype.fromJSON.call(this,e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this},wr.prototype=Object.create(Lt.prototype),wr.prototype.constructor=wr,wr.prototype.isQuadraticBezierCurve=!0,wr.prototype.getPoint=function(e,t=new Je){const n=t,r=this.v0,i=this.v1,o=this.v2;return n.set(ya(e,r.x,i.x,o.x),ya(e,r.y,i.y,o.y)),n},wr.prototype.copy=function(e){return Lt.prototype.copy.call(this,e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this},wr.prototype.toJSON=function(){const e=Lt.prototype.toJSON.call(this);return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e},wr.prototype.fromJSON=function(e){return Lt.prototype.fromJSON.call(this,e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this},Dr.prototype=Object.create(Lt.prototype),Dr.prototype.constructor=Dr,Dr.prototype.isQuadraticBezierCurve3=!0,Dr.prototype.getPoint=function(e,t=new z){const n=t,r=this.v0,i=this.v1,o=this.v2;return n.set(ya(e,r.x,i.x,o.x),ya(e,r.y,i.y,o.y),ya(e,r.z,i.z,o.z)),n},Dr.prototype.copy=function(e){return Lt.prototype.copy.call(this,e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this},Dr.prototype.toJSON=function(){const e=Lt.prototype.toJSON.call(this);return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e},Dr.prototype.fromJSON=function(e){return Lt.prototype.fromJSON.call(this,e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this},_r.prototype=Object.create(Lt.prototype),_r.prototype.constructor=_r,_r.prototype.isSplineCurve=!0,_r.prototype.getPoint=function(e,t=new Je){const n=t,r=this.points,i=(r.length-1)*e,o=Math.floor(i),a=i-o,s=r[o===0?o:o-1],c=r[o],u=r[o>r.length-2?r.length-1:o+1],p=r[o>r.length-3?r.length-1:o+2];return n.set(id(a,s.x,c.x,u.x,p.x),id(a,s.y,c.y,u.y,p.y)),n},_r.prototype.copy=function(e){Lt.prototype.copy.call(this,e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const r=e.points[t];this.points.push(r.clone())}return this},_r.prototype.toJSON=function(){const e=Lt.prototype.toJSON.call(this);e.points=[];for(let t=0,n=this.points.length;t<n;t++){const r=this.points[t];e.points.push(r.toArray())}return e},_r.prototype.fromJSON=function(e){Lt.prototype.fromJSON.call(this,e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const r=e.points[t];this.points.push(new Je().fromArray(r))}return this};var yl=Object.freeze({__proto__:null,ArcCurve:_o,CatmullRomCurve3:Un,CubicBezierCurve:xr,CubicBezierCurve3:Or,EllipseCurve:ir,LineCurve:qn,LineCurve3:br,QuadraticBezierCurve:wr,QuadraticBezierCurve3:Dr,SplineCurve:_r});function Xr(){Lt.call(this),this.type="CurvePath",this.curves=[],this.autoClose=!1}function Mr(e){Xr.call(this),this.type="Path",this.currentPoint=new Je,e&&this.setFromPoints(e)}function di(e){Mr.call(this,e),this.uuid=Ft.generateUUID(),this.type="Shape",this.holes=[]}function ln(e,t=1){At.call(this),this.type="Light",this.color=new _t(e),this.intensity=t}function Ps(e,t,n){ln.call(this,e,n),this.type="HemisphereLight",this.position.copy(At.DefaultUp),this.updateMatrix(),this.groundColor=new _t(t)}function qr(e){this.camera=e,this.bias=0,this.normalBias=0,this.radius=1,this.mapSize=new Je(512,512),this.map=null,this.mapPass=null,this.matrix=new Ht,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new Yo,this._frameExtents=new Je(1,1),this._viewportCount=1,this._viewports=[new nn(0,0,1,1)]}function xl(){qr.call(this,new _n(50,1,.5,500)),this.focus=1}function Rs(e,t,n,r,i,o){ln.call(this,e,t),this.type="SpotLight",this.position.copy(At.DefaultUp),this.updateMatrix(),this.target=new At,Object.defineProperty(this,"power",{get:function(){return this.intensity*Math.PI},set:function(a){this.intensity=a/Math.PI}}),this.distance=n!==void 0?n:0,this.angle=r!==void 0?r:Math.PI/3,this.penumbra=i!==void 0?i:0,this.decay=o!==void 0?o:1,this.shadow=new xl}function bl(){qr.call(this,new _n(90,1,.5,500)),this._frameExtents=new Je(4,2),this._viewportCount=6,this._viewports=[new nn(2,1,1,1),new nn(0,1,1,1),new nn(3,1,1,1),new nn(1,1,1,1),new nn(3,0,1,1),new nn(1,0,1,1)],this._cubeDirections=[new z(1,0,0),new z(-1,0,0),new z(0,0,1),new z(0,0,-1),new z(0,1,0),new z(0,-1,0)],this._cubeUps=[new z(0,1,0),new z(0,1,0),new z(0,1,0),new z(0,1,0),new z(0,0,1),new z(0,0,-1)]}function Os(e,t,n,r){ln.call(this,e,t),this.type="PointLight",Object.defineProperty(this,"power",{get:function(){return 4*this.intensity*Math.PI},set:function(i){this.intensity=i/(4*Math.PI)}}),this.distance=n!==void 0?n:0,this.decay=r!==void 0?r:1,this.shadow=new bl}function Mo(e,t,n,r,i,o){Lr.call(this),this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=e!==void 0?e:-1,this.right=t!==void 0?t:1,this.top=n!==void 0?n:1,this.bottom=r!==void 0?r:-1,this.near=i!==void 0?i:.1,this.far=o!==void 0?o:2e3,this.updateProjectionMatrix()}function wl(){qr.call(this,new Mo(-5,5,5,-5,.5,500))}function Ds(e,t){ln.call(this,e,t),this.type="DirectionalLight",this.position.copy(At.DefaultUp),this.updateMatrix(),this.target=new At,this.shadow=new wl}function Is(e,t){ln.call(this,e,t),this.type="AmbientLight"}function Ns(e,t,n,r){ln.call(this,e,t),this.type="RectAreaLight",this.width=n!==void 0?n:10,this.height=r!==void 0?r:10}Xr.prototype=Object.assign(Object.create(Lt.prototype),{constructor:Xr,add:function(e){this.curves.push(e)},closePath:function(){const e=this.curves[0].getPoint(0),t=this.curves[this.curves.length-1].getPoint(1);e.equals(t)||this.curves.push(new qn(t,e))},getPoint:function(e){const t=e*this.getLength(),n=this.getCurveLengths();let r=0;for(;r<n.length;){if(n[r]>=t){const i=n[r]-t,o=this.curves[r],a=o.getLength(),s=a===0?0:1-i/a;return o.getPointAt(s)}r++}return null},getLength:function(){const e=this.getCurveLengths();return e[e.length-1]},updateArcLengths:function(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()},getCurveLengths:function(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const e=[];let t=0;for(let n=0,r=this.curves.length;n<r;n++)t+=this.curves[n].getLength(),e.push(t);return this.cacheLengths=e,e},getSpacedPoints:function(e=40){const t=[];for(let n=0;n<=e;n++)t.push(this.getPoint(n/e));return this.autoClose&&t.push(t[0]),t},getPoints:function(e=12){const t=[];let n;for(let r=0,i=this.curves;r<i.length;r++){const o=i[r],a=o&&o.isEllipseCurve?2*e:o&&(o.isLineCurve||o.isLineCurve3)?1:o&&o.isSplineCurve?e*o.points.length:e,s=o.getPoints(a);for(let c=0;c<s.length;c++){const u=s[c];n&&n.equals(u)||(t.push(u),n=u)}}return this.autoClose&&t.length>1&&!t[t.length-1].equals(t[0])&&t.push(t[0]),t},copy:function(e){Lt.prototype.copy.call(this,e),this.curves=[];for(let t=0,n=e.curves.length;t<n;t++){const r=e.curves[t];this.curves.push(r.clone())}return this.autoClose=e.autoClose,this},toJSON:function(){const e=Lt.prototype.toJSON.call(this);e.autoClose=this.autoClose,e.curves=[];for(let t=0,n=this.curves.length;t<n;t++){const r=this.curves[t];e.curves.push(r.toJSON())}return e},fromJSON:function(e){Lt.prototype.fromJSON.call(this,e),this.autoClose=e.autoClose,this.curves=[];for(let t=0,n=e.curves.length;t<n;t++){const r=e.curves[t];this.curves.push(new yl[r.type]().fromJSON(r))}return this}}),Mr.prototype=Object.assign(Object.create(Xr.prototype),{constructor:Mr,setFromPoints:function(e){this.moveTo(e[0].x,e[0].y);for(let t=1,n=e.length;t<n;t++)this.lineTo(e[t].x,e[t].y);return this},moveTo:function(e,t){return this.currentPoint.set(e,t),this},lineTo:function(e,t){const n=new qn(this.currentPoint.clone(),new Je(e,t));return this.curves.push(n),this.currentPoint.set(e,t),this},quadraticCurveTo:function(e,t,n,r){const i=new wr(this.currentPoint.clone(),new Je(e,t),new Je(n,r));return this.curves.push(i),this.currentPoint.set(n,r),this},bezierCurveTo:function(e,t,n,r,i,o){const a=new xr(this.currentPoint.clone(),new Je(e,t),new Je(n,r),new Je(i,o));return this.curves.push(a),this.currentPoint.set(i,o),this},splineThru:function(e){const t=new _r([this.currentPoint.clone()].concat(e));return this.curves.push(t),this.currentPoint.copy(e[e.length-1]),this},arc:function(e,t,n,r,i,o){const a=this.currentPoint.x,s=this.currentPoint.y;return this.absarc(e+a,t+s,n,r,i,o),this},absarc:function(e,t,n,r,i,o){return this.absellipse(e,t,n,n,r,i,o),this},ellipse:function(e,t,n,r,i,o,a,s){const c=this.currentPoint.x,u=this.currentPoint.y;return this.absellipse(e+c,t+u,n,r,i,o,a,s),this},absellipse:function(e,t,n,r,i,o,a,s){const c=new ir(e,t,n,r,i,o,a,s);if(this.curves.length>0){const p=c.getPoint(0);p.equals(this.currentPoint)||this.lineTo(p.x,p.y)}this.curves.push(c);const u=c.getPoint(1);return this.currentPoint.copy(u),this},copy:function(e){return Xr.prototype.copy.call(this,e),this.currentPoint.copy(e.currentPoint),this},toJSON:function(){const e=Xr.prototype.toJSON.call(this);return e.currentPoint=this.currentPoint.toArray(),e},fromJSON:function(e){return Xr.prototype.fromJSON.call(this,e),this.currentPoint.fromArray(e.currentPoint),this}}),di.prototype=Object.assign(Object.create(Mr.prototype),{constructor:di,getPointsHoles:function(e){const t=[];for(let n=0,r=this.holes.length;n<r;n++)t[n]=this.holes[n].getPoints(e);return t},extractPoints:function(e){return{shape:this.getPoints(e),holes:this.getPointsHoles(e)}},copy:function(e){Mr.prototype.copy.call(this,e),this.holes=[];for(let t=0,n=e.holes.length;t<n;t++){const r=e.holes[t];this.holes.push(r.clone())}return this},toJSON:function(){const e=Mr.prototype.toJSON.call(this);e.uuid=this.uuid,e.holes=[];for(let t=0,n=this.holes.length;t<n;t++){const r=this.holes[t];e.holes.push(r.toJSON())}return e},fromJSON:function(e){Mr.prototype.fromJSON.call(this,e),this.uuid=e.uuid,this.holes=[];for(let t=0,n=e.holes.length;t<n;t++){const r=e.holes[t];this.holes.push(new Mr().fromJSON(r))}return this}}),ln.prototype=Object.assign(Object.create(At.prototype),{constructor:ln,isLight:!0,copy:function(e){return At.prototype.copy.call(this,e),this.color.copy(e.color),this.intensity=e.intensity,this},toJSON:function(e){const t=At.prototype.toJSON.call(this,e);return t.object.color=this.color.getHex(),t.object.intensity=this.intensity,this.groundColor!==void 0&&(t.object.groundColor=this.groundColor.getHex()),this.distance!==void 0&&(t.object.distance=this.distance),this.angle!==void 0&&(t.object.angle=this.angle),this.decay!==void 0&&(t.object.decay=this.decay),this.penumbra!==void 0&&(t.object.penumbra=this.penumbra),this.shadow!==void 0&&(t.object.shadow=this.shadow.toJSON()),t}}),Ps.prototype=Object.assign(Object.create(ln.prototype),{constructor:Ps,isHemisphereLight:!0,copy:function(e){return ln.prototype.copy.call(this,e),this.groundColor.copy(e.groundColor),this}}),Object.assign(qr.prototype,{_projScreenMatrix:new Ht,_lightPositionWorld:new z,_lookTarget:new z,getViewportCount:function(){return this._viewportCount},getFrustum:function(){return this._frustum},updateMatrices:function(e){const t=this.camera,n=this.matrix,r=this._projScreenMatrix,i=this._lookTarget,o=this._lightPositionWorld;o.setFromMatrixPosition(e.matrixWorld),t.position.copy(o),i.setFromMatrixPosition(e.target.matrixWorld),t.lookAt(i),t.updateMatrixWorld(),r.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse),this._frustum.setFromProjectionMatrix(r),n.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),n.multiply(t.projectionMatrix),n.multiply(t.matrixWorldInverse)},getViewport:function(e){return this._viewports[e]},getFrameExtents:function(){return this._frameExtents},copy:function(e){return this.camera=e.camera.clone(),this.bias=e.bias,this.radius=e.radius,this.mapSize.copy(e.mapSize),this},clone:function(){return new this.constructor().copy(this)},toJSON:function(){const e={};return this.bias!==0&&(e.bias=this.bias),this.normalBias!==0&&(e.normalBias=this.normalBias),this.radius!==1&&(e.radius=this.radius),this.mapSize.x===512&&this.mapSize.y===512||(e.mapSize=this.mapSize.toArray()),e.camera=this.camera.toJSON(!1).object,delete e.camera.matrix,e}}),xl.prototype=Object.assign(Object.create(qr.prototype),{constructor:xl,isSpotLightShadow:!0,updateMatrices:function(e){const t=this.camera,n=2*Ft.RAD2DEG*e.angle*this.focus,r=this.mapSize.width/this.mapSize.height,i=e.distance||t.far;n===t.fov&&r===t.aspect&&i===t.far||(t.fov=n,t.aspect=r,t.far=i,t.updateProjectionMatrix()),qr.prototype.updateMatrices.call(this,e)}}),Rs.prototype=Object.assign(Object.create(ln.prototype),{constructor:Rs,isSpotLight:!0,copy:function(e){return ln.prototype.copy.call(this,e),this.distance=e.distance,this.angle=e.angle,this.penumbra=e.penumbra,this.decay=e.decay,this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}),bl.prototype=Object.assign(Object.create(qr.prototype),{constructor:bl,isPointLightShadow:!0,updateMatrices:function(e,t=0){const n=this.camera,r=this.matrix,i=this._lightPositionWorld,o=this._lookTarget,a=this._projScreenMatrix;i.setFromMatrixPosition(e.matrixWorld),n.position.copy(i),o.copy(n.position),o.add(this._cubeDirections[t]),n.up.copy(this._cubeUps[t]),n.lookAt(o),n.updateMatrixWorld(),r.makeTranslation(-i.x,-i.y,-i.z),a.multiplyMatrices(n.projectionMatrix,n.matrixWorldInverse),this._frustum.setFromProjectionMatrix(a)}}),Os.prototype=Object.assign(Object.create(ln.prototype),{constructor:Os,isPointLight:!0,copy:function(e){return ln.prototype.copy.call(this,e),this.distance=e.distance,this.decay=e.decay,this.shadow=e.shadow.clone(),this}}),Mo.prototype=Object.assign(Object.create(Lr.prototype),{constructor:Mo,isOrthographicCamera:!0,copy:function(e,t){return Lr.prototype.copy.call(this,e,t),this.left=e.left,this.right=e.right,this.top=e.top,this.bottom=e.bottom,this.near=e.near,this.far=e.far,this.zoom=e.zoom,this.view=e.view===null?null:Object.assign({},e.view),this},setViewOffset:function(e,t,n,r,i,o){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=n,this.view.offsetY=r,this.view.width=i,this.view.height=o,this.updateProjectionMatrix()},clearViewOffset:function(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()},updateProjectionMatrix:function(){const e=(this.right-this.left)/(2*this.zoom),t=(this.top-this.bottom)/(2*this.zoom),n=(this.right+this.left)/2,r=(this.top+this.bottom)/2;let i=n-e,o=n+e,a=r+t,s=r-t;if(this.view!==null&&this.view.enabled){const c=(this.right-this.left)/this.view.fullWidth/this.zoom,u=(this.top-this.bottom)/this.view.fullHeight/this.zoom;i+=c*this.view.offsetX,o=i+c*this.view.width,a-=u*this.view.offsetY,s=a-u*this.view.height}this.projectionMatrix.makeOrthographic(i,o,a,s,this.near,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()},toJSON:function(e){const t=At.prototype.toJSON.call(this,e);return t.object.zoom=this.zoom,t.object.left=this.left,t.object.right=this.right,t.object.top=this.top,t.object.bottom=this.bottom,t.object.near=this.near,t.object.far=this.far,this.view!==null&&(t.object.view=Object.assign({},this.view)),t}}),wl.prototype=Object.assign(Object.create(qr.prototype),{constructor:wl,isDirectionalLightShadow:!0,updateMatrices:function(e){qr.prototype.updateMatrices.call(this,e)}}),Ds.prototype=Object.assign(Object.create(ln.prototype),{constructor:Ds,isDirectionalLight:!0,copy:function(e){return ln.prototype.copy.call(this,e),this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}),Is.prototype=Object.assign(Object.create(ln.prototype),{constructor:Is,isAmbientLight:!0}),Ns.prototype=Object.assign(Object.create(ln.prototype),{constructor:Ns,isRectAreaLight:!0,copy:function(e){return ln.prototype.copy.call(this,e),this.width=e.width,this.height=e.height,this},toJSON:function(e){const t=ln.prototype.toJSON.call(this,e);return t.object.width=this.width,t.object.height=this.height,t}});class od{constructor(){Object.defineProperty(this,"isSphericalHarmonics3",{value:!0}),this.coefficients=[];for(let e=0;e<9;e++)this.coefficients.push(new z)}set(e){for(let t=0;t<9;t++)this.coefficients[t].copy(e[t]);return this}zero(){for(let e=0;e<9;e++)this.coefficients[e].set(0,0,0);return this}getAt(e,t){const n=e.x,r=e.y,i=e.z,o=this.coefficients;return t.copy(o[0]).multiplyScalar(.282095),t.addScaledVector(o[1],.488603*r),t.addScaledVector(o[2],.488603*i),t.addScaledVector(o[3],.488603*n),t.addScaledVector(o[4],n*r*1.092548),t.addScaledVector(o[5],r*i*1.092548),t.addScaledVector(o[6],.315392*(3*i*i-1)),t.addScaledVector(o[7],n*i*1.092548),t.addScaledVector(o[8],.546274*(n*n-r*r)),t}getIrradianceAt(e,t){const n=e.x,r=e.y,i=e.z,o=this.coefficients;return t.copy(o[0]).multiplyScalar(.886227),t.addScaledVector(o[1],1.023328*r),t.addScaledVector(o[2],1.023328*i),t.addScaledVector(o[3],1.023328*n),t.addScaledVector(o[4],.858086*n*r),t.addScaledVector(o[5],.858086*r*i),t.addScaledVector(o[6],.743125*i*i-.247708),t.addScaledVector(o[7],.858086*n*i),t.addScaledVector(o[8],.429043*(n*n-r*r)),t}add(e){for(let t=0;t<9;t++)this.coefficients[t].add(e.coefficients[t]);return this}addScaledSH(e,t){for(let n=0;n<9;n++)this.coefficients[n].addScaledVector(e.coefficients[n],t);return this}scale(e){for(let t=0;t<9;t++)this.coefficients[t].multiplyScalar(e);return this}lerp(e,t){for(let n=0;n<9;n++)this.coefficients[n].lerp(e.coefficients[n],t);return this}equals(e){for(let t=0;t<9;t++)if(!this.coefficients[t].equals(e.coefficients[t]))return!1;return!0}copy(e){return this.set(e.coefficients)}clone(){return new this.constructor().copy(this)}fromArray(e,t=0){const n=this.coefficients;for(let r=0;r<9;r++)n[r].fromArray(e,t+3*r);return this}toArray(e=[],t=0){const n=this.coefficients;for(let r=0;r<9;r++)n[r].toArray(e,t+3*r);return e}static getBasisAt(e,t){const n=e.x,r=e.y,i=e.z;t[0]=.282095,t[1]=.488603*r,t[2]=.488603*i,t[3]=.488603*n,t[4]=1.092548*n*r,t[5]=1.092548*r*i,t[6]=.315392*(3*i*i-1),t[7]=1.092548*n*i,t[8]=.546274*(n*n-r*r)}}function hr(e,t){ln.call(this,void 0,t),this.type="LightProbe",this.sh=e!==void 0?e:new od}function Bs(e){en.call(this,e),this.textures={}}hr.prototype=Object.assign(Object.create(ln.prototype),{constructor:hr,isLightProbe:!0,copy:function(e){return ln.prototype.copy.call(this,e),this.sh.copy(e.sh),this},fromJSON:function(e){return this.intensity=e.intensity,this.sh.fromArray(e.sh),this},toJSON:function(e){const t=ln.prototype.toJSON.call(this,e);return t.object.sh=this.sh.toArray(),t}}),Bs.prototype=Object.assign(Object.create(en.prototype),{constructor:Bs,load:function(e,t,n,r){const i=this,o=new ur(i.manager);o.setPath(i.path),o.setRequestHeader(i.requestHeader),o.setWithCredentials(i.withCredentials),o.load(e,function(a){try{t(i.parse(JSON.parse(a)))}catch(s){r?r(s):console.error(s),i.manager.itemError(e)}},n,r)},parse:function(e){const t=this.textures;function n(i){return t[i]===void 0&&console.warn("THREE.MaterialLoader: Undefined texture",i),t[i]}const r=new bm[e.type];if(e.uuid!==void 0&&(r.uuid=e.uuid),e.name!==void 0&&(r.name=e.name),e.color!==void 0&&r.color!==void 0&&r.color.setHex(e.color),e.roughness!==void 0&&(r.roughness=e.roughness),e.metalness!==void 0&&(r.metalness=e.metalness),e.sheen!==void 0&&(r.sheen=new _t().setHex(e.sheen)),e.emissive!==void 0&&r.emissive!==void 0&&r.emissive.setHex(e.emissive),e.specular!==void 0&&r.specular!==void 0&&r.specular.setHex(e.specular),e.shininess!==void 0&&(r.shininess=e.shininess),e.clearcoat!==void 0&&(r.clearcoat=e.clearcoat),e.clearcoatRoughness!==void 0&&(r.clearcoatRoughness=e.clearcoatRoughness),e.fog!==void 0&&(r.fog=e.fog),e.flatShading!==void 0&&(r.flatShading=e.flatShading),e.blending!==void 0&&(r.blending=e.blending),e.combine!==void 0&&(r.combine=e.combine),e.side!==void 0&&(r.side=e.side),e.opacity!==void 0&&(r.opacity=e.opacity),e.transparent!==void 0&&(r.transparent=e.transparent),e.alphaTest!==void 0&&(r.alphaTest=e.alphaTest),e.depthTest!==void 0&&(r.depthTest=e.depthTest),e.depthWrite!==void 0&&(r.depthWrite=e.depthWrite),e.colorWrite!==void 0&&(r.colorWrite=e.colorWrite),e.stencilWrite!==void 0&&(r.stencilWrite=e.stencilWrite),e.stencilWriteMask!==void 0&&(r.stencilWriteMask=e.stencilWriteMask),e.stencilFunc!==void 0&&(r.stencilFunc=e.stencilFunc),e.stencilRef!==void 0&&(r.stencilRef=e.stencilRef),e.stencilFuncMask!==void 0&&(r.stencilFuncMask=e.stencilFuncMask),e.stencilFail!==void 0&&(r.stencilFail=e.stencilFail),e.stencilZFail!==void 0&&(r.stencilZFail=e.stencilZFail),e.stencilZPass!==void 0&&(r.stencilZPass=e.stencilZPass),e.wireframe!==void 0&&(r.wireframe=e.wireframe),e.wireframeLinewidth!==void 0&&(r.wireframeLinewidth=e.wireframeLinewidth),e.wireframeLinecap!==void 0&&(r.wireframeLinecap=e.wireframeLinecap),e.wireframeLinejoin!==void 0&&(r.wireframeLinejoin=e.wireframeLinejoin),e.rotation!==void 0&&(r.rotation=e.rotation),e.linewidth!==1&&(r.linewidth=e.linewidth),e.dashSize!==void 0&&(r.dashSize=e.dashSize),e.gapSize!==void 0&&(r.gapSize=e.gapSize),e.scale!==void 0&&(r.scale=e.scale),e.polygonOffset!==void 0&&(r.polygonOffset=e.polygonOffset),e.polygonOffsetFactor!==void 0&&(r.polygonOffsetFactor=e.polygonOffsetFactor),e.polygonOffsetUnits!==void 0&&(r.polygonOffsetUnits=e.polygonOffsetUnits),e.skinning!==void 0&&(r.skinning=e.skinning),e.morphTargets!==void 0&&(r.morphTargets=e.morphTargets),e.morphNormals!==void 0&&(r.morphNormals=e.morphNormals),e.dithering!==void 0&&(r.dithering=e.dithering),e.vertexTangents!==void 0&&(r.vertexTangents=e.vertexTangents),e.visible!==void 0&&(r.visible=e.visible),e.toneMapped!==void 0&&(r.toneMapped=e.toneMapped),e.userData!==void 0&&(r.userData=e.userData),e.vertexColors!==void 0&&(typeof e.vertexColors=="number"?r.vertexColors=e.vertexColors>0:r.vertexColors=e.vertexColors),e.uniforms!==void 0)for(const i in e.uniforms){const o=e.uniforms[i];switch(r.uniforms[i]={},o.type){case"t":r.uniforms[i].value=n(o.value);break;case"c":r.uniforms[i].value=new _t().setHex(o.value);break;case"v2":r.uniforms[i].value=new Je().fromArray(o.value);break;case"v3":r.uniforms[i].value=new z().fromArray(o.value);break;case"v4":r.uniforms[i].value=new nn().fromArray(o.value);break;case"m3":r.uniforms[i].value=new Vn().fromArray(o.value);break;case"m4":r.uniforms[i].value=new Ht().fromArray(o.value);break;default:r.uniforms[i].value=o.value}}if(e.defines!==void 0&&(r.defines=e.defines),e.vertexShader!==void 0&&(r.vertexShader=e.vertexShader),e.fragmentShader!==void 0&&(r.fragmentShader=e.fragmentShader),e.extensions!==void 0)for(const i in e.extensions)r.extensions[i]=e.extensions[i];if(e.shading!==void 0&&(r.flatShading=e.shading===1),e.size!==void 0&&(r.size=e.size),e.sizeAttenuation!==void 0&&(r.sizeAttenuation=e.sizeAttenuation),e.map!==void 0&&(r.map=n(e.map)),e.matcap!==void 0&&(r.matcap=n(e.matcap)),e.alphaMap!==void 0&&(r.alphaMap=n(e.alphaMap)),e.bumpMap!==void 0&&(r.bumpMap=n(e.bumpMap)),e.bumpScale!==void 0&&(r.bumpScale=e.bumpScale),e.normalMap!==void 0&&(r.normalMap=n(e.normalMap)),e.normalMapType!==void 0&&(r.normalMapType=e.normalMapType),e.normalScale!==void 0){let i=e.normalScale;Array.isArray(i)===!1&&(i=[i,i]),r.normalScale=new Je().fromArray(i)}return e.displacementMap!==void 0&&(r.displacementMap=n(e.displacementMap)),e.displacementScale!==void 0&&(r.displacementScale=e.displacementScale),e.displacementBias!==void 0&&(r.displacementBias=e.displacementBias),e.roughnessMap!==void 0&&(r.roughnessMap=n(e.roughnessMap)),e.metalnessMap!==void 0&&(r.metalnessMap=n(e.metalnessMap)),e.emissiveMap!==void 0&&(r.emissiveMap=n(e.emissiveMap)),e.emissiveIntensity!==void 0&&(r.emissiveIntensity=e.emissiveIntensity),e.specularMap!==void 0&&(r.specularMap=n(e.specularMap)),e.envMap!==void 0&&(r.envMap=n(e.envMap)),e.envMapIntensity!==void 0&&(r.envMapIntensity=e.envMapIntensity),e.reflectivity!==void 0&&(r.reflectivity=e.reflectivity),e.refractionRatio!==void 0&&(r.refractionRatio=e.refractionRatio),e.lightMap!==void 0&&(r.lightMap=n(e.lightMap)),e.lightMapIntensity!==void 0&&(r.lightMapIntensity=e.lightMapIntensity),e.aoMap!==void 0&&(r.aoMap=n(e.aoMap)),e.aoMapIntensity!==void 0&&(r.aoMapIntensity=e.aoMapIntensity),e.gradientMap!==void 0&&(r.gradientMap=n(e.gradientMap)),e.clearcoatMap!==void 0&&(r.clearcoatMap=n(e.clearcoatMap)),e.clearcoatRoughnessMap!==void 0&&(r.clearcoatRoughnessMap=n(e.clearcoatRoughnessMap)),e.clearcoatNormalMap!==void 0&&(r.clearcoatNormalMap=n(e.clearcoatNormalMap)),e.clearcoatNormalScale!==void 0&&(r.clearcoatNormalScale=new Je().fromArray(e.clearcoatNormalScale)),e.transmission!==void 0&&(r.transmission=e.transmission),e.transmissionMap!==void 0&&(r.transmissionMap=n(e.transmissionMap)),r},setTextures:function(e){return this.textures=e,this}});const _l={decodeText:function(e){if(typeof TextDecoder!="undefined")return new TextDecoder().decode(e);let t="";for(let n=0,r=e.length;n<r;n++)t+=String.fromCharCode(e[n]);try{return decodeURIComponent(escape(t))}catch(n){return t}},extractUrlBase:function(e){const t=e.lastIndexOf("/");return t===-1?"./":e.substr(0,t+1)}};function ba(){Ct.call(this),this.type="InstancedBufferGeometry",this.instanceCount=1/0}function Fs(e,t,n,r){typeof n=="number"&&(r=n,n=!1,console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")),Rt.call(this,e,t,n),this.meshPerAttribute=r||1}function Us(e){en.call(this,e)}ba.prototype=Object.assign(Object.create(Ct.prototype),{constructor:ba,isInstancedBufferGeometry:!0,copy:function(e){return Ct.prototype.copy.call(this,e),this.instanceCount=e.instanceCount,this},clone:function(){return new this.constructor().copy(this)},toJSON:function(){const e=Ct.prototype.toJSON.call(this);return e.instanceCount=this.instanceCount,e.isInstancedBufferGeometry=!0,e}}),Fs.prototype=Object.assign(Object.create(Rt.prototype),{constructor:Fs,isInstancedBufferAttribute:!0,copy:function(e){return Rt.prototype.copy.call(this,e),this.meshPerAttribute=e.meshPerAttribute,this},toJSON:function(){const e=Rt.prototype.toJSON.call(this);return e.meshPerAttribute=this.meshPerAttribute,e.isInstancedBufferAttribute=!0,e}}),Us.prototype=Object.assign(Object.create(en.prototype),{constructor:Us,load:function(e,t,n,r){const i=this,o=new ur(i.manager);o.setPath(i.path),o.setRequestHeader(i.requestHeader),o.setWithCredentials(i.withCredentials),o.load(e,function(a){try{t(i.parse(JSON.parse(a)))}catch(s){r?r(s):console.error(s),i.manager.itemError(e)}},n,r)},parse:function(e){const t={},n={};function r(p,d){if(t[d]!==void 0)return t[d];const g=p.interleavedBuffers[d],m=function(S,b){if(n[b]!==void 0)return n[b];const R=S.arrayBuffers[b],F=new Uint32Array(R).buffer;return n[b]=F,F}(p,g.buffer),x=new tr(jo(g.type,m),g.stride);return x.uuid=g.uuid,t[d]=x,x}const i=e.isInstancedBufferGeometry?new ba:new Ct,o=e.data.index;if(o!==void 0){const p=jo(o.type,o.array);i.setIndex(new Rt(p,1))}const a=e.data.attributes;for(const p in a){const d=a[p];let g;if(d.isInterleavedBufferAttribute)g=new si(r(e.data,d.data),d.itemSize,d.offset,d.normalized);else{const m=jo(d.type,d.array);g=new(d.isInstancedBufferAttribute?Fs:Rt)(m,d.itemSize,d.normalized)}d.name!==void 0&&(g.name=d.name),i.setAttribute(p,g)}const s=e.data.morphAttributes;if(s)for(const p in s){const d=s[p],g=[];for(let m=0,x=d.length;m<x;m++){const S=d[m];let b;S.isInterleavedBufferAttribute?b=new si(r(e.data,S.data),S.itemSize,S.offset,S.normalized):b=new Rt(jo(S.type,S.array),S.itemSize,S.normalized),S.name!==void 0&&(b.name=S.name),g.push(b)}i.morphAttributes[p]=g}e.data.morphTargetsRelative&&(i.morphTargetsRelative=!0);const c=e.data.groups||e.data.drawcalls||e.data.offsets;if(c!==void 0)for(let p=0,d=c.length;p!==d;++p){const g=c[p];i.addGroup(g.start,g.count,g.materialIndex)}const u=e.data.boundingSphere;if(u!==void 0){const p=new z;u.center!==void 0&&p.fromArray(u.center),i.boundingSphere=new Fr(p,u.radius)}return e.name&&(i.name=e.name),e.userData&&(i.userData=e.userData),i}});class _m extends en{constructor(e){super(e)}load(e,t,n,r){const i=this,o=this.path===""?_l.extractUrlBase(e):this.path;this.resourcePath=this.resourcePath||o;const a=new ur(this.manager);a.setPath(this.path),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(e,function(s){let c=null;try{c=JSON.parse(s)}catch(p){return r!==void 0&&r(p),void console.error("THREE:ObjectLoader: Can't parse "+e+".",p.message)}const u=c.metadata;u!==void 0&&u.type!==void 0&&u.type.toLowerCase()!=="geometry"?i.parse(c,t):console.error("THREE.ObjectLoader: Can't load "+e)},n,r)}parse(e,t){const n=this.parseAnimations(e.animations),r=this.parseShapes(e.shapes),i=this.parseGeometries(e.geometries,r),o=this.parseImages(e.images,function(){t!==void 0&&t(c)}),a=this.parseTextures(e.textures,o),s=this.parseMaterials(e.materials,a),c=this.parseObject(e.object,i,s,n),u=this.parseSkeletons(e.skeletons,c);if(this.bindSkeletons(c,u),t!==void 0){let p=!1;for(const d in o)if(o[d]instanceof HTMLImageElement){p=!0;break}p===!1&&t(c)}return c}parseShapes(e){const t={};if(e!==void 0)for(let n=0,r=e.length;n<r;n++){const i=new di().fromJSON(e[n]);t[i.uuid]=i}return t}parseSkeletons(e,t){const n={},r={};if(t.traverse(function(i){i.isBone&&(r[i.uuid]=i)}),e!==void 0)for(let i=0,o=e.length;i<o;i++){const a=new aa().fromJSON(e[i],r);n[a.uuid]=a}return n}parseGeometries(e,t){const n={};let r;if(e!==void 0){const i=new Us;for(let o=0,a=e.length;o<a;o++){let s;const c=e[o];switch(c.type){case"PlaneGeometry":case"PlaneBufferGeometry":s=new Xn[c.type](c.width,c.height,c.widthSegments,c.heightSegments);break;case"BoxGeometry":case"BoxBufferGeometry":case"CubeGeometry":s=new Xn[c.type](c.width,c.height,c.depth,c.widthSegments,c.heightSegments,c.depthSegments);break;case"CircleGeometry":case"CircleBufferGeometry":s=new Xn[c.type](c.radius,c.segments,c.thetaStart,c.thetaLength);break;case"CylinderGeometry":case"CylinderBufferGeometry":s=new Xn[c.type](c.radiusTop,c.radiusBottom,c.height,c.radialSegments,c.heightSegments,c.openEnded,c.thetaStart,c.thetaLength);break;case"ConeGeometry":case"ConeBufferGeometry":s=new Xn[c.type](c.radius,c.height,c.radialSegments,c.heightSegments,c.openEnded,c.thetaStart,c.thetaLength);break;case"SphereGeometry":case"SphereBufferGeometry":s=new Xn[c.type](c.radius,c.widthSegments,c.heightSegments,c.phiStart,c.phiLength,c.thetaStart,c.thetaLength);break;case"DodecahedronGeometry":case"DodecahedronBufferGeometry":case"IcosahedronGeometry":case"IcosahedronBufferGeometry":case"OctahedronGeometry":case"OctahedronBufferGeometry":case"TetrahedronGeometry":case"TetrahedronBufferGeometry":s=new Xn[c.type](c.radius,c.detail);break;case"RingGeometry":case"RingBufferGeometry":s=new Xn[c.type](c.innerRadius,c.outerRadius,c.thetaSegments,c.phiSegments,c.thetaStart,c.thetaLength);break;case"TorusGeometry":case"TorusBufferGeometry":s=new Xn[c.type](c.radius,c.tube,c.radialSegments,c.tubularSegments,c.arc);break;case"TorusKnotGeometry":case"TorusKnotBufferGeometry":s=new Xn[c.type](c.radius,c.tube,c.tubularSegments,c.radialSegments,c.p,c.q);break;case"TubeGeometry":case"TubeBufferGeometry":s=new Xn[c.type](new yl[c.path.type]().fromJSON(c.path),c.tubularSegments,c.radius,c.radialSegments,c.closed);break;case"LatheGeometry":case"LatheBufferGeometry":s=new Xn[c.type](c.points,c.segments,c.phiStart,c.phiLength);break;case"PolyhedronGeometry":case"PolyhedronBufferGeometry":s=new Xn[c.type](c.vertices,c.indices,c.radius,c.details);break;case"ShapeGeometry":case"ShapeBufferGeometry":r=[];for(let p=0,d=c.shapes.length;p<d;p++){const g=t[c.shapes[p]];r.push(g)}s=new Xn[c.type](r,c.curveSegments);break;case"ExtrudeGeometry":case"ExtrudeBufferGeometry":r=[];for(let p=0,d=c.shapes.length;p<d;p++){const g=t[c.shapes[p]];r.push(g)}const u=c.options.extrudePath;u!==void 0&&(c.options.extrudePath=new yl[u.type]().fromJSON(u)),s=new Xn[c.type](r,c.options);break;case"BufferGeometry":case"InstancedBufferGeometry":s=i.parse(c);break;case"Geometry":console.error('THREE.ObjectLoader: Loading "Geometry" is not supported anymore.');break;default:console.warn('THREE.ObjectLoader: Unsupported geometry type "'+c.type+'"');continue}s.uuid=c.uuid,c.name!==void 0&&(s.name=c.name),s.isBufferGeometry===!0&&c.userData!==void 0&&(s.userData=c.userData),n[c.uuid]=s}}return n}parseMaterials(e,t){const n={},r={};if(e!==void 0){const i=new Bs;i.setTextures(t);for(let o=0,a=e.length;o<a;o++){const s=e[o];if(s.type==="MultiMaterial"){const c=[];for(let u=0;u<s.materials.length;u++){const p=s.materials[u];n[p.uuid]===void 0&&(n[p.uuid]=i.parse(p)),c.push(n[p.uuid])}r[s.uuid]=c}else n[s.uuid]===void 0&&(n[s.uuid]=i.parse(s)),r[s.uuid]=n[s.uuid]}}return r}parseAnimations(e){const t={};if(e!==void 0)for(let n=0;n<e.length;n++){const r=e[n],i=rr.parse(r);t[i.uuid]=i}return t}parseImages(e,t){const n=this,r={};let i;function o(a){if(typeof a=="string"){const s=a;return function(c){return n.manager.itemStart(c),i.load(c,function(){n.manager.itemEnd(c)},void 0,function(){n.manager.itemError(c),n.manager.itemEnd(c)})}(/^(\/\/)|([a-z]+:(\/\/)?)/i.test(s)?s:n.resourcePath+s)}return a.data?{data:jo(a.type,a.data),width:a.width,height:a.height}:null}if(e!==void 0&&e.length>0){const a=new hl(t);i=new wo(a),i.setCrossOrigin(this.crossOrigin);for(let s=0,c=e.length;s<c;s++){const u=e[s],p=u.url;if(Array.isArray(p)){r[u.uuid]=[];for(let d=0,g=p.length;d<g;d++){const m=o(p[d]);m!==null&&(m instanceof HTMLImageElement?r[u.uuid].push(m):r[u.uuid].push(new Vr(m.data,m.width,m.height)))}}else{const d=o(u.url);d!==null&&(r[u.uuid]=d)}}}return r}parseTextures(e,t){function n(i,o){return typeof i=="number"?i:(console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",i),o[i])}const r={};if(e!==void 0)for(let i=0,o=e.length;i<o;i++){const a=e[i];let s;a.image===void 0&&console.warn('THREE.ObjectLoader: No "image" specified for',a.uuid),t[a.image]===void 0&&console.warn("THREE.ObjectLoader: Undefined image",a.image);const c=t[a.image];Array.isArray(c)?(s=new Cr(c),c.length===6&&(s.needsUpdate=!0)):(s=c&&c.data?new Vr(c.data,c.width,c.height):new tn(c),c&&(s.needsUpdate=!0)),s.uuid=a.uuid,a.name!==void 0&&(s.name=a.name),a.mapping!==void 0&&(s.mapping=n(a.mapping,Mm)),a.offset!==void 0&&s.offset.fromArray(a.offset),a.repeat!==void 0&&s.repeat.fromArray(a.repeat),a.center!==void 0&&s.center.fromArray(a.center),a.rotation!==void 0&&(s.rotation=a.rotation),a.wrap!==void 0&&(s.wrapS=n(a.wrap[0],ad),s.wrapT=n(a.wrap[1],ad)),a.format!==void 0&&(s.format=a.format),a.type!==void 0&&(s.type=a.type),a.encoding!==void 0&&(s.encoding=a.encoding),a.minFilter!==void 0&&(s.minFilter=n(a.minFilter,sd)),a.magFilter!==void 0&&(s.magFilter=n(a.magFilter,sd)),a.anisotropy!==void 0&&(s.anisotropy=a.anisotropy),a.flipY!==void 0&&(s.flipY=a.flipY),a.premultiplyAlpha!==void 0&&(s.premultiplyAlpha=a.premultiplyAlpha),a.unpackAlignment!==void 0&&(s.unpackAlignment=a.unpackAlignment),r[a.uuid]=s}return r}parseObject(e,t,n,r){let i,o,a;function s(u){return t[u]===void 0&&console.warn("THREE.ObjectLoader: Undefined geometry",u),t[u]}function c(u){if(u!==void 0){if(Array.isArray(u)){const p=[];for(let d=0,g=u.length;d<g;d++){const m=u[d];n[m]===void 0&&console.warn("THREE.ObjectLoader: Undefined material",m),p.push(n[m])}return p}return n[u]===void 0&&console.warn("THREE.ObjectLoader: Undefined material",u),n[u]}}switch(e.type){case"Scene":i=new zc,e.background!==void 0&&Number.isInteger(e.background)&&(i.background=new _t(e.background)),e.fog!==void 0&&(e.fog.type==="Fog"?i.fog=new Uc(e.fog.color,e.fog.near,e.fog.far):e.fog.type==="FogExp2"&&(i.fog=new Fc(e.fog.color,e.fog.density)));break;case"PerspectiveCamera":i=new _n(e.fov,e.aspect,e.near,e.far),e.focus!==void 0&&(i.focus=e.focus),e.zoom!==void 0&&(i.zoom=e.zoom),e.filmGauge!==void 0&&(i.filmGauge=e.filmGauge),e.filmOffset!==void 0&&(i.filmOffset=e.filmOffset),e.view!==void 0&&(i.view=Object.assign({},e.view));break;case"OrthographicCamera":i=new Mo(e.left,e.right,e.top,e.bottom,e.near,e.far),e.zoom!==void 0&&(i.zoom=e.zoom),e.view!==void 0&&(i.view=Object.assign({},e.view));break;case"AmbientLight":i=new Is(e.color,e.intensity);break;case"DirectionalLight":i=new Ds(e.color,e.intensity);break;case"PointLight":i=new Os(e.color,e.intensity,e.distance,e.decay);break;case"RectAreaLight":i=new Ns(e.color,e.intensity,e.width,e.height);break;case"SpotLight":i=new Rs(e.color,e.intensity,e.distance,e.angle,e.penumbra,e.decay);break;case"HemisphereLight":i=new Ps(e.color,e.groundColor,e.intensity);break;case"LightProbe":i=new hr().fromJSON(e);break;case"SkinnedMesh":o=s(e.geometry),a=c(e.material),i=new ia(o,a),e.bindMode!==void 0&&(i.bindMode=e.bindMode),e.bindMatrix!==void 0&&i.bindMatrix.fromArray(e.bindMatrix),e.skeleton!==void 0&&(i.skeleton=e.skeleton);break;case"Mesh":o=s(e.geometry),a=c(e.material),i=new pn(o,a);break;case"InstancedMesh":o=s(e.geometry),a=c(e.material);const u=e.count,p=e.instanceMatrix;i=new rs(o,a,u),i.instanceMatrix=new Rt(new Float32Array(p.array),16);break;case"LOD":i=new ra;break;case"Line":i=new lr(s(e.geometry),c(e.material),e.mode);break;case"LineLoop":i=new cs(s(e.geometry),c(e.material));break;case"LineSegments":i=new Wn(s(e.geometry),c(e.material));break;case"PointCloud":case"Points":i=new mo(s(e.geometry),c(e.material));break;case"Sprite":i=new na(c(e.material));break;case"Group":i=new ai;break;case"Bone":i=new oa;break;default:i=new At}if(i.uuid=e.uuid,e.name!==void 0&&(i.name=e.name),e.matrix!==void 0?(i.matrix.fromArray(e.matrix),e.matrixAutoUpdate!==void 0&&(i.matrixAutoUpdate=e.matrixAutoUpdate),i.matrixAutoUpdate&&i.matrix.decompose(i.position,i.quaternion,i.scale)):(e.position!==void 0&&i.position.fromArray(e.position),e.rotation!==void 0&&i.rotation.fromArray(e.rotation),e.quaternion!==void 0&&i.quaternion.fromArray(e.quaternion),e.scale!==void 0&&i.scale.fromArray(e.scale)),e.castShadow!==void 0&&(i.castShadow=e.castShadow),e.receiveShadow!==void 0&&(i.receiveShadow=e.receiveShadow),e.shadow&&(e.shadow.bias!==void 0&&(i.shadow.bias=e.shadow.bias),e.shadow.normalBias!==void 0&&(i.shadow.normalBias=e.shadow.normalBias),e.shadow.radius!==void 0&&(i.shadow.radius=e.shadow.radius),e.shadow.mapSize!==void 0&&i.shadow.mapSize.fromArray(e.shadow.mapSize),e.shadow.camera!==void 0&&(i.shadow.camera=this.parseObject(e.shadow.camera))),e.visible!==void 0&&(i.visible=e.visible),e.frustumCulled!==void 0&&(i.frustumCulled=e.frustumCulled),e.renderOrder!==void 0&&(i.renderOrder=e.renderOrder),e.userData!==void 0&&(i.userData=e.userData),e.layers!==void 0&&(i.layers.mask=e.layers),e.children!==void 0){const u=e.children;for(let p=0;p<u.length;p++)i.add(this.parseObject(u[p],t,n,r))}if(e.animations!==void 0){const u=e.animations;for(let p=0;p<u.length;p++){const d=u[p];i.animations.push(r[d])}}if(e.type==="LOD"){e.autoUpdate!==void 0&&(i.autoUpdate=e.autoUpdate);const u=e.levels;for(let p=0;p<u.length;p++){const d=u[p],g=i.getObjectByProperty("uuid",d.object);g!==void 0&&i.addLevel(g,d.distance)}}return i}bindSkeletons(e,t){Object.keys(t).length!==0&&e.traverse(function(n){if(n.isSkinnedMesh===!0&&n.skeleton!==void 0){const r=t[n.skeleton];r===void 0?console.warn("THREE.ObjectLoader: No skeleton found with UUID:",n.skeleton):n.bind(r,n.bindMatrix)}})}setTexturePath(e){return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."),this.setResourcePath(e)}}const Mm={UVMapping:$,CubeReflectionMapping:ye,CubeRefractionMapping:_e,EquirectangularReflectionMapping:W,EquirectangularRefractionMapping:ae,CubeUVReflectionMapping:pe,CubeUVRefractionMapping:Fe},ad={RepeatWrapping:Ce,ClampToEdgeWrapping:v,MirroredRepeatWrapping:M},sd={NearestFilter:y,NearestMipmapNearestFilter:_,NearestMipmapLinearFilter:ie,LinearFilter:se,LinearMipmapNearestFilter:Ue,LinearMipmapLinearFilter:Be};function Ml(e){typeof createImageBitmap=="undefined"&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),typeof fetch=="undefined"&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),en.call(this,e),this.options={premultiplyAlpha:"none"}}function Sl(){this.type="ShapePath",this.color=new _t,this.subPaths=[],this.currentPath=null}function Tl(e){this.type="Font",this.data=e}function Sm(e,t,n,r,i){const o=i.glyphs[e]||i.glyphs["?"];if(!o)return void console.error('THREE.Font: character "'+e+'" does not exists in font family '+i.familyName+".");const a=new Sl;let s,c,u,p,d,g,m,x;if(o.o){const S=o._cachedOutline||(o._cachedOutline=o.o.split(" "));for(let b=0,R=S.length;b<R;)switch(S[b++]){case"m":s=S[b++]*t+n,c=S[b++]*t+r,a.moveTo(s,c);break;case"l":s=S[b++]*t+n,c=S[b++]*t+r,a.lineTo(s,c);break;case"q":u=S[b++]*t+n,p=S[b++]*t+r,d=S[b++]*t+n,g=S[b++]*t+r,a.quadraticCurveTo(d,g,u,p);break;case"b":u=S[b++]*t+n,p=S[b++]*t+r,d=S[b++]*t+n,g=S[b++]*t+r,m=S[b++]*t+n,x=S[b++]*t+r,a.bezierCurveTo(d,g,m,x,u,p)}}return{offsetX:o.ha*t,path:a}}function El(e){en.call(this,e)}let zs;Ml.prototype=Object.assign(Object.create(en.prototype),{constructor:Ml,isImageBitmapLoader:!0,setOptions:function(e){return this.options=e,this},load:function(e,t,n,r){e===void 0&&(e=""),this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const i=this,o=Bi.get(e);if(o!==void 0)return i.manager.itemStart(e),setTimeout(function(){t&&t(o),i.manager.itemEnd(e)},0),o;const a={};a.credentials=this.crossOrigin==="anonymous"?"same-origin":"include",fetch(e,a).then(function(s){return s.blob()}).then(function(s){return createImageBitmap(s,i.options)}).then(function(s){Bi.add(e,s),t&&t(s),i.manager.itemEnd(e)}).catch(function(s){r&&r(s),i.manager.itemError(e),i.manager.itemEnd(e)}),i.manager.itemStart(e)}}),Object.assign(Sl.prototype,{moveTo:function(e,t){return this.currentPath=new Mr,this.subPaths.push(this.currentPath),this.currentPath.moveTo(e,t),this},lineTo:function(e,t){return this.currentPath.lineTo(e,t),this},quadraticCurveTo:function(e,t,n,r){return this.currentPath.quadraticCurveTo(e,t,n,r),this},bezierCurveTo:function(e,t,n,r,i,o){return this.currentPath.bezierCurveTo(e,t,n,r,i,o),this},splineThru:function(e){return this.currentPath.splineThru(e),this},toShapes:function(e,t){function n(R){const F=[];for(let ee=0,k=R.length;ee<k;ee++){const K=R[ee],le=new di;le.curves=K.curves,F.push(le)}return F}function r(R,F){const ee=F.length;let k=!1;for(let K=ee-1,le=0;le<ee;K=le++){let ge=F[K],Le=F[le],Ae=Le.x-ge.x,xe=Le.y-ge.y;if(Math.abs(xe)>Number.EPSILON){if(xe<0&&(ge=F[le],Ae=-Ae,Le=F[K],xe=-xe),R.y<ge.y||R.y>Le.y)continue;if(R.y===ge.y){if(R.x===ge.x)return!0}else{const Xe=xe*(R.x-ge.x)-Ae*(R.y-ge.y);if(Xe===0)return!0;if(Xe<0)continue;k=!k}}else{if(R.y!==ge.y)continue;if(Le.x<=R.x&&R.x<=ge.x||ge.x<=R.x&&R.x<=Le.x)return!0}}return k}const i=jr.isClockWise,o=this.subPaths;if(o.length===0)return[];if(t===!0)return n(o);let a,s,c;const u=[];if(o.length===1)return s=o[0],c=new di,c.curves=s.curves,u.push(c),u;let p=!i(o[0].getPoints());p=e?!p:p;const d=[],g=[];let m,x,S=[],b=0;g[b]=void 0,S[b]=[];for(let R=0,F=o.length;R<F;R++)s=o[R],m=s.getPoints(),a=i(m),a=e?!a:a,a?(!p&&g[b]&&b++,g[b]={s:new di,p:m},g[b].s.curves=s.curves,p&&b++,S[b]=[]):S[b].push({h:s,p:m[0]});if(!g[0])return n(o);if(g.length>1){let R=!1;const F=[];for(let ee=0,k=g.length;ee<k;ee++)d[ee]=[];for(let ee=0,k=g.length;ee<k;ee++){const K=S[ee];for(let le=0;le<K.length;le++){const ge=K[le];let Le=!0;for(let Ae=0;Ae<g.length;Ae++)r(ge.p,g[Ae].p)&&(ee!==Ae&&F.push({froms:ee,tos:Ae,hole:le}),Le?(Le=!1,d[Ae].push(ge)):R=!0);Le&&d[ee].push(ge)}}F.length>0&&(R||(S=d))}for(let R=0,F=g.length;R<F;R++){c=g[R].s,u.push(c),x=S[R];for(let ee=0,k=x.length;ee<k;ee++)c.holes.push(x[ee].h)}return u}}),Object.assign(Tl.prototype,{isFont:!0,generateShapes:function(e,t=100){const n=[],r=function(i,o,a){const s=Array.from?Array.from(i):String(i).split(""),c=o/a.resolution,u=(a.boundingBox.yMax-a.boundingBox.yMin+a.underlineThickness)*c,p=[];let d=0,g=0;for(let m=0;m<s.length;m++){const x=s[m];if(x===`
`)d=0,g-=u;else{const S=Sm(x,c,d,g,a);d+=S.offsetX,p.push(S.path)}}return p}(e,t,this.data);for(let i=0,o=r.length;i<o;i++)Array.prototype.push.apply(n,r[i].toShapes());return n}}),El.prototype=Object.assign(Object.create(en.prototype),{constructor:El,load:function(e,t,n,r){const i=this,o=new ur(this.manager);o.setPath(this.path),o.setRequestHeader(this.requestHeader),o.setWithCredentials(i.withCredentials),o.load(e,function(a){let s;try{s=JSON.parse(a)}catch(u){console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."),s=JSON.parse(a.substring(65,a.length-2))}const c=i.parse(s);t&&t(c)},n,r)},parse:function(e){return new Tl(e)}});const Al={getContext:function(){return zs===void 0&&(zs=new(window.AudioContext||window.webkitAudioContext)),zs},setContext:function(e){zs=e}};function ks(e){en.call(this,e)}function Ll(e,t,n){hr.call(this,void 0,n);const r=new _t().set(e),i=new _t().set(t),o=new z(r.r,r.g,r.b),a=new z(i.r,i.g,i.b),s=Math.sqrt(Math.PI),c=s*Math.sqrt(.75);this.sh.coefficients[0].copy(o).add(a).multiplyScalar(s),this.sh.coefficients[1].copy(o).sub(a).multiplyScalar(c)}function Cl(e,t){hr.call(this,void 0,t);const n=new _t().set(e);this.sh.coefficients[0].set(n.r,n.g,n.b).multiplyScalar(2*Math.sqrt(Math.PI))}ks.prototype=Object.assign(Object.create(en.prototype),{constructor:ks,load:function(e,t,n,r){const i=this,o=new ur(i.manager);o.setResponseType("arraybuffer"),o.setPath(i.path),o.setRequestHeader(i.requestHeader),o.setWithCredentials(i.withCredentials),o.load(e,function(a){try{const s=a.slice(0);Al.getContext().decodeAudioData(s,function(c){t(c)})}catch(s){r?r(s):console.error(s),i.manager.itemError(e)}},n,r)}}),Ll.prototype=Object.assign(Object.create(hr.prototype),{constructor:Ll,isHemisphereLightProbe:!0,copy:function(e){return hr.prototype.copy.call(this,e),this},toJSON:function(e){return hr.prototype.toJSON.call(this,e)}}),Cl.prototype=Object.assign(Object.create(hr.prototype),{constructor:Cl,isAmbientLightProbe:!0,copy:function(e){return hr.prototype.copy.call(this,e),this},toJSON:function(e){return hr.prototype.toJSON.call(this,e)}});const cd=new Ht,ld=new Ht;function ud(){this.type="StereoCamera",this.aspect=1,this.eyeSep=.064,this.cameraL=new _n,this.cameraL.layers.enable(1),this.cameraL.matrixAutoUpdate=!1,this.cameraR=new _n,this.cameraR.layers.enable(2),this.cameraR.matrixAutoUpdate=!1,this._cache={focus:null,fov:null,aspect:null,near:null,far:null,zoom:null,eyeSep:null}}Object.assign(ud.prototype,{update:function(e){const t=this._cache;if(t.focus!==e.focus||t.fov!==e.fov||t.aspect!==e.aspect*this.aspect||t.near!==e.near||t.far!==e.far||t.zoom!==e.zoom||t.eyeSep!==this.eyeSep){t.focus=e.focus,t.fov=e.fov,t.aspect=e.aspect*this.aspect,t.near=e.near,t.far=e.far,t.zoom=e.zoom,t.eyeSep=this.eyeSep;const n=e.projectionMatrix.clone(),r=t.eyeSep/2,i=r*t.near/t.focus,o=t.near*Math.tan(Ft.DEG2RAD*t.fov*.5)/t.zoom;let a,s;ld.elements[12]=-r,cd.elements[12]=r,a=-o*t.aspect+i,s=o*t.aspect+i,n.elements[0]=2*t.near/(s-a),n.elements[8]=(s+a)/(s-a),this.cameraL.projectionMatrix.copy(n),a=-o*t.aspect-i,s=o*t.aspect-i,n.elements[0]=2*t.near/(s-a),n.elements[8]=(s+a)/(s-a),this.cameraR.projectionMatrix.copy(n)}this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(ld),this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(cd)}});class hd{constructor(e){this.autoStart=e===void 0||e,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=dd(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let e=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){const t=dd();e=(t-this.oldTime)/1e3,this.oldTime=t,this.elapsedTime+=e}return e}}function dd(){return(typeof performance=="undefined"?Date:performance).now()}const Fi=new z,pd=new Nn,Tm=new z,Ui=new z;class Em extends At{constructor(){super(),this.type="AudioListener",this.context=Al.getContext(),this.gain=this.context.createGain(),this.gain.connect(this.context.destination),this.filter=null,this.timeDelta=0,this._clock=new hd}getInput(){return this.gain}removeFilter(){return this.filter!==null&&(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination),this.gain.connect(this.context.destination),this.filter=null),this}getFilter(){return this.filter}setFilter(e){return this.filter!==null?(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination)):this.gain.disconnect(this.context.destination),this.filter=e,this.gain.connect(this.filter),this.filter.connect(this.context.destination),this}getMasterVolume(){return this.gain.gain.value}setMasterVolume(e){return this.gain.gain.setTargetAtTime(e,this.context.currentTime,.01),this}updateMatrixWorld(e){super.updateMatrixWorld(e);const t=this.context.listener,n=this.up;if(this.timeDelta=this._clock.getDelta(),this.matrixWorld.decompose(Fi,pd,Tm),Ui.set(0,0,-1).applyQuaternion(pd),t.positionX){const r=this.context.currentTime+this.timeDelta;t.positionX.linearRampToValueAtTime(Fi.x,r),t.positionY.linearRampToValueAtTime(Fi.y,r),t.positionZ.linearRampToValueAtTime(Fi.z,r),t.forwardX.linearRampToValueAtTime(Ui.x,r),t.forwardY.linearRampToValueAtTime(Ui.y,r),t.forwardZ.linearRampToValueAtTime(Ui.z,r),t.upX.linearRampToValueAtTime(n.x,r),t.upY.linearRampToValueAtTime(n.y,r),t.upZ.linearRampToValueAtTime(n.z,r)}else t.setPosition(Fi.x,Fi.y,Fi.z),t.setOrientation(Ui.x,Ui.y,Ui.z,n.x,n.y,n.z)}}class Pl extends At{constructor(e){super(),this.type="Audio",this.listener=e,this.context=e.context,this.gain=this.context.createGain(),this.gain.connect(e.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(e){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=e,this.connect(),this}setMediaElementSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(e),this.connect(),this}setMediaStreamSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(e),this.connect(),this}setBuffer(e){return this.buffer=e,this.sourceType="buffer",this.autoplay&&this.play(),this}play(e=0){if(this.isPlaying===!0)return void console.warn("THREE.Audio: Audio is already playing.");if(this.hasPlaybackControl===!1)return void console.warn("THREE.Audio: this Audio has no playback control.");this._startedAt=this.context.currentTime+e;const t=this.context.createBufferSource();return t.buffer=this.buffer,t.loop=this.loop,t.loopStart=this.loopStart,t.loopEnd=this.loopEnd,t.onended=this.onEnded.bind(this),t.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=t,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(this.hasPlaybackControl!==!1)return this.isPlaying===!0&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,this.loop===!0&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this;console.warn("THREE.Audio: this Audio has no playback control.")}stop(){if(this.hasPlaybackControl!==!1)return this._progress=0,this.source.stop(),this.source.onended=null,this.isPlaying=!1,this;console.warn("THREE.Audio: this Audio has no playback control.")}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let e=1,t=this.filters.length;e<t;e++)this.filters[e-1].connect(this.filters[e]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let e=1,t=this.filters.length;e<t;e++)this.filters[e-1].disconnect(this.filters[e]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}getFilters(){return this.filters}setFilters(e){return e||(e=[]),this._connected===!0?(this.disconnect(),this.filters=e.slice(),this.connect()):this.filters=e.slice(),this}setDetune(e){if(this.detune=e,this.source.detune!==void 0)return this.isPlaying===!0&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(e){return this.setFilters(e?[e]:[])}setPlaybackRate(e){if(this.hasPlaybackControl!==!1)return this.playbackRate=e,this.isPlaying===!0&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this;console.warn("THREE.Audio: this Audio has no playback control.")}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1}getLoop(){return this.hasPlaybackControl===!1?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop}setLoop(e){if(this.hasPlaybackControl!==!1)return this.loop=e,this.isPlaying===!0&&(this.source.loop=this.loop),this;console.warn("THREE.Audio: this Audio has no playback control.")}setLoopStart(e){return this.loopStart=e,this}setLoopEnd(e){return this.loopEnd=e,this}getVolume(){return this.gain.gain.value}setVolume(e){return this.gain.gain.setTargetAtTime(e,this.context.currentTime,.01),this}}const zi=new z,fd=new Nn,Am=new z,ki=new z;class Lm extends Pl{constructor(e){super(e),this.panner=this.context.createPanner(),this.panner.panningModel="HRTF",this.panner.connect(this.gain)}getOutput(){return this.panner}getRefDistance(){return this.panner.refDistance}setRefDistance(e){return this.panner.refDistance=e,this}getRolloffFactor(){return this.panner.rolloffFactor}setRolloffFactor(e){return this.panner.rolloffFactor=e,this}getDistanceModel(){return this.panner.distanceModel}setDistanceModel(e){return this.panner.distanceModel=e,this}getMaxDistance(){return this.panner.maxDistance}setMaxDistance(e){return this.panner.maxDistance=e,this}setDirectionalCone(e,t,n){return this.panner.coneInnerAngle=e,this.panner.coneOuterAngle=t,this.panner.coneOuterGain=n,this}updateMatrixWorld(e){if(super.updateMatrixWorld(e),this.hasPlaybackControl===!0&&this.isPlaying===!1)return;this.matrixWorld.decompose(zi,fd,Am),ki.set(0,0,1).applyQuaternion(fd);const t=this.panner;if(t.positionX){const n=this.context.currentTime+this.listener.timeDelta;t.positionX.linearRampToValueAtTime(zi.x,n),t.positionY.linearRampToValueAtTime(zi.y,n),t.positionZ.linearRampToValueAtTime(zi.z,n),t.orientationX.linearRampToValueAtTime(ki.x,n),t.orientationY.linearRampToValueAtTime(ki.y,n),t.orientationZ.linearRampToValueAtTime(ki.z,n)}else t.setPosition(zi.x,zi.y,zi.z),t.setOrientation(ki.x,ki.y,ki.z)}}class md{constructor(e,t=2048){this.analyser=e.context.createAnalyser(),this.analyser.fftSize=t,this.data=new Uint8Array(this.analyser.frequencyBinCount),e.getOutput().connect(this.analyser)}getFrequencyData(){return this.analyser.getByteFrequencyData(this.data),this.data}getAverageFrequency(){let e=0;const t=this.getFrequencyData();for(let n=0;n<t.length;n++)e+=t[n];return e/t.length}}function Rl(e,t,n){let r,i,o;switch(this.binding=e,this.valueSize=n,t){case"quaternion":r=this._slerp,i=this._slerpAdditive,o=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(6*n),this._workIndex=5;break;case"string":case"bool":r=this._select,i=this._select,o=this._setAdditiveIdentityOther,this.buffer=new Array(5*n);break;default:r=this._lerp,i=this._lerpAdditive,o=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(5*n)}this._mixBufferRegion=r,this._mixBufferRegionAdditive=i,this._setIdentity=o,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}Object.assign(Rl.prototype,{accumulate:function(e,t){const n=this.buffer,r=this.valueSize,i=e*r+r;let o=this.cumulativeWeight;if(o===0){for(let a=0;a!==r;++a)n[i+a]=n[a];o=t}else{o+=t;const a=t/o;this._mixBufferRegion(n,i,0,a,r)}this.cumulativeWeight=o},accumulateAdditive:function(e){const t=this.buffer,n=this.valueSize,r=n*this._addIndex;this.cumulativeWeightAdditive===0&&this._setIdentity(),this._mixBufferRegionAdditive(t,r,0,e,n),this.cumulativeWeightAdditive+=e},apply:function(e){const t=this.valueSize,n=this.buffer,r=e*t+t,i=this.cumulativeWeight,o=this.cumulativeWeightAdditive,a=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,i<1){const s=t*this._origIndex;this._mixBufferRegion(n,r,s,1-i,t)}o>0&&this._mixBufferRegionAdditive(n,r,this._addIndex*t,1,t);for(let s=t,c=t+t;s!==c;++s)if(n[s]!==n[s+t]){a.setValue(n,r);break}},saveOriginalState:function(){const e=this.binding,t=this.buffer,n=this.valueSize,r=n*this._origIndex;e.getValue(t,r);for(let i=n,o=r;i!==o;++i)t[i]=t[r+i%n];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0},restoreOriginalState:function(){const e=3*this.valueSize;this.binding.setValue(this.buffer,e)},_setAdditiveIdentityNumeric:function(){const e=this._addIndex*this.valueSize,t=e+this.valueSize;for(let n=e;n<t;n++)this.buffer[n]=0},_setAdditiveIdentityQuaternion:function(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1},_setAdditiveIdentityOther:function(){const e=this._origIndex*this.valueSize,t=this._addIndex*this.valueSize;for(let n=0;n<this.valueSize;n++)this.buffer[t+n]=this.buffer[e+n]},_select:function(e,t,n,r,i){if(r>=.5)for(let o=0;o!==i;++o)e[t+o]=e[n+o]},_slerp:function(e,t,n,r){Nn.slerpFlat(e,t,e,t,e,n,r)},_slerpAdditive:function(e,t,n,r,i){const o=this._workIndex*i;Nn.multiplyQuaternionsFlat(e,o,e,t,e,n),Nn.slerpFlat(e,t,e,t,e,o,r)},_lerp:function(e,t,n,r,i){const o=1-r;for(let a=0;a!==i;++a){const s=t+a;e[s]=e[s]*o+e[n+a]*r}},_lerpAdditive:function(e,t,n,r,i){for(let o=0;o!==i;++o){const a=t+o;e[a]=e[a]+e[n+o]*r}}});const Cm=new RegExp("[\\[\\]\\.:\\/]","g"),Pm="[^"+"\\[\\]\\.:\\/".replace("\\.","")+"]",Rm=/((?:WC+[\/:])*)/.source.replace("WC","[^\\[\\]\\.:\\/]"),Om=/(WCOD+)?/.source.replace("WCOD",Pm),Dm=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC","[^\\[\\]\\.:\\/]"),Im=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC","[^\\[\\]\\.:\\/]"),Nm=new RegExp("^"+Rm+Om+Dm+Im+"$"),Bm=["material","materials","bones"];function gd(e,t,n){const r=n||zn.parseTrackName(t);this._targetGroup=e,this._bindings=e.subscribe_(t,r)}function zn(e,t,n){this.path=t,this.parsedPath=n||zn.parseTrackName(t),this.node=zn.findNode(e,this.parsedPath.nodeName)||e,this.rootNode=e}function vd(){this.uuid=Ft.generateUUID(),this._objects=Array.prototype.slice.call(arguments),this.nCachedObjects_=0;const e={};this._indicesByUUID=e;for(let n=0,r=arguments.length;n!==r;++n)e[arguments[n].uuid]=n;this._paths=[],this._parsedPaths=[],this._bindings=[],this._bindingsIndicesByPath={};const t=this;this.stats={objects:{get total(){return t._objects.length},get inUse(){return this.total-t.nCachedObjects_}},get bindingsPerObject(){return t._bindings.length}}}Object.assign(gd.prototype,{getValue:function(e,t){this.bind();const n=this._targetGroup.nCachedObjects_,r=this._bindings[n];r!==void 0&&r.getValue(e,t)},setValue:function(e,t){const n=this._bindings;for(let r=this._targetGroup.nCachedObjects_,i=n.length;r!==i;++r)n[r].setValue(e,t)},bind:function(){const e=this._bindings;for(let t=this._targetGroup.nCachedObjects_,n=e.length;t!==n;++t)e[t].bind()},unbind:function(){const e=this._bindings;for(let t=this._targetGroup.nCachedObjects_,n=e.length;t!==n;++t)e[t].unbind()}}),Object.assign(zn,{Composite:gd,create:function(e,t,n){return e&&e.isAnimationObjectGroup?new zn.Composite(e,t,n):new zn(e,t,n)},sanitizeNodeName:function(e){return e.replace(/\s/g,"_").replace(Cm,"")},parseTrackName:function(e){const t=Nm.exec(e);if(!t)throw new Error("PropertyBinding: Cannot parse trackName: "+e);const n={nodeName:t[2],objectName:t[3],objectIndex:t[4],propertyName:t[5],propertyIndex:t[6]},r=n.nodeName&&n.nodeName.lastIndexOf(".");if(r!==void 0&&r!==-1){const i=n.nodeName.substring(r+1);Bm.indexOf(i)!==-1&&(n.nodeName=n.nodeName.substring(0,r),n.objectName=i)}if(n.propertyName===null||n.propertyName.length===0)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+e);return n},findNode:function(e,t){if(!t||t===""||t==="."||t===-1||t===e.name||t===e.uuid)return e;if(e.skeleton){const n=e.skeleton.getBoneByName(t);if(n!==void 0)return n}if(e.children){const n=function(i){for(let o=0;o<i.length;o++){const a=i[o];if(a.name===t||a.uuid===t)return a;const s=n(a.children);if(s)return s}return null},r=n(e.children);if(r)return r}return null}}),Object.assign(zn.prototype,{_getValue_unavailable:function(){},_setValue_unavailable:function(){},BindingType:{Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3},Versioning:{None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2},GetterByBindingType:[function(e,t){e[t]=this.node[this.propertyName]},function(e,t){const n=this.resolvedProperty;for(let r=0,i=n.length;r!==i;++r)e[t++]=n[r]},function(e,t){e[t]=this.resolvedProperty[this.propertyIndex]},function(e,t){this.resolvedProperty.toArray(e,t)}],SetterByBindingTypeAndVersioning:[[function(e,t){this.targetObject[this.propertyName]=e[t]},function(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.needsUpdate=!0},function(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}],[function(e,t){const n=this.resolvedProperty;for(let r=0,i=n.length;r!==i;++r)n[r]=e[t++]},function(e,t){const n=this.resolvedProperty;for(let r=0,i=n.length;r!==i;++r)n[r]=e[t++];this.targetObject.needsUpdate=!0},function(e,t){const n=this.resolvedProperty;for(let r=0,i=n.length;r!==i;++r)n[r]=e[t++];this.targetObject.matrixWorldNeedsUpdate=!0}],[function(e,t){this.resolvedProperty[this.propertyIndex]=e[t]},function(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.needsUpdate=!0},function(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}],[function(e,t){this.resolvedProperty.fromArray(e,t)},function(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.needsUpdate=!0},function(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.matrixWorldNeedsUpdate=!0}]],getValue:function(e,t){this.bind(),this.getValue(e,t)},setValue:function(e,t){this.bind(),this.setValue(e,t)},bind:function(){let e=this.node;const t=this.parsedPath,n=t.objectName,r=t.propertyName;let i=t.propertyIndex;if(e||(e=zn.findNode(this.rootNode,t.nodeName)||this.rootNode,this.node=e),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!e)return void console.error("THREE.PropertyBinding: Trying to update node for track: "+this.path+" but it wasn't found.");if(n){let c=t.objectIndex;switch(n){case"materials":if(!e.material)return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);if(!e.material.materials)return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);e=e.material.materials;break;case"bones":if(!e.skeleton)return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);e=e.skeleton.bones;for(let u=0;u<e.length;u++)if(e[u].name===c){c=u;break}break;default:if(e[n]===void 0)return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);e=e[n]}if(c!==void 0){if(e[c]===void 0)return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,e);e=e[c]}}const o=e[r];if(o===void 0){const c=t.nodeName;return void console.error("THREE.PropertyBinding: Trying to update property for track: "+c+"."+r+" but it wasn't found.",e)}let a=this.Versioning.None;this.targetObject=e,e.needsUpdate!==void 0?a=this.Versioning.NeedsUpdate:e.matrixWorldNeedsUpdate!==void 0&&(a=this.Versioning.MatrixWorldNeedsUpdate);let s=this.BindingType.Direct;if(i!==void 0){if(r==="morphTargetInfluences"){if(!e.geometry)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);if(!e.geometry.isBufferGeometry)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",this);if(!e.geometry.morphAttributes)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);e.morphTargetDictionary[i]!==void 0&&(i=e.morphTargetDictionary[i])}s=this.BindingType.ArrayElement,this.resolvedProperty=o,this.propertyIndex=i}else o.fromArray!==void 0&&o.toArray!==void 0?(s=this.BindingType.HasFromToArray,this.resolvedProperty=o):Array.isArray(o)?(s=this.BindingType.EntireArray,this.resolvedProperty=o):this.propertyName=r;this.getValue=this.GetterByBindingType[s],this.setValue=this.SetterByBindingTypeAndVersioning[s][a]},unbind:function(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}),Object.assign(zn.prototype,{_getValue_unbound:zn.prototype.getValue,_setValue_unbound:zn.prototype.setValue}),Object.assign(vd.prototype,{isAnimationObjectGroup:!0,add:function(){const e=this._objects,t=this._indicesByUUID,n=this._paths,r=this._parsedPaths,i=this._bindings,o=i.length;let a,s=e.length,c=this.nCachedObjects_;for(let u=0,p=arguments.length;u!==p;++u){const d=arguments[u],g=d.uuid;let m=t[g];if(m===void 0){m=s++,t[g]=m,e.push(d);for(let x=0,S=o;x!==S;++x)i[x].push(new zn(d,n[x],r[x]))}else if(m<c){a=e[m];const x=--c,S=e[x];t[S.uuid]=m,e[m]=S,t[g]=x,e[x]=d;for(let b=0,R=o;b!==R;++b){const F=i[b],ee=F[x];let k=F[m];F[m]=ee,k===void 0&&(k=new zn(d,n[b],r[b])),F[x]=k}}else e[m]!==a&&console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")}this.nCachedObjects_=c},remove:function(){const e=this._objects,t=this._indicesByUUID,n=this._bindings,r=n.length;let i=this.nCachedObjects_;for(let o=0,a=arguments.length;o!==a;++o){const s=arguments[o],c=s.uuid,u=t[c];if(u!==void 0&&u>=i){const p=i++,d=e[p];t[d.uuid]=u,e[u]=d,t[c]=p,e[p]=s;for(let g=0,m=r;g!==m;++g){const x=n[g],S=x[p],b=x[u];x[u]=S,x[p]=b}}}this.nCachedObjects_=i},uncache:function(){const e=this._objects,t=this._indicesByUUID,n=this._bindings,r=n.length;let i=this.nCachedObjects_,o=e.length;for(let a=0,s=arguments.length;a!==s;++a){const c=arguments[a].uuid,u=t[c];if(u!==void 0)if(delete t[c],u<i){const p=--i,d=e[p],g=--o,m=e[g];t[d.uuid]=u,e[u]=d,t[m.uuid]=p,e[p]=m,e.pop();for(let x=0,S=r;x!==S;++x){const b=n[x],R=b[p],F=b[g];b[u]=R,b[p]=F,b.pop()}}else{const p=--o,d=e[p];p>0&&(t[d.uuid]=u),e[u]=d,e.pop();for(let g=0,m=r;g!==m;++g){const x=n[g];x[u]=x[p],x.pop()}}}this.nCachedObjects_=i},subscribe_:function(e,t){const n=this._bindingsIndicesByPath;let r=n[e];const i=this._bindings;if(r!==void 0)return i[r];const o=this._paths,a=this._parsedPaths,s=this._objects,c=s.length,u=this.nCachedObjects_,p=new Array(c);r=i.length,n[e]=r,o.push(e),a.push(t),i.push(p);for(let d=u,g=s.length;d!==g;++d){const m=s[d];p[d]=new zn(m,e,t)}return p},unsubscribe_:function(e){const t=this._bindingsIndicesByPath,n=t[e];if(n!==void 0){const r=this._paths,i=this._parsedPaths,o=this._bindings,a=o.length-1,s=o[a];t[e[a]]=n,o[n]=s,o.pop(),i[n]=i[a],i.pop(),r[n]=r[a],r.pop()}}});class Fm{constructor(e,t,n=null,r=t.blendMode){this._mixer=e,this._clip=t,this._localRoot=n,this.blendMode=r;const i=t.tracks,o=i.length,a=new Array(o),s={endingStart:vi,endingEnd:vi};for(let c=0;c!==o;++c){const u=i[c].createInterpolant(null);a[c]=u,u.settings=s}this._interpolantSettings=s,this._interpolants=a,this._propertyBindings=new Array(o),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=Ru,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&this.timeScale!==0&&this._startTime===null&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(e){return this._startTime=e,this}setLoop(e,t){return this.loop=e,this.repetitions=t,this}setEffectiveWeight(e){return this.weight=e,this._effectiveWeight=this.enabled?e:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(e){return this._scheduleFading(e,0,1)}fadeOut(e){return this._scheduleFading(e,1,0)}crossFadeFrom(e,t,n){if(e.fadeOut(t),this.fadeIn(t),n){const r=this._clip.duration,i=e._clip.duration,o=i/r,a=r/i;e.warp(1,o,t),this.warp(a,1,t)}return this}crossFadeTo(e,t,n){return e.crossFadeFrom(this,t,n)}stopFading(){const e=this._weightInterpolant;return e!==null&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}setEffectiveTimeScale(e){return this.timeScale=e,this._effectiveTimeScale=this.paused?0:e,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(e){return this.timeScale=this._clip.duration/e,this.stopWarping()}syncWith(e){return this.time=e.time,this.timeScale=e.timeScale,this.stopWarping()}halt(e){return this.warp(this._effectiveTimeScale,0,e)}warp(e,t,n){const r=this._mixer,i=r.time,o=this.timeScale;let a=this._timeScaleInterpolant;a===null&&(a=r._lendControlInterpolant(),this._timeScaleInterpolant=a);const s=a.parameterPositions,c=a.sampleValues;return s[0]=i,s[1]=i+n,c[0]=e/o,c[1]=t/o,this}stopWarping(){const e=this._timeScaleInterpolant;return e!==null&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(e,t,n,r){if(!this.enabled)return void this._updateWeight(e);const i=this._startTime;if(i!==null){const s=(e-i)*n;if(s<0||n===0)return;this._startTime=null,t=n*s}t*=this._updateTimeScale(e);const o=this._updateTime(t),a=this._updateWeight(e);if(a>0){const s=this._interpolants,c=this._propertyBindings;switch(this.blendMode){case sc:for(let u=0,p=s.length;u!==p;++u)s[u].evaluate(o),c[u].accumulateAdditive(a);break;case Ra:default:for(let u=0,p=s.length;u!==p;++u)s[u].evaluate(o),c[u].accumulate(r,a)}}}_updateWeight(e){let t=0;if(this.enabled){t=this.weight;const n=this._weightInterpolant;if(n!==null){const r=n.evaluate(e)[0];t*=r,e>n.parameterPositions[1]&&(this.stopFading(),r===0&&(this.enabled=!1))}}return this._effectiveWeight=t,t}_updateTimeScale(e){let t=0;if(!this.paused){t=this.timeScale;const n=this._timeScaleInterpolant;n!==null&&(t*=n.evaluate(e)[0],e>n.parameterPositions[1]&&(this.stopWarping(),t===0?this.paused=!0:this.timeScale=t))}return this._effectiveTimeScale=t,t}_updateTime(e){const t=this._clip.duration,n=this.loop;let r=this.time+e,i=this._loopCount;const o=n===Ou;if(e===0)return i===-1?r:o&&(1&i)==1?t-r:r;if(n===Pu){i===-1&&(this._loopCount=0,this._setEndings(!0,!0,!1));e:{if(r>=t)r=t;else{if(!(r<0)){this.time=r;break e}r=0}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=r,this._mixer.dispatchEvent({type:"finished",action:this,direction:e<0?-1:1})}}else{if(i===-1&&(e>=0?(i=0,this._setEndings(!0,this.repetitions===0,o)):this._setEndings(this.repetitions===0,!0,o)),r>=t||r<0){const a=Math.floor(r/t);r-=t*a,i+=Math.abs(a);const s=this.repetitions-i;if(s<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,r=e>0?t:0,this.time=r,this._mixer.dispatchEvent({type:"finished",action:this,direction:e>0?1:-1});else{if(s===1){const c=e<0;this._setEndings(c,!c,o)}else this._setEndings(!1,!1,o);this._loopCount=i,this.time=r,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:a})}}else this.time=r;if(o&&(1&i)==1)return t-r}return r}_setEndings(e,t,n){const r=this._interpolantSettings;n?(r.endingStart=yi,r.endingEnd=yi):(r.endingStart=e?this.zeroSlopeAtStart?yi:vi:Co,r.endingEnd=t?this.zeroSlopeAtEnd?yi:vi:Co)}_scheduleFading(e,t,n){const r=this._mixer,i=r.time;let o=this._weightInterpolant;o===null&&(o=r._lendControlInterpolant(),this._weightInterpolant=o);const a=o.parameterPositions,s=o.sampleValues;return a[0]=i,s[0]=t,a[1]=i+e,s[1]=n,this}}function Ol(e){this._root=e,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}Ol.prototype=Object.assign(Object.create(Sr.prototype),{constructor:Ol,_bindAction:function(e,t){const n=e._localRoot||this._root,r=e._clip.tracks,i=r.length,o=e._propertyBindings,a=e._interpolants,s=n.uuid,c=this._bindingsByRootAndName;let u=c[s];u===void 0&&(u={},c[s]=u);for(let p=0;p!==i;++p){const d=r[p],g=d.name;let m=u[g];if(m!==void 0)o[p]=m;else{if(m=o[p],m!==void 0){m._cacheIndex===null&&(++m.referenceCount,this._addInactiveBinding(m,s,g));continue}const x=t&&t._propertyBindings[p].binding.parsedPath;m=new Rl(zn.create(n,g,x),d.ValueTypeName,d.getValueSize()),++m.referenceCount,this._addInactiveBinding(m,s,g),o[p]=m}a[p].resultBuffer=m.buffer}},_activateAction:function(e){if(!this._isActiveAction(e)){if(e._cacheIndex===null){const n=(e._localRoot||this._root).uuid,r=e._clip.uuid,i=this._actionsByClip[r];this._bindAction(e,i&&i.knownActions[0]),this._addInactiveAction(e,r,n)}const t=e._propertyBindings;for(let n=0,r=t.length;n!==r;++n){const i=t[n];i.useCount++==0&&(this._lendBinding(i),i.saveOriginalState())}this._lendAction(e)}},_deactivateAction:function(e){if(this._isActiveAction(e)){const t=e._propertyBindings;for(let n=0,r=t.length;n!==r;++n){const i=t[n];--i.useCount==0&&(i.restoreOriginalState(),this._takeBackBinding(i))}this._takeBackAction(e)}},_initMemoryManager:function(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const e=this;this.stats={actions:{get total(){return e._actions.length},get inUse(){return e._nActiveActions}},bindings:{get total(){return e._bindings.length},get inUse(){return e._nActiveBindings}},controlInterpolants:{get total(){return e._controlInterpolants.length},get inUse(){return e._nActiveControlInterpolants}}}},_isActiveAction:function(e){const t=e._cacheIndex;return t!==null&&t<this._nActiveActions},_addInactiveAction:function(e,t,n){const r=this._actions,i=this._actionsByClip;let o=i[t];if(o===void 0)o={knownActions:[e],actionByRoot:{}},e._byClipCacheIndex=0,i[t]=o;else{const a=o.knownActions;e._byClipCacheIndex=a.length,a.push(e)}e._cacheIndex=r.length,r.push(e),o.actionByRoot[n]=e},_removeInactiveAction:function(e){const t=this._actions,n=t[t.length-1],r=e._cacheIndex;n._cacheIndex=r,t[r]=n,t.pop(),e._cacheIndex=null;const i=e._clip.uuid,o=this._actionsByClip,a=o[i],s=a.knownActions,c=s[s.length-1],u=e._byClipCacheIndex;c._byClipCacheIndex=u,s[u]=c,s.pop(),e._byClipCacheIndex=null,delete a.actionByRoot[(e._localRoot||this._root).uuid],s.length===0&&delete o[i],this._removeInactiveBindingsForAction(e)},_removeInactiveBindingsForAction:function(e){const t=e._propertyBindings;for(let n=0,r=t.length;n!==r;++n){const i=t[n];--i.referenceCount==0&&this._removeInactiveBinding(i)}},_lendAction:function(e){const t=this._actions,n=e._cacheIndex,r=this._nActiveActions++,i=t[r];e._cacheIndex=r,t[r]=e,i._cacheIndex=n,t[n]=i},_takeBackAction:function(e){const t=this._actions,n=e._cacheIndex,r=--this._nActiveActions,i=t[r];e._cacheIndex=r,t[r]=e,i._cacheIndex=n,t[n]=i},_addInactiveBinding:function(e,t,n){const r=this._bindingsByRootAndName,i=this._bindings;let o=r[t];o===void 0&&(o={},r[t]=o),o[n]=e,e._cacheIndex=i.length,i.push(e)},_removeInactiveBinding:function(e){const t=this._bindings,n=e.binding,r=n.rootNode.uuid,i=n.path,o=this._bindingsByRootAndName,a=o[r],s=t[t.length-1],c=e._cacheIndex;s._cacheIndex=c,t[c]=s,t.pop(),delete a[i],Object.keys(a).length===0&&delete o[r]},_lendBinding:function(e){const t=this._bindings,n=e._cacheIndex,r=this._nActiveBindings++,i=t[r];e._cacheIndex=r,t[r]=e,i._cacheIndex=n,t[n]=i},_takeBackBinding:function(e){const t=this._bindings,n=e._cacheIndex,r=--this._nActiveBindings,i=t[r];e._cacheIndex=r,t[r]=e,i._cacheIndex=n,t[n]=i},_lendControlInterpolant:function(){const e=this._controlInterpolants,t=this._nActiveControlInterpolants++;let n=e[t];return n===void 0&&(n=new ga(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer),n.__cacheIndex=t,e[t]=n),n},_takeBackControlInterpolant:function(e){const t=this._controlInterpolants,n=e.__cacheIndex,r=--this._nActiveControlInterpolants,i=t[r];e.__cacheIndex=r,t[r]=e,i.__cacheIndex=n,t[n]=i},_controlInterpolantsResultBuffer:new Float32Array(1),clipAction:function(e,t,n){const r=t||this._root,i=r.uuid;let o=typeof e=="string"?rr.findByName(r,e):e;const a=o!==null?o.uuid:e,s=this._actionsByClip[a];let c=null;if(n===void 0&&(n=o!==null?o.blendMode:Ra),s!==void 0){const p=s.actionByRoot[i];if(p!==void 0&&p.blendMode===n)return p;c=s.knownActions[0],o===null&&(o=c._clip)}if(o===null)return null;const u=new Fm(this,o,t,n);return this._bindAction(u,c),this._addInactiveAction(u,a,i),u},existingAction:function(e,t){const n=t||this._root,r=n.uuid,i=typeof e=="string"?rr.findByName(n,e):e,o=i?i.uuid:e,a=this._actionsByClip[o];return a!==void 0&&a.actionByRoot[r]||null},stopAllAction:function(){const e=this._actions;for(let t=this._nActiveActions-1;t>=0;--t)e[t].stop();return this},update:function(e){e*=this.timeScale;const t=this._actions,n=this._nActiveActions,r=this.time+=e,i=Math.sign(e),o=this._accuIndex^=1;for(let c=0;c!==n;++c)t[c]._update(r,e,i,o);const a=this._bindings,s=this._nActiveBindings;for(let c=0;c!==s;++c)a[c].apply(o);return this},setTime:function(e){this.time=0;for(let t=0;t<this._actions.length;t++)this._actions[t].time=0;return this.update(e)},getRoot:function(){return this._root},uncacheClip:function(e){const t=this._actions,n=e.uuid,r=this._actionsByClip,i=r[n];if(i!==void 0){const o=i.knownActions;for(let a=0,s=o.length;a!==s;++a){const c=o[a];this._deactivateAction(c);const u=c._cacheIndex,p=t[t.length-1];c._cacheIndex=null,c._byClipCacheIndex=null,p._cacheIndex=u,t[u]=p,t.pop(),this._removeInactiveBindingsForAction(c)}delete r[n]}},uncacheRoot:function(e){const t=e.uuid,n=this._actionsByClip;for(const i in n){const o=n[i].actionByRoot[t];o!==void 0&&(this._deactivateAction(o),this._removeInactiveAction(o))}const r=this._bindingsByRootAndName[t];if(r!==void 0)for(const i in r){const o=r[i];o.restoreOriginalState(),this._removeInactiveBinding(o)}},uncacheAction:function(e,t){const n=this.existingAction(e,t);n!==null&&(this._deactivateAction(n),this._removeInactiveAction(n))}});class Dl{constructor(e){typeof e=="string"&&(console.warn("THREE.Uniform: Type parameter is no longer needed."),e=arguments[1]),this.value=e}clone(){return new Dl(this.value.clone===void 0?this.value:this.value.clone())}}function Il(e,t,n){tr.call(this,e,t),this.meshPerAttribute=n||1}function Nl(e,t,n,r,i){this.buffer=e,this.type=t,this.itemSize=n,this.elementSize=r,this.count=i,this.version=0}function Bl(e,t,n,r){this.ray=new Ji(e,t),this.near=n||0,this.far=r||1/0,this.camera=null,this.layers=new bc,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}},Object.defineProperties(this.params,{PointCloud:{get:function(){return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."),this.Points}}})}function yd(e,t){return e.distance-t.distance}function Fl(e,t,n,r){if(e.layers.test(t.layers)&&e.raycast(t,n),r===!0){const i=e.children;for(let o=0,a=i.length;o<a;o++)Fl(i[o],t,n,!0)}}Il.prototype=Object.assign(Object.create(tr.prototype),{constructor:Il,isInstancedInterleavedBuffer:!0,copy:function(e){return tr.prototype.copy.call(this,e),this.meshPerAttribute=e.meshPerAttribute,this},clone:function(e){const t=tr.prototype.clone.call(this,e);return t.meshPerAttribute=this.meshPerAttribute,t},toJSON:function(e){const t=tr.prototype.toJSON.call(this,e);return t.isInstancedInterleavedBuffer=!0,t.meshPerAttribute=this.meshPerAttribute,t}}),Object.defineProperty(Nl.prototype,"needsUpdate",{set:function(e){e===!0&&this.version++}}),Object.assign(Nl.prototype,{isGLBufferAttribute:!0,setBuffer:function(e){return this.buffer=e,this},setType:function(e,t){return this.type=e,this.elementSize=t,this},setItemSize:function(e){return this.itemSize=e,this},setCount:function(e){return this.count=e,this}}),Object.assign(Bl.prototype,{set:function(e,t){this.ray.set(e,t)},setFromCamera:function(e,t){t&&t.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(t.matrixWorld),this.ray.direction.set(e.x,e.y,.5).unproject(t).sub(this.ray.origin).normalize(),this.camera=t):t&&t.isOrthographicCamera?(this.ray.origin.set(e.x,e.y,(t.near+t.far)/(t.near-t.far)).unproject(t),this.ray.direction.set(0,0,-1).transformDirection(t.matrixWorld),this.camera=t):console.error("THREE.Raycaster: Unsupported camera type.")},intersectObject:function(e,t,n){const r=n||[];return Fl(e,this,r,t),r.sort(yd),r},intersectObjects:function(e,t,n){const r=n||[];if(Array.isArray(e)===!1)return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."),r;for(let i=0,o=e.length;i<o;i++)Fl(e[i],this,r,t);return r.sort(yd),r}});class Um{constructor(e=1,t=0,n=0){return this.radius=e,this.phi=t,this.theta=n,this}set(e,t,n){return this.radius=e,this.phi=t,this.theta=n,this}clone(){return new this.constructor().copy(this)}copy(e){return this.radius=e.radius,this.phi=e.phi,this.theta=e.theta,this}makeSafe(){return this.phi=Math.max(1e-6,Math.min(Math.PI-1e-6,this.phi)),this}setFromVector3(e){return this.setFromCartesianCoords(e.x,e.y,e.z)}setFromCartesianCoords(e,t,n){return this.radius=Math.sqrt(e*e+t*t+n*n),this.radius===0?(this.theta=0,this.phi=0):(this.theta=Math.atan2(e,n),this.phi=Math.acos(Ft.clamp(t/this.radius,-1,1))),this}}class zm{constructor(e,t,n){return this.radius=e!==void 0?e:1,this.theta=t!==void 0?t:0,this.y=n!==void 0?n:0,this}set(e,t,n){return this.radius=e,this.theta=t,this.y=n,this}clone(){return new this.constructor().copy(this)}copy(e){return this.radius=e.radius,this.theta=e.theta,this.y=e.y,this}setFromVector3(e){return this.setFromCartesianCoords(e.x,e.y,e.z)}setFromCartesianCoords(e,t,n){return this.radius=Math.sqrt(e*e+n*n),this.theta=Math.atan2(e,n),this.y=t,this}}const xd=new Je;class bd{constructor(e,t){Object.defineProperty(this,"isBox2",{value:!0}),this.min=e!==void 0?e:new Je(1/0,1/0),this.max=t!==void 0?t:new Je(-1/0,-1/0)}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromPoints(e){this.makeEmpty();for(let t=0,n=e.length;t<n;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){const n=xd.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(n),this.max.copy(e).add(n),this}clone(){return new this.constructor().copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=1/0,this.max.x=this.max.y=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y}getCenter(e){return e===void 0&&(console.warn("THREE.Box2: .getCenter() target is now required"),e=new Je),this.isEmpty()?e.set(0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return e===void 0&&(console.warn("THREE.Box2: .getSize() target is now required"),e=new Je),this.isEmpty()?e.set(0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}containsPoint(e){return!(e.x<this.min.x||e.x>this.max.x||e.y<this.min.y||e.y>this.max.y)}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y}getParameter(e,t){return t===void 0&&(console.warn("THREE.Box2: .getParameter() target is now required"),t=new Je),t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y))}intersectsBox(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y)}clampPoint(e,t){return t===void 0&&(console.warn("THREE.Box2: .clampPoint() target is now required"),t=new Je),t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return xd.copy(e).clamp(this.min,this.max).sub(e).length()}intersect(e){return this.min.max(e.min),this.max.min(e.max),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}const wd=new z,Hs=new z;class _d{constructor(e,t){this.start=e!==void 0?e:new z,this.end=t!==void 0?t:new z}set(e,t){return this.start.copy(e),this.end.copy(t),this}clone(){return new this.constructor().copy(this)}copy(e){return this.start.copy(e.start),this.end.copy(e.end),this}getCenter(e){return e===void 0&&(console.warn("THREE.Line3: .getCenter() target is now required"),e=new z),e.addVectors(this.start,this.end).multiplyScalar(.5)}delta(e){return e===void 0&&(console.warn("THREE.Line3: .delta() target is now required"),e=new z),e.subVectors(this.end,this.start)}distanceSq(){return this.start.distanceToSquared(this.end)}distance(){return this.start.distanceTo(this.end)}at(e,t){return t===void 0&&(console.warn("THREE.Line3: .at() target is now required"),t=new z),this.delta(t).multiplyScalar(e).add(this.start)}closestPointToPointParameter(e,t){wd.subVectors(e,this.start),Hs.subVectors(this.end,this.start);const n=Hs.dot(Hs);let r=Hs.dot(wd)/n;return t&&(r=Ft.clamp(r,0,1)),r}closestPointToPoint(e,t,n){const r=this.closestPointToPointParameter(e,t);return n===void 0&&(console.warn("THREE.Line3: .closestPointToPoint() target is now required"),n=new z),this.delta(n).multiplyScalar(r).add(this.start)}applyMatrix4(e){return this.start.applyMatrix4(e),this.end.applyMatrix4(e),this}equals(e){return e.start.equals(this.start)&&e.end.equals(this.end)}}function wa(e){At.call(this),this.material=e,this.render=function(){},this.hasPositions=!1,this.hasNormals=!1,this.hasColors=!1,this.hasUvs=!1,this.positionArray=null,this.normalArray=null,this.colorArray=null,this.uvArray=null,this.count=0}wa.prototype=Object.create(At.prototype),wa.prototype.constructor=wa,wa.prototype.isImmediateRenderObject=!0;const Md=new z;class km extends At{constructor(e,t){super(),this.light=e,this.light.updateMatrixWorld(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=t;const n=new Ct,r=[0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(let o=0,a=1,s=32;o<s;o++,a++){const c=o/s*Math.PI*2,u=a/s*Math.PI*2;r.push(Math.cos(c),Math.sin(c),1,Math.cos(u),Math.sin(u),1)}n.setAttribute("position",new yt(r,3));const i=new mn({fog:!1,toneMapped:!1});this.cone=new Wn(n,i),this.add(this.cone),this.update()}dispose(){this.cone.geometry.dispose(),this.cone.material.dispose()}update(){this.light.updateMatrixWorld();const e=this.light.distance?this.light.distance:1e3,t=e*Math.tan(this.light.angle);this.cone.scale.set(t,t,e),Md.setFromMatrixPosition(this.light.target.matrixWorld),this.cone.lookAt(Md),this.color!==void 0?this.cone.material.color.set(this.color):this.cone.material.color.copy(this.light.color)}}const pi=new z,Gs=new Ht,Ul=new Ht;class Sd extends Wn{constructor(e){const t=function s(c){const u=[];c&&c.isBone&&u.push(c);for(let p=0;p<c.children.length;p++)u.push.apply(u,s(c.children[p]));return u}(e),n=new Ct,r=[],i=[],o=new _t(0,0,1),a=new _t(0,1,0);for(let s=0;s<t.length;s++){const c=t[s];c.parent&&c.parent.isBone&&(r.push(0,0,0),r.push(0,0,0),i.push(o.r,o.g,o.b),i.push(a.r,a.g,a.b))}n.setAttribute("position",new yt(r,3)),n.setAttribute("color",new yt(i,3)),super(n,new mn({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0})),this.type="SkeletonHelper",this.isSkeletonHelper=!0,this.root=e,this.bones=t,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1}updateMatrixWorld(e){const t=this.bones,n=this.geometry,r=n.getAttribute("position");Ul.copy(this.root.matrixWorld).invert();for(let i=0,o=0;i<t.length;i++){const a=t[i];a.parent&&a.parent.isBone&&(Gs.multiplyMatrices(Ul,a.matrixWorld),pi.setFromMatrixPosition(Gs),r.setXYZ(o,pi.x,pi.y,pi.z),Gs.multiplyMatrices(Ul,a.parent.matrixWorld),pi.setFromMatrixPosition(Gs),r.setXYZ(o+1,pi.x,pi.y,pi.z),o+=2)}n.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(e)}}class Hm extends pn{constructor(e,t,n){super(new xs(t,4,2),new sr({wireframe:!0,fog:!1,toneMapped:!1})),this.light=e,this.light.updateMatrixWorld(),this.color=n,this.type="PointLightHelper",this.matrix=this.light.matrixWorld,this.matrixAutoUpdate=!1,this.update()}dispose(){this.geometry.dispose(),this.material.dispose()}update(){this.color!==void 0?this.material.color.set(this.color):this.material.color.copy(this.light.color)}}const Gm=new z,Td=new _t,Ed=new _t;class Vm extends At{constructor(e,t,n){super(),this.light=e,this.light.updateMatrixWorld(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=n;const r=new ys(t);r.rotateY(.5*Math.PI),this.material=new sr({wireframe:!0,fog:!1,toneMapped:!1}),this.color===void 0&&(this.material.vertexColors=!0);const i=r.getAttribute("position"),o=new Float32Array(3*i.count);r.setAttribute("color",new Rt(o,3)),this.add(new pn(r,this.material)),this.update()}dispose(){this.children[0].geometry.dispose(),this.children[0].material.dispose()}update(){const e=this.children[0];if(this.color!==void 0)this.material.color.set(this.color);else{const t=e.geometry.getAttribute("color");Td.copy(this.light.color),Ed.copy(this.light.groundColor);for(let n=0,r=t.count;n<r;n++){const i=n<r/2?Td:Ed;t.setXYZ(n,i.r,i.g,i.b)}t.needsUpdate=!0}e.lookAt(Gm.setFromMatrixPosition(this.light.matrixWorld).negate())}}class Ad extends Wn{constructor(e=10,t=10,n=4473924,r=8947848){n=new _t(n),r=new _t(r);const i=t/2,o=e/t,a=e/2,s=[],c=[];for(let p=0,d=0,g=-a;p<=t;p++,g+=o){s.push(-a,0,g,a,0,g),s.push(g,0,-a,g,0,a);const m=p===i?n:r;m.toArray(c,d),d+=3,m.toArray(c,d),d+=3,m.toArray(c,d),d+=3,m.toArray(c,d),d+=3}const u=new Ct;u.setAttribute("position",new yt(s,3)),u.setAttribute("color",new yt(c,3)),super(u,new mn({vertexColors:!0,toneMapped:!1})),this.type="GridHelper"}}class jm extends Wn{constructor(e=10,t=16,n=8,r=64,i=4473924,o=8947848){i=new _t(i),o=new _t(o);const a=[],s=[];for(let u=0;u<=t;u++){const p=u/t*(2*Math.PI),d=Math.sin(p)*e,g=Math.cos(p)*e;a.push(0,0,0),a.push(d,0,g);const m=1&u?i:o;s.push(m.r,m.g,m.b),s.push(m.r,m.g,m.b)}for(let u=0;u<=n;u++){const p=1&u?i:o,d=e-e/n*u;for(let g=0;g<r;g++){let m=g/r*(2*Math.PI),x=Math.sin(m)*d,S=Math.cos(m)*d;a.push(x,0,S),s.push(p.r,p.g,p.b),m=(g+1)/r*(2*Math.PI),x=Math.sin(m)*d,S=Math.cos(m)*d,a.push(x,0,S),s.push(p.r,p.g,p.b)}}const c=new Ct;c.setAttribute("position",new yt(a,3)),c.setAttribute("color",new yt(s,3)),super(c,new mn({vertexColors:!0,toneMapped:!1})),this.type="PolarGridHelper"}}const Ld=new z,Vs=new z,Cd=new z;class Wm extends At{constructor(e,t,n){super(),this.light=e,this.light.updateMatrixWorld(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=n,t===void 0&&(t=1);let r=new Ct;r.setAttribute("position",new yt([-t,t,0,t,t,0,t,-t,0,-t,-t,0,-t,t,0],3));const i=new mn({fog:!1,toneMapped:!1});this.lightPlane=new lr(r,i),this.add(this.lightPlane),r=new Ct,r.setAttribute("position",new yt([0,0,0,0,0,1],3)),this.targetLine=new lr(r,i),this.add(this.targetLine),this.update()}dispose(){this.lightPlane.geometry.dispose(),this.lightPlane.material.dispose(),this.targetLine.geometry.dispose(),this.targetLine.material.dispose()}update(){Ld.setFromMatrixPosition(this.light.matrixWorld),Vs.setFromMatrixPosition(this.light.target.matrixWorld),Cd.subVectors(Vs,Ld),this.lightPlane.lookAt(Vs),this.color!==void 0?(this.lightPlane.material.color.set(this.color),this.targetLine.material.color.set(this.color)):(this.lightPlane.material.color.copy(this.light.color),this.targetLine.material.color.copy(this.light.color)),this.targetLine.lookAt(Vs),this.targetLine.scale.z=Cd.length()}}const js=new z,yn=new Lr;class Xm extends Wn{constructor(e){const t=new Ct,n=new mn({color:16777215,vertexColors:!0,toneMapped:!1}),r=[],i=[],o={},a=new _t(16755200),s=new _t(16711680),c=new _t(43775),u=new _t(16777215),p=new _t(3355443);function d(m,x,S){g(m,S),g(x,S)}function g(m,x){r.push(0,0,0),i.push(x.r,x.g,x.b),o[m]===void 0&&(o[m]=[]),o[m].push(r.length/3-1)}d("n1","n2",a),d("n2","n4",a),d("n4","n3",a),d("n3","n1",a),d("f1","f2",a),d("f2","f4",a),d("f4","f3",a),d("f3","f1",a),d("n1","f1",a),d("n2","f2",a),d("n3","f3",a),d("n4","f4",a),d("p","n1",s),d("p","n2",s),d("p","n3",s),d("p","n4",s),d("u1","u2",c),d("u2","u3",c),d("u3","u1",c),d("c","t",u),d("p","c",p),d("cn1","cn2",p),d("cn3","cn4",p),d("cf1","cf2",p),d("cf3","cf4",p),t.setAttribute("position",new yt(r,3)),t.setAttribute("color",new yt(i,3)),super(t,n),this.type="CameraHelper",this.camera=e,this.camera.updateProjectionMatrix&&this.camera.updateProjectionMatrix(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.pointMap=o,this.update()}update(){const e=this.geometry,t=this.pointMap;yn.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),bn("c",t,e,yn,0,0,-1),bn("t",t,e,yn,0,0,1),bn("n1",t,e,yn,-1,-1,-1),bn("n2",t,e,yn,1,-1,-1),bn("n3",t,e,yn,-1,1,-1),bn("n4",t,e,yn,1,1,-1),bn("f1",t,e,yn,-1,-1,1),bn("f2",t,e,yn,1,-1,1),bn("f3",t,e,yn,-1,1,1),bn("f4",t,e,yn,1,1,1),bn("u1",t,e,yn,.7,1.1,-1),bn("u2",t,e,yn,-.7,1.1,-1),bn("u3",t,e,yn,0,2,-1),bn("cf1",t,e,yn,-1,0,1),bn("cf2",t,e,yn,1,0,1),bn("cf3",t,e,yn,0,-1,1),bn("cf4",t,e,yn,0,1,1),bn("cn1",t,e,yn,-1,0,-1),bn("cn2",t,e,yn,1,0,-1),bn("cn3",t,e,yn,0,-1,-1),bn("cn4",t,e,yn,0,1,-1),e.getAttribute("position").needsUpdate=!0}}function bn(e,t,n,r,i,o,a){js.set(i,o,a).unproject(r);const s=t[e];if(s!==void 0){const c=n.getAttribute("position");for(let u=0,p=s.length;u<p;u++)c.setXYZ(s[u],js.x,js.y,js.z)}}const Ws=new Tr;class Pd extends Wn{constructor(e,t=16776960){const n=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),r=new Float32Array(24),i=new Ct;i.setIndex(new Rt(n,1)),i.setAttribute("position",new Rt(r,3)),super(i,new mn({color:t,toneMapped:!1})),this.object=e,this.type="BoxHelper",this.matrixAutoUpdate=!1,this.update()}update(e){if(e!==void 0&&console.warn("THREE.BoxHelper: .update() has no longer arguments."),this.object!==void 0&&Ws.setFromObject(this.object),Ws.isEmpty())return;const t=Ws.min,n=Ws.max,r=this.geometry.attributes.position,i=r.array;i[0]=n.x,i[1]=n.y,i[2]=n.z,i[3]=t.x,i[4]=n.y,i[5]=n.z,i[6]=t.x,i[7]=t.y,i[8]=n.z,i[9]=n.x,i[10]=t.y,i[11]=n.z,i[12]=n.x,i[13]=n.y,i[14]=t.z,i[15]=t.x,i[16]=n.y,i[17]=t.z,i[18]=t.x,i[19]=t.y,i[20]=t.z,i[21]=n.x,i[22]=t.y,i[23]=t.z,r.needsUpdate=!0,this.geometry.computeBoundingSphere()}setFromObject(e){return this.object=e,this.update(),this}copy(e){return Wn.prototype.copy.call(this,e),this.object=e.object,this}}class qm extends Wn{constructor(e,t=16776960){const n=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),r=new Ct;r.setIndex(new Rt(n,1)),r.setAttribute("position",new yt([1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1],3)),super(r,new mn({color:t,toneMapped:!1})),this.box=e,this.type="Box3Helper",this.geometry.computeBoundingSphere()}updateMatrixWorld(e){const t=this.box;t.isEmpty()||(t.getCenter(this.position),t.getSize(this.scale),this.scale.multiplyScalar(.5),super.updateMatrixWorld(e))}}class Ym extends lr{constructor(e,t=1,n=16776960){const r=n,i=new Ct;i.setAttribute("position",new yt([1,-1,1,-1,1,1,-1,-1,1,1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,1,0,0,1,0,0,0],3)),i.computeBoundingSphere(),super(i,new mn({color:r,toneMapped:!1})),this.type="PlaneHelper",this.plane=e,this.size=t;const o=new Ct;o.setAttribute("position",new yt([1,1,1,-1,1,1,-1,-1,1,1,1,1,-1,-1,1,1,-1,1],3)),o.computeBoundingSphere(),this.add(new pn(o,new sr({color:r,opacity:.2,transparent:!0,depthWrite:!1,toneMapped:!1})))}updateMatrixWorld(e){let t=-this.plane.constant;Math.abs(t)<1e-8&&(t=1e-8),this.scale.set(.5*this.size,.5*this.size,t),this.children[0].material.side=t<0?Z:T,this.lookAt(this.plane.normal),super.updateMatrixWorld(e)}}const Rd=new z;let Xs,zl;class Zm extends At{constructor(e,t,n,r,i,o){super(),this.type="ArrowHelper",e===void 0&&(e=new z(0,0,1)),t===void 0&&(t=new z(0,0,0)),n===void 0&&(n=1),r===void 0&&(r=16776960),i===void 0&&(i=.2*n),o===void 0&&(o=.2*i),Xs===void 0&&(Xs=new Ct,Xs.setAttribute("position",new yt([0,0,0,0,1,0],3)),zl=new ua(0,.5,1,5,1),zl.translate(0,-.5,0)),this.position.copy(t),this.line=new lr(Xs,new mn({color:r,toneMapped:!1})),this.line.matrixAutoUpdate=!1,this.add(this.line),this.cone=new pn(zl,new sr({color:r,toneMapped:!1})),this.cone.matrixAutoUpdate=!1,this.add(this.cone),this.setDirection(e),this.setLength(n,i,o)}setDirection(e){if(e.y>.99999)this.quaternion.set(0,0,0,1);else if(e.y<-.99999)this.quaternion.set(1,0,0,0);else{Rd.set(e.z,0,-e.x).normalize();const t=Math.acos(e.y);this.quaternion.setFromAxisAngle(Rd,t)}}setLength(e,t,n){t===void 0&&(t=.2*e),n===void 0&&(n=.2*t),this.line.scale.set(1,Math.max(1e-4,e-t),1),this.line.updateMatrix(),this.cone.scale.set(n,t,n),this.cone.position.y=e,this.cone.updateMatrix()}setColor(e){this.line.material.color.set(e),this.cone.material.color.set(e)}copy(e){return super.copy(e,!1),this.line.copy(e.line),this.cone.copy(e.cone),this}}class Od extends Wn{constructor(e=1){const t=[0,0,0,e,0,0,0,0,0,0,e,0,0,0,0,0,0,e],n=new Ct;n.setAttribute("position",new yt(t,3)),n.setAttribute("color",new yt([1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1],3)),super(n,new mn({vertexColors:!0,toneMapped:!1})),this.type="AxesHelper"}}const Dd=new Float32Array(1),Jm=new Int32Array(Dd.buffer),Km={toHalfFloat:function(e){Dd[0]=e;const t=Jm[0];let n=t>>16&32768,r=t>>12&2047;const i=t>>23&255;return i<103?n:i>142?(n|=31744,n|=(i==255?0:1)&&8388607&t,n):i<113?(r|=2048,n|=(r>>114-i)+(r>>113-i&1),n):(n|=i-112<<10|r>>1,n+=1&r,n)}},Ir=Math.pow(2,8),Id=[.125,.215,.35,.446,.526,.582],Nd=5+Id.length,Nr={[Gn]:0,[Po]:1,[Da]:2,[cc]:3,[lc]:4,[uc]:5,[Oa]:6},kl=new Mo,{_lodPlanes:_a,_sizeLods:Bd,_sigmas:qs}=eg();let Hl=null;const Hi=(1+Math.sqrt(5))/2,So=1/Hi,Fd=[new z(1,1,1),new z(-1,1,1),new z(1,1,-1),new z(-1,1,-1),new z(0,Hi,So),new z(0,Hi,-So),new z(So,0,Hi),new z(-So,0,Hi),new z(Hi,So,0),new z(-Hi,So,0)];class Qm{constructor(e){this._renderer=e,this._pingPongRenderTarget=null,this._blurMaterial=function(t){const n=new Float32Array(t),r=new z(0,1,0);return new Wr({name:"SphericalGaussianBlur",defines:{n:t},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:n},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:r},inputEncoding:{value:Nr[Gn]},outputEncoding:{value:Nr[Gn]}},vertexShader:Gl(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			${Vl()}

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,blending:X,depthTest:!1,depthWrite:!1})}(20),this._equirectShader=null,this._cubemapShader=null,this._compileMaterial(this._blurMaterial)}fromScene(e,t=0,n=.1,r=100){Hl=this._renderer.getRenderTarget();const i=this._allocateTargets();return this._sceneToCubeUV(e,n,r,i),t>0&&this._blur(i,0,0,t),this._applyPMREM(i),this._cleanup(i),i}fromEquirectangular(e){return this._fromTexture(e)}fromCubemap(e){return this._fromTexture(e)}compileCubemapShader(){this._cubemapShader===null&&(this._cubemapShader=kd(),this._compileMaterial(this._cubemapShader))}compileEquirectangularShader(){this._equirectShader===null&&(this._equirectShader=zd(),this._compileMaterial(this._equirectShader))}dispose(){this._blurMaterial.dispose(),this._cubemapShader!==null&&this._cubemapShader.dispose(),this._equirectShader!==null&&this._equirectShader.dispose();for(let e=0;e<_a.length;e++)_a[e].dispose()}_cleanup(e){this._pingPongRenderTarget.dispose(),this._renderer.setRenderTarget(Hl),e.scissorTest=!1,Ys(e,0,0,e.width,e.height)}_fromTexture(e){Hl=this._renderer.getRenderTarget();const t=this._allocateTargets(e);return this._textureToCubeUV(e,t),this._applyPMREM(t),this._cleanup(t),t}_allocateTargets(e){const t={magFilter:y,minFilter:y,generateMipmaps:!1,type:bt,format:Ca,encoding:$m(e)?e.encoding:Da,depthBuffer:!1},n=Ud(t);return n.depthBuffer=!e,this._pingPongRenderTarget=Ud(t),n}_compileMaterial(e){const t=new pn(_a[0],e);this._renderer.compile(t,kl)}_sceneToCubeUV(e,t,n,r){const i=new _n(90,1,t,n),o=[1,-1,1,1,1,1],a=[1,1,1,-1,-1,-1],s=this._renderer,c=s.outputEncoding,u=s.toneMapping,p=s.getClearColor(),d=s.getClearAlpha();s.toneMapping=C,s.outputEncoding=Gn;let g=e.background;if(g&&g.isColor){g.convertSRGBToLinear();const m=Math.max(g.r,g.g,g.b),x=Math.min(Math.max(Math.ceil(Math.log2(m)),-128),127);g=g.multiplyScalar(Math.pow(2,-x));const S=(x+128)/255;s.setClearColor(g,S),e.background=null}for(let m=0;m<6;m++){const x=m%3;x==0?(i.up.set(0,o[m],0),i.lookAt(a[m],0,0)):x==1?(i.up.set(0,0,o[m]),i.lookAt(0,a[m],0)):(i.up.set(0,o[m],0),i.lookAt(0,0,a[m])),Ys(r,x*Ir,m>2?Ir:0,Ir,Ir),s.setRenderTarget(r),s.render(e,i)}s.toneMapping=u,s.outputEncoding=c,s.setClearColor(p,d)}_textureToCubeUV(e,t){const n=this._renderer;e.isCubeTexture?this._cubemapShader==null&&(this._cubemapShader=kd()):this._equirectShader==null&&(this._equirectShader=zd());const r=e.isCubeTexture?this._cubemapShader:this._equirectShader,i=new pn(_a[0],r),o=r.uniforms;o.envMap.value=e,e.isCubeTexture||o.texelSize.value.set(1/e.image.width,1/e.image.height),o.inputEncoding.value=Nr[e.encoding],o.outputEncoding.value=Nr[t.texture.encoding],Ys(t,0,0,3*Ir,2*Ir),n.setRenderTarget(t),n.render(i,kl)}_applyPMREM(e){const t=this._renderer,n=t.autoClear;t.autoClear=!1;for(let r=1;r<Nd;r++){const i=Math.sqrt(qs[r]*qs[r]-qs[r-1]*qs[r-1]),o=Fd[(r-1)%Fd.length];this._blur(e,r-1,r,i,o)}t.autoClear=n}_blur(e,t,n,r,i){const o=this._pingPongRenderTarget;this._halfBlur(e,o,t,n,r,"latitudinal",i),this._halfBlur(o,e,n,n,r,"longitudinal",i)}_halfBlur(e,t,n,r,i,o,a){const s=this._renderer,c=this._blurMaterial;o!=="latitudinal"&&o!=="longitudinal"&&console.error("blur direction must be either latitudinal or longitudinal!");const u=new pn(_a[r],c),p=c.uniforms,d=Bd[n]-1,g=isFinite(i)?Math.PI/(2*d):2*Math.PI/39,m=i/g,x=isFinite(i)?1+Math.floor(3*m):20;x>20&&console.warn(`sigmaRadians, ${i}, is too large and will clip, as it requested ${x} samples when the maximum is set to 20`);const S=[];let b=0;for(let F=0;F<20;++F){const ee=F/m,k=Math.exp(-ee*ee/2);S.push(k),F==0?b+=k:F<x&&(b+=2*k)}for(let F=0;F<S.length;F++)S[F]=S[F]/b;p.envMap.value=e.texture,p.samples.value=x,p.weights.value=S,p.latitudinal.value=o==="latitudinal",a&&(p.poleAxis.value=a),p.dTheta.value=g,p.mipInt.value=8-n,p.inputEncoding.value=Nr[e.texture.encoding],p.outputEncoding.value=Nr[e.texture.encoding];const R=Bd[r];Ys(t,3*Math.max(0,Ir-2*R),(r===0?0:2*Ir)+2*R*(r>4?r-8+4:0),3*R,2*R),s.setRenderTarget(t),s.render(u,kl)}}function $m(e){return e!==void 0&&e.type===bt&&(e.encoding===Gn||e.encoding===Po||e.encoding===Oa)}function eg(){const e=[],t=[],n=[];let r=8;for(let i=0;i<Nd;i++){const o=Math.pow(2,r);t.push(o);let a=1/o;i>4?a=Id[i-8+4-1]:i==0&&(a=0),n.push(a);const s=1/(o-1),c=-s/2,u=1+s/2,p=[c,c,u,c,u,u,c,c,u,u,c,u],d=6,g=6,m=3,x=2,S=1,b=new Float32Array(m*g*d),R=new Float32Array(x*g*d),F=new Float32Array(S*g*d);for(let k=0;k<d;k++){const K=k%3*2/3-1,le=k>2?0:-1,ge=[K,le,0,K+2/3,le,0,K+2/3,le+1,0,K,le,0,K+2/3,le+1,0,K,le+1,0];b.set(ge,m*g*k),R.set(p,x*g*k);const Le=[k,k,k,k,k,k];F.set(Le,S*g*k)}const ee=new Ct;ee.setAttribute("position",new Rt(b,m)),ee.setAttribute("uv",new Rt(R,x)),ee.setAttribute("faceIndex",new Rt(F,S)),e.push(ee),r>4&&r--}return{_lodPlanes:e,_sizeLods:t,_sigmas:n}}function Ud(e){const t=new Kn(3*Ir,3*Ir,e);return t.texture.mapping=pe,t.texture.name="PMREM.cubeUv",t.scissorTest=!0,t}function Ys(e,t,n,r,i){e.viewport.set(t,n,r,i),e.scissor.set(t,n,r,i)}function zd(){return new Wr({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null},texelSize:{value:new Je(1,1)},inputEncoding:{value:Nr[Gn]},outputEncoding:{value:Nr[Gn]}},vertexShader:Gl(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform vec2 texelSize;

			${Vl()}

			#include <common>

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				vec2 f = fract( uv / texelSize - 0.5 );
				uv -= f * texelSize;
				vec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x += texelSize.x;
				vec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.y += texelSize.y;
				vec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x -= texelSize.x;
				vec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;

				vec3 tm = mix( tl, tr, f.x );
				vec3 bm = mix( bl, br, f.x );
				gl_FragColor.rgb = mix( tm, bm, f.y );

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,blending:X,depthTest:!1,depthWrite:!1})}function kd(){return new Wr({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},inputEncoding:{value:Nr[Gn]},outputEncoding:{value:Nr[Gn]}},vertexShader:Gl(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			${Vl()}

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;
				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,blending:X,depthTest:!1,depthWrite:!1})}function Gl(){return`

		precision mediump float;
		precision mediump int;

		attribute vec3 position;
		attribute vec2 uv;
		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`}function Vl(){return`

		uniform int inputEncoding;
		uniform int outputEncoding;

		#include <encodings_pars_fragment>

		vec4 inputTexelToLinear( vec4 value ) {

			if ( inputEncoding == 0 ) {

				return value;

			} else if ( inputEncoding == 1 ) {

				return sRGBToLinear( value );

			} else if ( inputEncoding == 2 ) {

				return RGBEToLinear( value );

			} else if ( inputEncoding == 3 ) {

				return RGBMToLinear( value, 7.0 );

			} else if ( inputEncoding == 4 ) {

				return RGBMToLinear( value, 16.0 );

			} else if ( inputEncoding == 5 ) {

				return RGBDToLinear( value, 256.0 );

			} else {

				return GammaToLinear( value, 2.2 );

			}

		}

		vec4 linearToOutputTexel( vec4 value ) {

			if ( outputEncoding == 0 ) {

				return value;

			} else if ( outputEncoding == 1 ) {

				return LinearTosRGB( value );

			} else if ( outputEncoding == 2 ) {

				return LinearToRGBE( value );

			} else if ( outputEncoding == 3 ) {

				return LinearToRGBM( value, 7.0 );

			} else if ( outputEncoding == 4 ) {

				return LinearToRGBM( value, 16.0 );

			} else if ( outputEncoding == 5 ) {

				return LinearToRGBD( value, 256.0 );

			} else {

				return LinearToGamma( value, 2.2 );

			}

		}

		vec4 envMapTexelToLinear( vec4 color ) {

			return inputTexelToLinear( color );

		}
	`}function tg(e,t,n,r,i,o,a){return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."),new Bo(e,t,n,i,o,a)}const ng=0,rg=1,ig=0,og=1,ag=2;function sg(e){return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."),e}function cg(e=[]){return console.warn("THREE.MultiMaterial has been removed. Use an Array instead."),e.isMultiMaterial=!0,e.materials=e,e.clone=function(){return e.slice()},e}function lg(e,t){return console.warn("THREE.PointCloud has been renamed to THREE.Points."),new mo(e,t)}function ug(e){return console.warn("THREE.Particle has been renamed to THREE.Sprite."),new na(e)}function hg(e,t){return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."),new mo(e,t)}function dg(e){return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."),new vr(e)}function pg(e){return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."),new vr(e)}function fg(e){return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."),new vr(e)}function mg(e,t,n){return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."),new z(e,t,n)}function gg(e,t){return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead."),new Rt(e,t).setUsage(bi)}function vg(e,t){return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."),new Fo(e,t)}function yg(e,t){return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."),new Uo(e,t)}function xg(e,t){return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."),new zo(e,t)}function bg(e,t){return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."),new ko(e,t)}function wg(e,t){return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."),new Si(e,t)}function _g(e,t){return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."),new Ho(e,t)}function Mg(e,t){return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."),new Ti(e,t)}function Sg(e,t){return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."),new yt(e,t)}function Tg(e,t){return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."),new Vo(e,t)}function Hd(e){console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."),Un.call(this,e),this.type="catmullrom",this.closed=!0}function Gd(e){console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."),Un.call(this,e),this.type="catmullrom"}function jl(e){console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."),Un.call(this,e),this.type="catmullrom"}function Eg(e){return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."),new Od(e)}function Ag(e,t){return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."),new Pd(e,t)}function Lg(e,t){return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."),new Wn(new Jc(e.geometry),new mn({color:t!==void 0?t:16777215}))}function Cg(e,t){return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."),new Wn(new ul(e.geometry),new mn({color:t!==void 0?t:16777215}))}function Pg(e){return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."),new ur(e)}function Rg(e){return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."),new As(e)}function Og(e,t,n){return console.warn("THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options )."),new Gr(e,n)}Lt.create=function(e,t){return console.log("THREE.Curve.create() has been deprecated"),e.prototype=Object.create(Lt.prototype),e.prototype.constructor=e,e.prototype.getPoint=t,e},Object.assign(Xr.prototype,{createPointsGeometry:function(e){console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");const t=this.getPoints(e);return this.createGeometry(t)},createSpacedPointsGeometry:function(e){console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");const t=this.getSpacedPoints(e);return this.createGeometry(t)},createGeometry:function(e){console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");const t=new rn;for(let n=0,r=e.length;n<r;n++){const i=e[n];t.vertices.push(new z(i.x,i.y,i.z||0))}return t}}),Object.assign(Mr.prototype,{fromPoints:function(e){return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."),this.setFromPoints(e)}}),Hd.prototype=Object.create(Un.prototype),Gd.prototype=Object.create(Un.prototype),jl.prototype=Object.create(Un.prototype),Object.assign(jl.prototype,{initFromArray:function(){console.error("THREE.Spline: .initFromArray() has been removed.")},getControlPointsArray:function(){console.error("THREE.Spline: .getControlPointsArray() has been removed.")},reparametrizeByArcLength:function(){console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.")}}),Ad.prototype.setColors=function(){console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")},Sd.prototype.update=function(){console.error("THREE.SkeletonHelper: update() no longer needs to be called.")},Object.assign(en.prototype,{extractUrlBase:function(e){return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."),_l.extractUrlBase(e)}}),en.Handlers={add:function(){console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")},get:function(){console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")}},Object.assign(bd.prototype,{center:function(e){return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."),this.getCenter(e)},empty:function(){return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."),this.isEmpty()},isIntersectionBox:function(e){return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(e)},size:function(e){return console.warn("THREE.Box2: .size() has been renamed to .getSize()."),this.getSize(e)}}),Object.assign(Tr.prototype,{center:function(e){return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."),this.getCenter(e)},empty:function(){return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),this.isEmpty()},isIntersectionBox:function(e){return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(e)},isIntersectionSphere:function(e){return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(e)},size:function(e){return console.warn("THREE.Box3: .size() has been renamed to .getSize()."),this.getSize(e)}}),Object.assign(Fr.prototype,{empty:function(){return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."),this.isEmpty()}}),Yo.prototype.setFromMatrix=function(e){return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."),this.setFromProjectionMatrix(e)},_d.prototype.center=function(e){return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."),this.getCenter(e)},Object.assign(Ft,{random16:function(){return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."),Math.random()},nearestPowerOfTwo:function(e){return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."),Ft.floorPowerOfTwo(e)},nextPowerOfTwo:function(e){return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."),Ft.ceilPowerOfTwo(e)}}),Object.assign(Vn.prototype,{flattenToArrayOffset:function(e,t){return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(e,t)},multiplyVector3:function(e){return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."),e.applyMatrix3(this)},multiplyVector3Array:function(){console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")},applyToBufferAttribute:function(e){return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."),e.applyMatrix3(this)},applyToVector3Array:function(){console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")},getInverse:function(e){return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(e).invert()}}),Object.assign(Ht.prototype,{extractPosition:function(e){return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."),this.copyPosition(e)},flattenToArrayOffset:function(e,t){return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(e,t)},getPosition:function(){return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."),new z().setFromMatrixColumn(this,3)},setRotationFromQuaternion:function(e){return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."),this.makeRotationFromQuaternion(e)},multiplyToArray:function(){console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")},multiplyVector3:function(e){return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."),e.applyMatrix4(this)},multiplyVector4:function(e){return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."),e.applyMatrix4(this)},multiplyVector3Array:function(){console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")},rotateAxis:function(e){console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."),e.transformDirection(this)},crossVector:function(e){return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."),e.applyMatrix4(this)},translate:function(){console.error("THREE.Matrix4: .translate() has been removed.")},rotateX:function(){console.error("THREE.Matrix4: .rotateX() has been removed.")},rotateY:function(){console.error("THREE.Matrix4: .rotateY() has been removed.")},rotateZ:function(){console.error("THREE.Matrix4: .rotateZ() has been removed.")},rotateByAxis:function(){console.error("THREE.Matrix4: .rotateByAxis() has been removed.")},applyToBufferAttribute:function(e){return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."),e.applyMatrix4(this)},applyToVector3Array:function(){console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")},makeFrustum:function(e,t,n,r,i,o){return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."),this.makePerspective(e,t,r,n,i,o)},getInverse:function(e){return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(e).invert()}}),Er.prototype.isIntersectionLine=function(e){return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."),this.intersectsLine(e)},Object.assign(Nn.prototype,{multiplyVector3:function(e){return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."),e.applyQuaternion(this)},inverse:function(){return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."),this.invert()}}),Object.assign(Ji.prototype,{isIntersectionBox:function(e){return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(e)},isIntersectionPlane:function(e){return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."),this.intersectsPlane(e)},isIntersectionSphere:function(e){return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(e)}}),Object.assign(Bn.prototype,{area:function(){return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."),this.getArea()},barycoordFromPoint:function(e,t){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),this.getBarycoord(e,t)},midpoint:function(e){return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."),this.getMidpoint(e)},normal:function(e){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),this.getNormal(e)},plane:function(e){return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."),this.getPlane(e)}}),Object.assign(Bn,{barycoordFromPoint:function(e,t,n,r,i){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),Bn.getBarycoord(e,t,n,r,i)},normal:function(e,t,n,r){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),Bn.getNormal(e,t,n,r)}}),Object.assign(di.prototype,{extractAllPoints:function(e){return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."),this.extractPoints(e)},extrude:function(e){return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."),new $c(this,e)},makeGeometry:function(e){return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."),new il(this,e)}}),Object.assign(Je.prototype,{fromAttribute:function(e,t,n){return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(e,t,n)},distanceToManhattan:function(e){return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(e)},lengthManhattan:function(){return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()}}),Object.assign(z.prototype,{setEulerFromRotationMatrix:function(){console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")},setEulerFromQuaternion:function(){console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")},getPositionFromMatrix:function(e){return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."),this.setFromMatrixPosition(e)},getScaleFromMatrix:function(e){return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."),this.setFromMatrixScale(e)},getColumnFromMatrix:function(e,t){return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."),this.setFromMatrixColumn(t,e)},applyProjection:function(e){return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."),this.applyMatrix4(e)},fromAttribute:function(e,t,n){return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(e,t,n)},distanceToManhattan:function(e){return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(e)},lengthManhattan:function(){return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()}}),Object.assign(nn.prototype,{fromAttribute:function(e,t,n){return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(e,t,n)},lengthManhattan:function(){return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()}}),Object.assign(rn.prototype,{computeTangents:function(){console.error("THREE.Geometry: .computeTangents() has been removed.")},computeLineDistances:function(){console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.")},applyMatrix:function(e){return console.warn("THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(e)}}),Object.assign(At.prototype,{getChildByName:function(e){return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."),this.getObjectByName(e)},renderDepth:function(){console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")},translate:function(e,t){return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."),this.translateOnAxis(t,e)},getWorldRotation:function(){console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")},applyMatrix:function(e){return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(e)}}),Object.defineProperties(At.prototype,{eulerOrder:{get:function(){return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order},set:function(e){console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order=e}},useQuaternion:{get:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")},set:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")}}}),Object.assign(pn.prototype,{setDrawMode:function(){console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")}}),Object.defineProperties(pn.prototype,{drawMode:{get:function(){return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."),Du},set:function(){console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")}}}),Object.defineProperties(ra.prototype,{objects:{get:function(){return console.warn("THREE.LOD: .objects has been renamed to .levels."),this.levels}}}),Object.defineProperty(aa.prototype,"useVertexTexture",{get:function(){console.warn("THREE.Skeleton: useVertexTexture has been removed.")},set:function(){console.warn("THREE.Skeleton: useVertexTexture has been removed.")}}),ia.prototype.initBones=function(){console.error("THREE.SkinnedMesh: initBones() has been removed.")},Object.defineProperty(Lt.prototype,"__arcLengthDivisions",{get:function(){return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."),this.arcLengthDivisions},set:function(e){console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."),this.arcLengthDivisions=e}}),_n.prototype.setLens=function(e,t){console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."),t!==void 0&&(this.filmGauge=t),this.setFocalLength(e)},Object.defineProperties(ln.prototype,{onlyShadow:{set:function(){console.warn("THREE.Light: .onlyShadow has been removed.")}},shadowCameraFov:{set:function(e){console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),this.shadow.camera.fov=e}},shadowCameraLeft:{set:function(e){console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."),this.shadow.camera.left=e}},shadowCameraRight:{set:function(e){console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."),this.shadow.camera.right=e}},shadowCameraTop:{set:function(e){console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),this.shadow.camera.top=e}},shadowCameraBottom:{set:function(e){console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."),this.shadow.camera.bottom=e}},shadowCameraNear:{set:function(e){console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."),this.shadow.camera.near=e}},shadowCameraFar:{set:function(e){console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),this.shadow.camera.far=e}},shadowCameraVisible:{set:function(){console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")}},shadowBias:{set:function(e){console.warn("THREE.Light: .shadowBias is now .shadow.bias."),this.shadow.bias=e}},shadowDarkness:{set:function(){console.warn("THREE.Light: .shadowDarkness has been removed.")}},shadowMapWidth:{set:function(e){console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."),this.shadow.mapSize.width=e}},shadowMapHeight:{set:function(e){console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."),this.shadow.mapSize.height=e}}}),Object.defineProperties(Rt.prototype,{length:{get:function(){return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."),this.array.length}},dynamic:{get:function(){return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.usage===bi},set:function(){console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.setUsage(bi)}}}),Object.assign(Rt.prototype,{setDynamic:function(e){return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(e===!0?bi:Ro),this},copyIndicesArray:function(){console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")},setArray:function(){console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")}}),Object.assign(Ct.prototype,{addIndex:function(e){console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."),this.setIndex(e)},addAttribute:function(e,t){return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."),t&&t.isBufferAttribute||t&&t.isInterleavedBufferAttribute?e==="index"?(console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),this.setIndex(t),this):this.setAttribute(e,t):(console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),this.setAttribute(e,new Rt(arguments[1],arguments[2])))},addDrawCall:function(e,t,n){n!==void 0&&console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."),console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),this.addGroup(e,t)},clearDrawCalls:function(){console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."),this.clearGroups()},computeTangents:function(){console.warn("THREE.BufferGeometry: .computeTangents() has been removed.")},computeOffsets:function(){console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")},removeAttribute:function(e){return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."),this.deleteAttribute(e)},applyMatrix:function(e){return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(e)}}),Object.defineProperties(Ct.prototype,{drawcalls:{get:function(){return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."),this.groups}},offsets:{get:function(){return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."),this.groups}}}),Object.defineProperties(ba.prototype,{maxInstancedCount:{get:function(){return console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."),this.instanceCount},set:function(e){console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."),this.instanceCount=e}}}),Object.defineProperties(Bl.prototype,{linePrecision:{get:function(){return console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."),this.params.Line.threshold},set:function(e){console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."),this.params.Line.threshold=e}}}),Object.defineProperties(tr.prototype,{dynamic:{get:function(){return console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."),this.usage===bi},set:function(e){console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."),this.setUsage(e)}}}),Object.assign(tr.prototype,{setDynamic:function(e){return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(e===!0?bi:Ro),this},setArray:function(){console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")}}),Object.assign(fa.prototype,{getArrays:function(){console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.")},addShapeList:function(){console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.")},addShape:function(){console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.")}}),Object.assign(zc.prototype,{dispose:function(){console.error("THREE.Scene: .dispose() has been removed.")}}),Object.defineProperties(Dl.prototype,{dynamic:{set:function(){console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.")}},onUpdate:{value:function(){return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."),this}}}),Object.defineProperties(Nt.prototype,{wrapAround:{get:function(){console.warn("THREE.Material: .wrapAround has been removed.")},set:function(){console.warn("THREE.Material: .wrapAround has been removed.")}},overdraw:{get:function(){console.warn("THREE.Material: .overdraw has been removed.")},set:function(){console.warn("THREE.Material: .overdraw has been removed.")}},wrapRGB:{get:function(){return console.warn("THREE.Material: .wrapRGB has been removed."),new _t}},shading:{get:function(){console.error("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead.")},set:function(e){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=e===L}},stencilMask:{get:function(){return console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask},set:function(e){console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask=e}}}),Object.defineProperties(hi.prototype,{metal:{get:function(){return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."),!1},set:function(){console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")}}}),Object.defineProperties(ui.prototype,{transparency:{get:function(){return console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."),this.transmission},set:function(e){console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."),this.transmission=e}}}),Object.defineProperties(jn.prototype,{derivatives:{get:function(){return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives},set:function(e){console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives=e}}}),Object.assign(Qo.prototype,{clearTarget:function(e,t,n,r){console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."),this.setRenderTarget(e),this.clear(t,n,r)},animate:function(e){console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."),this.setAnimationLoop(e)},getCurrentRenderTarget:function(){return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."),this.getRenderTarget()},getMaxAnisotropy:function(){return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."),this.capabilities.getMaxAnisotropy()},getPrecision:function(){return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."),this.capabilities.precision},resetGLState:function(){return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."),this.state.reset()},supportsFloatTextures:function(){return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."),this.extensions.get("OES_texture_float")},supportsHalfFloatTextures:function(){return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."),this.extensions.get("OES_texture_half_float")},supportsStandardDerivatives:function(){return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."),this.extensions.get("OES_standard_derivatives")},supportsCompressedTextureS3TC:function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."),this.extensions.get("WEBGL_compressed_texture_s3tc")},supportsCompressedTexturePVRTC:function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."),this.extensions.get("WEBGL_compressed_texture_pvrtc")},supportsBlendMinMax:function(){return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."),this.extensions.get("EXT_blend_minmax")},supportsVertexTextures:function(){return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."),this.capabilities.vertexTextures},supportsInstancedArrays:function(){return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."),this.extensions.get("ANGLE_instanced_arrays")},enableScissorTest:function(e){console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."),this.setScissorTest(e)},initMaterial:function(){console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")},addPrePlugin:function(){console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")},addPostPlugin:function(){console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")},updateShadowMap:function(){console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")},setFaceCulling:function(){console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")},allocTextureUnit:function(){console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")},setTexture:function(){console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")},setTexture2D:function(){console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")},setTextureCube:function(){console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")},getActiveMipMapLevel:function(){return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."),this.getActiveMipmapLevel()}}),Object.defineProperties(Qo.prototype,{shadowMapEnabled:{get:function(){return this.shadowMap.enabled},set:function(e){console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."),this.shadowMap.enabled=e}},shadowMapType:{get:function(){return this.shadowMap.type},set:function(e){console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."),this.shadowMap.type=e}},shadowMapCullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")}},context:{get:function(){return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."),this.getContext()}},vr:{get:function(){return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),this.xr}},gammaInput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."),!1},set:function(){console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")}},gammaOutput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),!1},set:function(e){console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),this.outputEncoding=e===!0?Po:Gn}},toneMappingWhitePoint:{get:function(){return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."),1},set:function(){console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")}}}),Object.defineProperties(wh.prototype,{cullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")}},renderReverseSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")}},renderSingleSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")}}}),Object.defineProperties(Kn.prototype,{wrapS:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS},set:function(e){console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS=e}},wrapT:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT},set:function(e){console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT=e}},magFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter},set:function(e){console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter=e}},minFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter},set:function(e){console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter=e}},anisotropy:{get:function(){return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy},set:function(e){console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy=e}},offset:{get:function(){return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset},set:function(e){console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset=e}},repeat:{get:function(){return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat},set:function(e){console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat=e}},format:{get:function(){return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format},set:function(e){console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format=e}},type:{get:function(){return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type},set:function(e){console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type=e}},generateMipmaps:{get:function(){return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps},set:function(e){console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps=e}}}),Object.defineProperties(Pl.prototype,{load:{value:function(e){console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");const t=this;return new ks().load(e,function(n){t.setBuffer(n)}),this}},startTime:{set:function(){console.warn("THREE.Audio: .startTime is now .play( delay ).")}}}),md.prototype.getData=function(){return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."),this.getFrequencyData()},Ai.prototype.updateCubeMap=function(e,t){return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),this.update(e,t)},Ai.prototype.clear=function(e,t,n,r){return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."),this.renderTarget.clear(e,t,n,r)};const Dg={merge:function(e,t,n){let r;console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead."),t.isMesh&&(t.matrixAutoUpdate&&t.updateMatrix(),r=t.matrix,t=t.geometry),e.merge(t,r,n)},center:function(e){return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."),e.center()}};function Ig(){console.error("THREE.CanvasRenderer has been removed")}function Ng(){console.error("THREE.JSONLoader has been removed.")}wi.crossOrigin=void 0,wi.loadTexture=function(e,t,n,r){console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");const i=new Ls;i.setCrossOrigin(this.crossOrigin);const o=i.load(e,n,void 0,r);return t&&(o.mapping=t),o},wi.loadTextureCube=function(e,t,n,r){console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");const i=new Es;i.setCrossOrigin(this.crossOrigin);const o=i.load(e,n,void 0,r);return t&&(o.mapping=t),o},wi.loadCompressedTexture=function(){console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")},wi.loadCompressedTextureCube=function(){console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")};const Bg={createMultiMaterialObject:function(){console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")},detach:function(){console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")},attach:function(){console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")}};function Fg(){console.error("THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js")}typeof __THREE_DEVTOOLS__!="undefined"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:f}}))},function(rt,h,l){l.d(h,"a",function(){return E});var f,A,P,I=l(0);function E(){this.enabled=!0,this.needsSwap=!0,this.clear=!1,this.renderToScreen=!1}Object.assign(E.prototype,{setSize:function(){},render:function(){console.error("THREE.Pass: .render() must be implemented in derived pass.")}}),E.FullScreenQuad=(f=new I.OrthographicCamera(-1,1,1,-1,0,1),A=new I.PlaneBufferGeometry(2,2),P=function(U){this._mesh=new I.Mesh(A,U)},Object.defineProperty(P.prototype,"material",{get:function(){return this._mesh.material},set:function(U){this._mesh.material=U}}),Object.assign(P.prototype,{dispose:function(){this._mesh.geometry.dispose()},render:function(U){U.render(this._mesh,f)}}),P)},function(rt,h,l){l.r(h),l.d(h,"ShaderPass",function(){return P});var f=l(0),A=l(1),P=function(I,E){A.a.call(this),this.textureID=E!==void 0?E:"tDiffuse",I instanceof f.ShaderMaterial?(this.uniforms=I.uniforms,this.material=I):I&&(this.uniforms=f.UniformsUtils.clone(I.uniforms),this.material=new f.ShaderMaterial({defines:Object.assign({},I.defines),uniforms:this.uniforms,vertexShader:I.vertexShader,fragmentShader:I.fragmentShader})),this.fsQuad=new A.a.FullScreenQuad(this.material)};P.prototype=Object.assign(Object.create(A.a.prototype),{constructor:P,render:function(I,E,U){this.uniforms[this.textureID]&&(this.uniforms[this.textureID].value=U.texture),this.fsQuad.material=this.material,this.renderToScreen?(I.setRenderTarget(null),this.fsQuad.render(I)):(I.setRenderTarget(E),this.clear&&I.clear(I.autoClearColor,I.autoClearDepth,I.autoClearStencil),this.fsQuad.render(I))}})},function(rt,h,l){l.r(h),l.d(h,"GLTFLoader",function(){return A});var f=l(0),A=function(){function P(O){f.Loader.call(this,O),this.dracoLoader=null,this.ddsLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register(function(C){return new we(C)}),this.register(function(C){return new Me(C)}),this.register(function(C){return new T(C)}),this.register(function(C){return new Se(C)}),this.register(function(C){return new G(C)}),this.register(function(C){return new Z(C)})}function I(){var O={};return{get:function(C){return O[C]},add:function(C,V){O[C]=V},remove:function(C){delete O[C]},removeAll:function(){O={}}}}P.prototype=Object.assign(Object.create(f.Loader.prototype),{constructor:P,load:function(O,C,V,j){var H,B=this;H=this.resourcePath!==""?this.resourcePath:this.path!==""?this.path:f.LoaderUtils.extractUrlBase(O),this.manager.itemStart(O);var w=function(ye){j?j(ye):console.error(ye),B.manager.itemError(O),B.manager.itemEnd(O)},$=new f.FileLoader(this.manager);$.setPath(this.path),$.setResponseType("arraybuffer"),$.setRequestHeader(this.requestHeader),$.setWithCredentials(this.withCredentials),$.load(O,function(ye){try{B.parse(ye,H,function(_e){C(_e),B.manager.itemEnd(O)},w)}catch(_e){w(_e)}},V,w)},setDRACOLoader:function(O){return this.dracoLoader=O,this},setDDSLoader:function(O){return this.ddsLoader=O,this},setKTX2Loader:function(O){return this.ktx2Loader=O,this},setMeshoptDecoder:function(O){return this.meshoptDecoder=O,this},register:function(O){return this.pluginCallbacks.indexOf(O)===-1&&this.pluginCallbacks.push(O),this},unregister:function(O){return this.pluginCallbacks.indexOf(O)!==-1&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(O),1),this},parse:function(O,C,V,j){var H,B={},w={};if(typeof O=="string")H=O;else if(f.LoaderUtils.decodeText(new Uint8Array(O,0,4))===J){try{B[E.KHR_BINARY_GLTF]=new X(O)}catch(Fe){return void(j&&j(Fe))}H=B[E.KHR_BINARY_GLTF].content}else H=f.LoaderUtils.decodeText(new Uint8Array(O));var $=JSON.parse(H);if($.asset===void 0||$.asset.version[0]<2)j&&j(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));else{var ye=new he($,{path:C||this.resourcePath||"",crossOrigin:this.crossOrigin,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});ye.fileLoader.setRequestHeader(this.requestHeader);for(var _e=0;_e<this.pluginCallbacks.length;_e++){var W=this.pluginCallbacks[_e](ye);w[W.name]=W,B[W.name]=!0}if($.extensionsUsed)for(_e=0;_e<$.extensionsUsed.length;++_e){var ae=$.extensionsUsed[_e],pe=$.extensionsRequired||[];switch(ae){case E.KHR_MATERIALS_UNLIT:B[ae]=new Y;break;case E.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:B[ae]=new Te;break;case E.KHR_DRACO_MESH_COMPRESSION:B[ae]=new Q($,this.dracoLoader);break;case E.MSFT_TEXTURE_DDS:B[ae]=new U(this.ddsLoader);break;case E.KHR_TEXTURE_TRANSFORM:B[ae]=new oe;break;case E.KHR_MESH_QUANTIZATION:B[ae]=new Pe;break;default:pe.indexOf(ae)>=0&&w[ae]===void 0&&console.warn('THREE.GLTFLoader: Unknown extension "'+ae+'".')}}ye.setExtensions(B),ye.setPlugins(w),ye.parse(V,j)}}});var E={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:"KHR_materials_pbrSpecularGlossiness",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression",MSFT_TEXTURE_DDS:"MSFT_texture_dds"};function U(O){if(!O)throw new Error("THREE.GLTFLoader: Attempting to load .dds texture without importing DDSLoader");this.name=E.MSFT_TEXTURE_DDS,this.ddsLoader=O}function G(O){this.parser=O,this.name=E.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}function Y(){this.name=E.KHR_MATERIALS_UNLIT}function we(O){this.parser=O,this.name=E.KHR_MATERIALS_CLEARCOAT}function Se(O){this.parser=O,this.name=E.KHR_MATERIALS_TRANSMISSION}function Me(O){this.parser=O,this.name=E.KHR_TEXTURE_BASISU}function T(O){this.parser=O,this.name=E.EXT_TEXTURE_WEBP,this.isSupported=null}function Z(O){this.name=E.EXT_MESHOPT_COMPRESSION,this.parser=O}G.prototype._markDefs=function(){for(var O=this.parser,C=this.parser.json.nodes||[],V=0,j=C.length;V<j;V++){var H=C[V];H.extensions&&H.extensions[this.name]&&H.extensions[this.name].light!==void 0&&O._addNodeRef(this.cache,H.extensions[this.name].light)}},G.prototype._loadLight=function(O){var C=this.parser,V="light:"+O,j=C.cache.get(V);if(j)return j;var H,B=C.json,w=((B.extensions&&B.extensions[this.name]||{}).lights||[])[O],$=new f.Color(16777215);w.color!==void 0&&$.fromArray(w.color);var ye=w.range!==void 0?w.range:0;switch(w.type){case"directional":(H=new f.DirectionalLight($)).target.position.set(0,0,-1),H.add(H.target);break;case"point":(H=new f.PointLight($)).distance=ye;break;case"spot":(H=new f.SpotLight($)).distance=ye,w.spot=w.spot||{},w.spot.innerConeAngle=w.spot.innerConeAngle!==void 0?w.spot.innerConeAngle:0,w.spot.outerConeAngle=w.spot.outerConeAngle!==void 0?w.spot.outerConeAngle:Math.PI/4,H.angle=w.spot.outerConeAngle,H.penumbra=1-w.spot.innerConeAngle/w.spot.outerConeAngle,H.target.position.set(0,0,-1),H.add(H.target);break;default:throw new Error('THREE.GLTFLoader: Unexpected light type, "'+w.type+'".')}return H.position.set(0,0,0),H.decay=2,w.intensity!==void 0&&(H.intensity=w.intensity),H.name=C.createUniqueName(w.name||"light_"+O),j=Promise.resolve(H),C.cache.add(V,j),j},G.prototype.createNodeAttachment=function(O){var C=this,V=this.parser,j=V.json.nodes[O],H=(j.extensions&&j.extensions[this.name]||{}).light;return H===void 0?null:this._loadLight(H).then(function(B){return V._getNodeRef(C.cache,H,B)})},Y.prototype.getMaterialType=function(){return f.MeshBasicMaterial},Y.prototype.extendParams=function(O,C,V){var j=[];O.color=new f.Color(1,1,1),O.opacity=1;var H=C.pbrMetallicRoughness;if(H){if(Array.isArray(H.baseColorFactor)){var B=H.baseColorFactor;O.color.fromArray(B),O.opacity=B[3]}H.baseColorTexture!==void 0&&j.push(V.assignTexture(O,"map",H.baseColorTexture))}return Promise.all(j)},we.prototype.getMaterialType=function(O){var C=this.parser.json.materials[O];return C.extensions&&C.extensions[this.name]?f.MeshPhysicalMaterial:null},we.prototype.extendMaterialParams=function(O,C){var V=this.parser,j=V.json.materials[O];if(!j.extensions||!j.extensions[this.name])return Promise.resolve();var H=[],B=j.extensions[this.name];if(B.clearcoatFactor!==void 0&&(C.clearcoat=B.clearcoatFactor),B.clearcoatTexture!==void 0&&H.push(V.assignTexture(C,"clearcoatMap",B.clearcoatTexture)),B.clearcoatRoughnessFactor!==void 0&&(C.clearcoatRoughness=B.clearcoatRoughnessFactor),B.clearcoatRoughnessTexture!==void 0&&H.push(V.assignTexture(C,"clearcoatRoughnessMap",B.clearcoatRoughnessTexture)),B.clearcoatNormalTexture!==void 0&&(H.push(V.assignTexture(C,"clearcoatNormalMap",B.clearcoatNormalTexture)),B.clearcoatNormalTexture.scale!==void 0)){var w=B.clearcoatNormalTexture.scale;C.clearcoatNormalScale=new f.Vector2(w,w)}return Promise.all(H)},Se.prototype.getMaterialType=function(O){var C=this.parser.json.materials[O];return C.extensions&&C.extensions[this.name]?f.MeshPhysicalMaterial:null},Se.prototype.extendMaterialParams=function(O,C){var V=this.parser,j=V.json.materials[O];if(!j.extensions||!j.extensions[this.name])return Promise.resolve();var H=[],B=j.extensions[this.name];return B.transmissionFactor!==void 0&&(C.transmission=B.transmissionFactor),B.transmissionTexture!==void 0&&H.push(V.assignTexture(C,"transmissionMap",B.transmissionTexture)),Promise.all(H)},Me.prototype.loadTexture=function(O){var C=this.parser,V=C.json,j=V.textures[O];if(!j.extensions||!j.extensions[this.name])return null;var H=j.extensions[this.name],B=V.images[H.source],w=C.options.ktx2Loader;if(!w){if(V.extensionsRequired&&V.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return C.loadTextureImage(O,B,w)},T.prototype.loadTexture=function(O){var C=this.name,V=this.parser,j=V.json,H=j.textures[O];if(!H.extensions||!H.extensions[C])return null;var B=H.extensions[C],w=j.images[B.source],$=w.uri?V.options.manager.getHandler(w.uri):V.textureLoader;return this.detectSupport().then(function(ye){if(ye)return V.loadTextureImage(O,w,$);if(j.extensionsRequired&&j.extensionsRequired.indexOf(C)>=0)throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");return V.loadTexture(O)})},T.prototype.detectSupport=function(){return this.isSupported||(this.isSupported=new Promise(function(O){var C=new Image;C.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",C.onload=C.onerror=function(){O(C.height===1)}})),this.isSupported},Z.prototype.loadBufferView=function(O){var C=this.parser.json,V=C.bufferViews[O];if(V.extensions&&V.extensions[this.name]){var j=V.extensions[this.name],H=this.parser.getDependency("buffer",j.buffer),B=this.parser.options.meshoptDecoder;if(!B||!B.supported){if(C.extensionsRequired&&C.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return Promise.all([H,B.ready]).then(function(w){var $=j.byteOffset||0,ye=j.byteLength||0,_e=j.count,W=j.byteStride,ae=new ArrayBuffer(_e*W),pe=new Uint8Array(w[0],$,ye);return B.decodeGltfBuffer(new Uint8Array(ae),_e,W,pe,j.mode,j.filter),ae})}return null};var J="glTF",L=1313821514,N=5130562;function X(O){this.name=E.KHR_BINARY_GLTF,this.content=null,this.body=null;var C=new DataView(O,0,12);if(this.header={magic:f.LoaderUtils.decodeText(new Uint8Array(O.slice(0,4))),version:C.getUint32(4,!0),length:C.getUint32(8,!0)},this.header.magic!==J)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");for(var V=new DataView(O,12),j=0;j<V.byteLength;){var H=V.getUint32(j,!0);j+=4;var B=V.getUint32(j,!0);if(j+=4,B===L){var w=new Uint8Array(O,12+j,H);this.content=f.LoaderUtils.decodeText(w)}else if(B===N){var $=12+j;this.body=O.slice($,$+H)}j+=H}if(this.content===null)throw new Error("THREE.GLTFLoader: JSON content not found.")}function Q(O,C){if(!C)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=E.KHR_DRACO_MESH_COMPRESSION,this.json=O,this.dracoLoader=C,this.dracoLoader.preload()}function oe(){this.name=E.KHR_TEXTURE_TRANSFORM}function me(O){f.MeshStandardMaterial.call(this),this.isGLTFSpecularGlossinessMaterial=!0;var C=["#ifdef USE_SPECULARMAP","	uniform sampler2D specularMap;","#endif"].join(`
`),V=["#ifdef USE_GLOSSINESSMAP","	uniform sampler2D glossinessMap;","#endif"].join(`
`),j=["vec3 specularFactor = specular;","#ifdef USE_SPECULARMAP","	vec4 texelSpecular = texture2D( specularMap, vUv );","	texelSpecular = sRGBToLinear( texelSpecular );","	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture","	specularFactor *= texelSpecular.rgb;","#endif"].join(`
`),H=["float glossinessFactor = glossiness;","#ifdef USE_GLOSSINESSMAP","	vec4 texelGlossiness = texture2D( glossinessMap, vUv );","	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture","	glossinessFactor *= texelGlossiness.a;","#endif"].join(`
`),B=["PhysicalMaterial material;","material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );","vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );","float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );","material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.","material.specularRoughness += geometryRoughness;","material.specularRoughness = min( material.specularRoughness, 1.0 );","material.specularColor = specularFactor;"].join(`
`),w={specular:{value:new f.Color().setHex(16777215)},glossiness:{value:1},specularMap:{value:null},glossinessMap:{value:null}};this._extraUniforms=w,this.onBeforeCompile=function($){for(var ye in w)$.uniforms[ye]=w[ye];$.fragmentShader=$.fragmentShader.replace("uniform float roughness;","uniform vec3 specular;").replace("uniform float metalness;","uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>",C).replace("#include <metalnessmap_pars_fragment>",V).replace("#include <roughnessmap_fragment>",j).replace("#include <metalnessmap_fragment>",H).replace("#include <lights_physical_fragment>",B)},Object.defineProperties(this,{specular:{get:function(){return w.specular.value},set:function($){w.specular.value=$}},specularMap:{get:function(){return w.specularMap.value},set:function($){w.specularMap.value=$,$?this.defines.USE_SPECULARMAP="":delete this.defines.USE_SPECULARMAP}},glossiness:{get:function(){return w.glossiness.value},set:function($){w.glossiness.value=$}},glossinessMap:{get:function(){return w.glossinessMap.value},set:function($){w.glossinessMap.value=$,$?(this.defines.USE_GLOSSINESSMAP="",this.defines.USE_UV=""):(delete this.defines.USE_GLOSSINESSMAP,delete this.defines.USE_UV)}}}),delete this.metalness,delete this.roughness,delete this.metalnessMap,delete this.roughnessMap,this.setValues(O)}function Te(){return{name:E.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,specularGlossinessParams:["color","map","lightMap","lightMapIntensity","aoMap","aoMapIntensity","emissive","emissiveIntensity","emissiveMap","bumpMap","bumpScale","normalMap","normalMapType","displacementMap","displacementScale","displacementBias","specularMap","specular","glossinessMap","glossiness","alphaMap","envMap","envMapIntensity","refractionRatio"],getMaterialType:function(){return me},extendParams:function(O,C,V){var j=C.extensions[this.name];O.color=new f.Color(1,1,1),O.opacity=1;var H=[];if(Array.isArray(j.diffuseFactor)){var B=j.diffuseFactor;O.color.fromArray(B),O.opacity=B[3]}if(j.diffuseTexture!==void 0&&H.push(V.assignTexture(O,"map",j.diffuseTexture)),O.emissive=new f.Color(0,0,0),O.glossiness=j.glossinessFactor!==void 0?j.glossinessFactor:1,O.specular=new f.Color(1,1,1),Array.isArray(j.specularFactor)&&O.specular.fromArray(j.specularFactor),j.specularGlossinessTexture!==void 0){var w=j.specularGlossinessTexture;H.push(V.assignTexture(O,"glossinessMap",w)),H.push(V.assignTexture(O,"specularMap",w))}return Promise.all(H)},createMaterial:function(O){var C=new me(O);return C.fog=!0,C.color=O.color,C.map=O.map===void 0?null:O.map,C.lightMap=null,C.lightMapIntensity=1,C.aoMap=O.aoMap===void 0?null:O.aoMap,C.aoMapIntensity=1,C.emissive=O.emissive,C.emissiveIntensity=1,C.emissiveMap=O.emissiveMap===void 0?null:O.emissiveMap,C.bumpMap=O.bumpMap===void 0?null:O.bumpMap,C.bumpScale=1,C.normalMap=O.normalMap===void 0?null:O.normalMap,C.normalMapType=f.TangentSpaceNormalMap,O.normalScale&&(C.normalScale=O.normalScale),C.displacementMap=null,C.displacementScale=1,C.displacementBias=0,C.specularMap=O.specularMap===void 0?null:O.specularMap,C.specular=O.specular,C.glossinessMap=O.glossinessMap===void 0?null:O.glossinessMap,C.glossiness=O.glossiness,C.alphaMap=null,C.envMap=O.envMap===void 0?null:O.envMap,C.envMapIntensity=1,C.refractionRatio=.98,C}}}function Pe(){this.name=E.KHR_MESH_QUANTIZATION}function Re(O,C,V,j){f.Interpolant.call(this,O,C,V,j)}Q.prototype.decodePrimitive=function(O,C){var V=this.json,j=this.dracoLoader,H=O.extensions[this.name].bufferView,B=O.extensions[this.name].attributes,w={},$={},ye={};for(var _e in B){var W=It[_e]||_e.toLowerCase();w[W]=B[_e]}for(_e in O.attributes)if(W=It[_e]||_e.toLowerCase(),B[_e]!==void 0){var ae=V.accessors[O.attributes[_e]],pe=$e[ae.componentType];ye[W]=pe,$[W]=ae.normalized===!0}return C.getDependency("bufferView",H).then(function(Fe){return new Promise(function(Ce){j.decodeDracoFile(Fe,function(v){for(var M in v.attributes){var y=v.attributes[M],_=$[M];_!==void 0&&(y.normalized=_)}Ce(v)},w,ye)})})},oe.prototype.extendTexture=function(O,C){return O=O.clone(),C.offset!==void 0&&O.offset.fromArray(C.offset),C.rotation!==void 0&&(O.rotation=C.rotation),C.scale!==void 0&&O.repeat.fromArray(C.scale),C.texCoord!==void 0&&console.warn('THREE.GLTFLoader: Custom UV sets in "'+this.name+'" extension not yet supported.'),O.needsUpdate=!0,O},me.prototype=Object.create(f.MeshStandardMaterial.prototype),me.prototype.constructor=me,me.prototype.copy=function(O){return f.MeshStandardMaterial.prototype.copy.call(this,O),this.specularMap=O.specularMap,this.specular.copy(O.specular),this.glossinessMap=O.glossinessMap,this.glossiness=O.glossiness,delete this.metalness,delete this.roughness,delete this.metalnessMap,delete this.roughnessMap,this},Re.prototype=Object.create(f.Interpolant.prototype),Re.prototype.constructor=Re,Re.prototype.copySampleValue_=function(O){for(var C=this.resultBuffer,V=this.sampleValues,j=this.valueSize,H=O*j*3+j,B=0;B!==j;B++)C[B]=V[H+B];return C},Re.prototype.beforeStart_=Re.prototype.copySampleValue_,Re.prototype.afterEnd_=Re.prototype.copySampleValue_,Re.prototype.interpolate_=function(O,C,V,j){for(var H=this.resultBuffer,B=this.sampleValues,w=this.valueSize,$=2*w,ye=3*w,_e=j-C,W=(V-C)/_e,ae=W*W,pe=ae*W,Fe=O*ye,Ce=Fe-ye,v=-2*pe+3*ae,M=pe-ae,y=1-v,_=M-ae+W,D=0;D!==w;D++){var ie=B[Ce+D+w],ue=B[Ce+D+$]*_e,se=B[Fe+D+w],Ue=B[Fe+D]*_e;H[D]=y*ie+_*ue+v*se+M*Ue}return H};var Ee=0,Ye=1,Qe=2,lt=3,ot=4,Ne=5,at=6,$e={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},ut={9728:f.NearestFilter,9729:f.LinearFilter,9984:f.NearestMipmapNearestFilter,9985:f.LinearMipmapNearestFilter,9986:f.NearestMipmapLinearFilter,9987:f.LinearMipmapLinearFilter},pt={33071:f.ClampToEdgeWrapping,33648:f.MirroredRepeatWrapping,10497:f.RepeatWrapping},Ot={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},It={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",TEXCOORD_0:"uv",TEXCOORD_1:"uv2",COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},Bt={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},Wt={CUBICSPLINE:void 0,LINEAR:f.InterpolateLinear,STEP:f.InterpolateDiscrete},Tt="OPAQUE",Yt="MASK",Kt="BLEND";function Zt(O,C){return typeof O!="string"||O===""?"":(/^https?:\/\//i.test(C)&&/^\//.test(O)&&(C=C.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(O)||/^data:.*,.*$/i.test(O)||/^blob:.*$/i.test(O)?O:C+O)}function be(O,C,V){for(var j in V.extensions)O[j]===void 0&&(C.userData.gltfExtensions=C.userData.gltfExtensions||{},C.userData.gltfExtensions[j]=V.extensions[j])}function de(O,C){C.extras!==void 0&&(typeof C.extras=="object"?Object.assign(O.userData,C.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+C.extras))}function re(O,C){if(O.updateMorphTargets(),C.weights!==void 0)for(var V=0,j=C.weights.length;V<j;V++)O.morphTargetInfluences[V]=C.weights[V];if(C.extras&&Array.isArray(C.extras.targetNames)){var H=C.extras.targetNames;if(O.morphTargetInfluences.length===H.length)for(O.morphTargetDictionary={},V=0,j=H.length;V<j;V++)O.morphTargetDictionary[H[V]]=V;else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function q(O){for(var C="",V=Object.keys(O).sort(),j=0,H=V.length;j<H;j++)C+=V[j]+":"+O[V[j]]+";";return C}function he(O,C){this.json=O||{},this.extensions={},this.plugins={},this.options=C||{},this.cache=new I,this.associations=new Map,this.primitiveCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.nodeNamesUsed={},typeof createImageBitmap!="undefined"&&/Firefox/.test(navigator.userAgent)===!1?this.textureLoader=new f.ImageBitmapLoader(this.options.manager):this.textureLoader=new f.TextureLoader(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.fileLoader=new f.FileLoader(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),this.options.crossOrigin==="use-credentials"&&this.fileLoader.setWithCredentials(!0)}function Ze(O,C,V){var j=C.attributes,H=[];function B(_e,W){return V.getDependency("accessor",_e).then(function(ae){O.setAttribute(W,ae)})}for(var w in j){var $=It[w]||w.toLowerCase();$ in O.attributes||H.push(B(j[w],$))}if(C.indices!==void 0&&!O.index){var ye=V.getDependency("accessor",C.indices).then(function(_e){O.setIndex(_e)});H.push(ye)}return de(O,C),function(_e,W,ae){var pe=W.attributes,Fe=new f.Box3;if(pe.POSITION!==void 0){var Ce=(se=ae.json.accessors[pe.POSITION]).min,v=se.max;if(Ce!==void 0&&v!==void 0){Fe.set(new f.Vector3(Ce[0],Ce[1],Ce[2]),new f.Vector3(v[0],v[1],v[2]));var M=W.targets;if(M!==void 0){for(var y=new f.Vector3,_=new f.Vector3,D=0,ie=M.length;D<ie;D++){var ue=M[D];if(ue.POSITION!==void 0){var se;Ce=(se=ae.json.accessors[ue.POSITION]).min,v=se.max,Ce!==void 0&&v!==void 0?(_.setX(Math.max(Math.abs(Ce[0]),Math.abs(v[0]))),_.setY(Math.max(Math.abs(Ce[1]),Math.abs(v[1]))),_.setZ(Math.max(Math.abs(Ce[2]),Math.abs(v[2]))),y.max(_)):console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}Fe.expandByVector(y)}_e.boundingBox=Fe;var Ue=new f.Sphere;Fe.getCenter(Ue.center),Ue.radius=Fe.min.distanceTo(Fe.max)/2,_e.boundingSphere=Ue}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}(O,C,V),Promise.all(H).then(function(){return C.targets!==void 0?function(_e,W,ae){for(var pe=!1,Fe=!1,Ce=0,v=W.length;Ce<v&&!((_=W[Ce]).POSITION!==void 0&&(pe=!0),_.NORMAL!==void 0&&(Fe=!0),pe&&Fe);Ce++);if(!pe&&!Fe)return Promise.resolve(_e);var M=[],y=[];for(Ce=0,v=W.length;Ce<v;Ce++){var _=W[Ce];if(pe){var D=_.POSITION!==void 0?ae.getDependency("accessor",_.POSITION):_e.attributes.position;M.push(D)}Fe&&(D=_.NORMAL!==void 0?ae.getDependency("accessor",_.NORMAL):_e.attributes.normal,y.push(D))}return Promise.all([Promise.all(M),Promise.all(y)]).then(function(ie){var ue=ie[0],se=ie[1];return pe&&(_e.morphAttributes.position=ue),Fe&&(_e.morphAttributes.normal=se),_e.morphTargetsRelative=!0,_e})}(O,C.targets,V):O})}function Oe(O,C){var V=O.getIndex();if(V===null){var j=[],H=O.getAttribute("position");if(H===void 0)return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),O;for(var B=0;B<H.count;B++)j.push(B);O.setIndex(j),V=O.getIndex()}var w=V.count-2,$=[];if(C===f.TriangleFanDrawMode)for(B=1;B<=w;B++)$.push(V.getX(0)),$.push(V.getX(B)),$.push(V.getX(B+1));else for(B=0;B<w;B++)B%2==0?($.push(V.getX(B)),$.push(V.getX(B+1)),$.push(V.getX(B+2))):($.push(V.getX(B+2)),$.push(V.getX(B+1)),$.push(V.getX(B)));$.length/3!==w&&console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");var ye=O.clone();return ye.setIndex($),ye}return he.prototype.setExtensions=function(O){this.extensions=O},he.prototype.setPlugins=function(O){this.plugins=O},he.prototype.parse=function(O,C){var V=this,j=this.json,H=this.extensions;this.cache.removeAll(),this._invokeAll(function(B){return B._markDefs&&B._markDefs()}),Promise.all([this.getDependencies("scene"),this.getDependencies("animation"),this.getDependencies("camera")]).then(function(B){var w={scene:B[0][j.scene||0],scenes:B[0],animations:B[1],cameras:B[2],asset:j.asset,parser:V,userData:{}};be(H,w,j),de(w,j),O(w)}).catch(C)},he.prototype._markDefs=function(){for(var O=this.json.nodes||[],C=this.json.skins||[],V=this.json.meshes||[],j=0,H=C.length;j<H;j++)for(var B=C[j].joints,w=0,$=B.length;w<$;w++)O[B[w]].isBone=!0;for(var ye=0,_e=O.length;ye<_e;ye++){var W=O[ye];W.mesh!==void 0&&(this._addNodeRef(this.meshCache,W.mesh),W.skin!==void 0&&(V[W.mesh].isSkinnedMesh=!0)),W.camera!==void 0&&this._addNodeRef(this.cameraCache,W.camera)}},he.prototype._addNodeRef=function(O,C){C!==void 0&&(O.refs[C]===void 0&&(O.refs[C]=O.uses[C]=0),O.refs[C]++)},he.prototype._getNodeRef=function(O,C,V){if(O.refs[C]<=1)return V;var j=V.clone();return j.name+="_instance_"+O.uses[C]++,j},he.prototype._invokeOne=function(O){var C=Object.values(this.plugins);C.push(this);for(var V=0;V<C.length;V++){var j=O(C[V]);if(j)return j}},he.prototype._invokeAll=function(O){var C=Object.values(this.plugins);C.unshift(this);for(var V=[],j=0;j<C.length;j++){var H=O(C[j]);H&&V.push(H)}return V},he.prototype.getDependency=function(O,C){var V=O+":"+C,j=this.cache.get(V);if(!j){switch(O){case"scene":j=this.loadScene(C);break;case"node":j=this.loadNode(C);break;case"mesh":j=this._invokeOne(function(H){return H.loadMesh&&H.loadMesh(C)});break;case"accessor":j=this.loadAccessor(C);break;case"bufferView":j=this._invokeOne(function(H){return H.loadBufferView&&H.loadBufferView(C)});break;case"buffer":j=this.loadBuffer(C);break;case"material":j=this._invokeOne(function(H){return H.loadMaterial&&H.loadMaterial(C)});break;case"texture":j=this._invokeOne(function(H){return H.loadTexture&&H.loadTexture(C)});break;case"skin":j=this.loadSkin(C);break;case"animation":j=this.loadAnimation(C);break;case"camera":j=this.loadCamera(C);break;default:throw new Error("Unknown type: "+O)}this.cache.add(V,j)}return j},he.prototype.getDependencies=function(O){var C=this.cache.get(O);if(!C){var V=this,j=this.json[O+(O==="mesh"?"es":"s")]||[];C=Promise.all(j.map(function(H,B){return V.getDependency(O,B)})),this.cache.add(O,C)}return C},he.prototype.loadBuffer=function(O){var C=this.json.buffers[O],V=this.fileLoader;if(C.type&&C.type!=="arraybuffer")throw new Error("THREE.GLTFLoader: "+C.type+" buffer type is not supported.");if(C.uri===void 0&&O===0)return Promise.resolve(this.extensions[E.KHR_BINARY_GLTF].body);var j=this.options;return new Promise(function(H,B){V.load(Zt(C.uri,j.path),H,void 0,function(){B(new Error('THREE.GLTFLoader: Failed to load buffer "'+C.uri+'".'))})})},he.prototype.loadBufferView=function(O){var C=this.json.bufferViews[O];return this.getDependency("buffer",C.buffer).then(function(V){var j=C.byteLength||0,H=C.byteOffset||0;return V.slice(H,H+j)})},he.prototype.loadAccessor=function(O){var C=this,V=this.json,j=this.json.accessors[O];if(j.bufferView===void 0&&j.sparse===void 0)return Promise.resolve(null);var H=[];return j.bufferView!==void 0?H.push(this.getDependency("bufferView",j.bufferView)):H.push(null),j.sparse!==void 0&&(H.push(this.getDependency("bufferView",j.sparse.indices.bufferView)),H.push(this.getDependency("bufferView",j.sparse.values.bufferView))),Promise.all(H).then(function(B){var w,$,ye=B[0],_e=Ot[j.type],W=$e[j.componentType],ae=W.BYTES_PER_ELEMENT,pe=ae*_e,Fe=j.byteOffset||0,Ce=j.bufferView!==void 0?V.bufferViews[j.bufferView].byteStride:void 0,v=j.normalized===!0;if(Ce&&Ce!==pe){var M=Math.floor(Fe/Ce),y="InterleavedBuffer:"+j.bufferView+":"+j.componentType+":"+M+":"+j.count,_=C.cache.get(y);_||(w=new W(ye,M*Ce,j.count*Ce/ae),_=new f.InterleavedBuffer(w,Ce/ae),C.cache.add(y,_)),$=new f.InterleavedBufferAttribute(_,_e,Fe%Ce/ae,v)}else w=ye===null?new W(j.count*_e):new W(ye,Fe,j.count*_e),$=new f.BufferAttribute(w,_e,v);if(j.sparse!==void 0){var D=Ot.SCALAR,ie=$e[j.sparse.indices.componentType],ue=j.sparse.indices.byteOffset||0,se=j.sparse.values.byteOffset||0,Ue=new ie(B[1],ue,j.sparse.count*D),it=new W(B[2],se,j.sparse.count*_e);ye!==null&&($=new f.BufferAttribute($.array.slice(),$.itemSize,$.normalized));for(var Be=0,Et=Ue.length;Be<Et;Be++){var bt=Ue[Be];if($.setX(bt,it[Be*_e]),_e>=2&&$.setY(bt,it[Be*_e+1]),_e>=3&&$.setZ(bt,it[Be*_e+2]),_e>=4&&$.setW(bt,it[Be*_e+3]),_e>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}}return $})},he.prototype.loadTexture=function(O){var C,V,j=this.json,H=this.options,B=j.textures[O],w=B.extensions||{};return(C=w[E.MSFT_TEXTURE_DDS]?j.images[w[E.MSFT_TEXTURE_DDS].source]:j.images[B.source]).uri&&(V=H.manager.getHandler(C.uri)),V||(V=w[E.MSFT_TEXTURE_DDS]?this.extensions[E.MSFT_TEXTURE_DDS].ddsLoader:this.textureLoader),this.loadTextureImage(O,C,V)},he.prototype.loadTextureImage=function(O,C,V){var j=this,H=this.json,B=this.options,w=H.textures[O],$=self.URL||self.webkitURL,ye=C.uri,_e=!1,W=!0;return C.mimeType==="image/jpeg"&&(W=!1),C.bufferView!==void 0&&(ye=j.getDependency("bufferView",C.bufferView).then(function(ae){if(C.mimeType==="image/png"){var pe=new DataView(ae,25,1).getUint8(0,!1);W=pe===6||pe===4||pe===3}_e=!0;var Fe=new Blob([ae],{type:C.mimeType});return ye=$.createObjectURL(Fe)})),Promise.resolve(ye).then(function(ae){return new Promise(function(pe,Fe){var Ce=pe;V.isImageBitmapLoader===!0&&(Ce=function(v){pe(new f.CanvasTexture(v))}),V.load(Zt(ae,B.path),Ce,void 0,Fe)})}).then(function(ae){_e===!0&&$.revokeObjectURL(ye),ae.flipY=!1,w.name&&(ae.name=w.name),W||(ae.format=f.RGBFormat);var pe=(H.samplers||{})[w.sampler]||{};return ae.magFilter=ut[pe.magFilter]||f.LinearFilter,ae.minFilter=ut[pe.minFilter]||f.LinearMipmapLinearFilter,ae.wrapS=pt[pe.wrapS]||f.RepeatWrapping,ae.wrapT=pt[pe.wrapT]||f.RepeatWrapping,j.associations.set(ae,{type:"textures",index:O}),ae})},he.prototype.assignTexture=function(O,C,V){var j=this;return this.getDependency("texture",V.index).then(function(H){if(V.texCoord===void 0||V.texCoord==0||C==="aoMap"&&V.texCoord==1||console.warn("THREE.GLTFLoader: Custom UV set "+V.texCoord+" for texture "+C+" not yet supported."),j.extensions[E.KHR_TEXTURE_TRANSFORM]){var B=V.extensions!==void 0?V.extensions[E.KHR_TEXTURE_TRANSFORM]:void 0;if(B){var w=j.associations.get(H);H=j.extensions[E.KHR_TEXTURE_TRANSFORM].extendTexture(H,B),j.associations.set(H,w)}}O[C]=H})},he.prototype.assignFinalMaterial=function(O){var C=O.geometry,V=O.material,j=C.attributes.tangent!==void 0,H=C.attributes.color!==void 0,B=C.attributes.normal===void 0,w=O.isSkinnedMesh===!0,$=Object.keys(C.morphAttributes).length>0,ye=$&&C.morphAttributes.normal!==void 0;if(O.isPoints){var _e="PointsMaterial:"+V.uuid,W=this.cache.get(_e);W||(W=new f.PointsMaterial,f.Material.prototype.copy.call(W,V),W.color.copy(V.color),W.map=V.map,W.sizeAttenuation=!1,this.cache.add(_e,W)),V=W}else if(O.isLine){_e="LineBasicMaterial:"+V.uuid;var ae=this.cache.get(_e);ae||(ae=new f.LineBasicMaterial,f.Material.prototype.copy.call(ae,V),ae.color.copy(V.color),this.cache.add(_e,ae)),V=ae}if(j||H||B||w||$){_e="ClonedMaterial:"+V.uuid+":",V.isGLTFSpecularGlossinessMaterial&&(_e+="specular-glossiness:"),w&&(_e+="skinning:"),j&&(_e+="vertex-tangents:"),H&&(_e+="vertex-colors:"),B&&(_e+="flat-shading:"),$&&(_e+="morph-targets:"),ye&&(_e+="morph-normals:");var pe=this.cache.get(_e);pe||(pe=V.clone(),w&&(pe.skinning=!0),j&&(pe.vertexTangents=!0),H&&(pe.vertexColors=!0),B&&(pe.flatShading=!0),$&&(pe.morphTargets=!0),ye&&(pe.morphNormals=!0),this.cache.add(_e,pe),this.associations.set(pe,this.associations.get(V))),V=pe}V.aoMap&&C.attributes.uv2===void 0&&C.attributes.uv!==void 0&&C.setAttribute("uv2",C.attributes.uv),V.normalScale&&!j&&(V.normalScale.y=-V.normalScale.y),V.clearcoatNormalScale&&!j&&(V.clearcoatNormalScale.y=-V.clearcoatNormalScale.y),O.material=V},he.prototype.getMaterialType=function(){return f.MeshStandardMaterial},he.prototype.loadMaterial=function(O){var C,V=this,j=this.json,H=this.extensions,B=j.materials[O],w={},$=B.extensions||{},ye=[];if($[E.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]){var _e=H[E.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];C=_e.getMaterialType(),ye.push(_e.extendParams(w,B,V))}else if($[E.KHR_MATERIALS_UNLIT]){var W=H[E.KHR_MATERIALS_UNLIT];C=W.getMaterialType(),ye.push(W.extendParams(w,B,V))}else{var ae=B.pbrMetallicRoughness||{};if(w.color=new f.Color(1,1,1),w.opacity=1,Array.isArray(ae.baseColorFactor)){var pe=ae.baseColorFactor;w.color.fromArray(pe),w.opacity=pe[3]}ae.baseColorTexture!==void 0&&ye.push(V.assignTexture(w,"map",ae.baseColorTexture)),w.metalness=ae.metallicFactor!==void 0?ae.metallicFactor:1,w.roughness=ae.roughnessFactor!==void 0?ae.roughnessFactor:1,ae.metallicRoughnessTexture!==void 0&&(ye.push(V.assignTexture(w,"metalnessMap",ae.metallicRoughnessTexture)),ye.push(V.assignTexture(w,"roughnessMap",ae.metallicRoughnessTexture))),C=this._invokeOne(function(Ce){return Ce.getMaterialType&&Ce.getMaterialType(O)}),ye.push(Promise.all(this._invokeAll(function(Ce){return Ce.extendMaterialParams&&Ce.extendMaterialParams(O,w)})))}B.doubleSided===!0&&(w.side=f.DoubleSide);var Fe=B.alphaMode||Tt;return Fe===Kt?(w.transparent=!0,w.depthWrite=!1):(w.transparent=!1,Fe===Yt&&(w.alphaTest=B.alphaCutoff!==void 0?B.alphaCutoff:.5)),B.normalTexture!==void 0&&C!==f.MeshBasicMaterial&&(ye.push(V.assignTexture(w,"normalMap",B.normalTexture)),w.normalScale=new f.Vector2(1,1),B.normalTexture.scale!==void 0&&w.normalScale.set(B.normalTexture.scale,B.normalTexture.scale)),B.occlusionTexture!==void 0&&C!==f.MeshBasicMaterial&&(ye.push(V.assignTexture(w,"aoMap",B.occlusionTexture)),B.occlusionTexture.strength!==void 0&&(w.aoMapIntensity=B.occlusionTexture.strength)),B.emissiveFactor!==void 0&&C!==f.MeshBasicMaterial&&(w.emissive=new f.Color().fromArray(B.emissiveFactor)),B.emissiveTexture!==void 0&&C!==f.MeshBasicMaterial&&ye.push(V.assignTexture(w,"emissiveMap",B.emissiveTexture)),Promise.all(ye).then(function(){var Ce;return Ce=C===me?H[E.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(w):new C(w),B.name&&(Ce.name=B.name),Ce.map&&(Ce.map.encoding=f.sRGBEncoding),Ce.emissiveMap&&(Ce.emissiveMap.encoding=f.sRGBEncoding),de(Ce,B),V.associations.set(Ce,{type:"materials",index:O}),B.extensions&&be(H,Ce,B),Ce})},he.prototype.createUniqueName=function(O){for(var C=f.PropertyBinding.sanitizeNodeName(O||""),V=1;this.nodeNamesUsed[C];++V)C=O+"_"+V;return this.nodeNamesUsed[C]=!0,C},he.prototype.loadGeometries=function(O){var C=this,V=this.extensions,j=this.primitiveCache;function H(Ce){return V[E.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(Ce,C).then(function(v){return Ze(v,Ce,C)})}for(var B,w,$=[],ye=0,_e=O.length;ye<_e;ye++){var W,ae=O[ye],pe=(w=void 0,(w=(B=ae).extensions&&B.extensions[E.KHR_DRACO_MESH_COMPRESSION])?"draco:"+w.bufferView+":"+w.indices+":"+q(w.attributes):B.indices+":"+q(B.attributes)+":"+B.mode),Fe=j[pe];Fe?$.push(Fe.promise):(W=ae.extensions&&ae.extensions[E.KHR_DRACO_MESH_COMPRESSION]?H(ae):Ze(new f.BufferGeometry,ae,C),j[pe]={primitive:ae,promise:W},$.push(W))}return Promise.all($)},he.prototype.loadMesh=function(O){for(var C,V=this,j=this.json,H=this.extensions,B=j.meshes[O],w=B.primitives,$=[],ye=0,_e=w.length;ye<_e;ye++){var W=w[ye].material===void 0?((C=this.cache).DefaultMaterial===void 0&&(C.DefaultMaterial=new f.MeshStandardMaterial({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:f.FrontSide})),C.DefaultMaterial):this.getDependency("material",w[ye].material);$.push(W)}return $.push(V.loadGeometries(w)),Promise.all($).then(function(ae){for(var pe=ae.slice(0,ae.length-1),Fe=ae[ae.length-1],Ce=[],v=0,M=Fe.length;v<M;v++){var y,_=Fe[v],D=w[v],ie=pe[v];if(D.mode===ot||D.mode===Ne||D.mode===at||D.mode===void 0)(y=B.isSkinnedMesh===!0?new f.SkinnedMesh(_,ie):new f.Mesh(_,ie)).isSkinnedMesh!==!0||y.geometry.attributes.skinWeight.normalized||y.normalizeSkinWeights(),D.mode===Ne?y.geometry=Oe(y.geometry,f.TriangleStripDrawMode):D.mode===at&&(y.geometry=Oe(y.geometry,f.TriangleFanDrawMode));else if(D.mode===Ye)y=new f.LineSegments(_,ie);else if(D.mode===lt)y=new f.Line(_,ie);else if(D.mode===Qe)y=new f.LineLoop(_,ie);else{if(D.mode!==Ee)throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+D.mode);y=new f.Points(_,ie)}Object.keys(y.geometry.morphAttributes).length>0&&re(y,B),y.name=V.createUniqueName(B.name||"mesh_"+O),de(y,B),D.extensions&&be(H,y,D),V.assignFinalMaterial(y),Ce.push(y)}if(Ce.length===1)return Ce[0];var ue=new f.Group;for(v=0,M=Ce.length;v<M;v++)ue.add(Ce[v]);return ue})},he.prototype.loadCamera=function(O){var C,V=this.json.cameras[O],j=V[V.type];if(j)return V.type==="perspective"?C=new f.PerspectiveCamera(f.MathUtils.radToDeg(j.yfov),j.aspectRatio||1,j.znear||1,j.zfar||2e6):V.type==="orthographic"&&(C=new f.OrthographicCamera(-j.xmag,j.xmag,j.ymag,-j.ymag,j.znear,j.zfar)),V.name&&(C.name=this.createUniqueName(V.name)),de(C,V),Promise.resolve(C);console.warn("THREE.GLTFLoader: Missing camera parameters.")},he.prototype.loadSkin=function(O){var C=this.json.skins[O],V={joints:C.joints};return C.inverseBindMatrices===void 0?Promise.resolve(V):this.getDependency("accessor",C.inverseBindMatrices).then(function(j){return V.inverseBindMatrices=j,V})},he.prototype.loadAnimation=function(O){for(var C=this.json.animations[O],V=[],j=[],H=[],B=[],w=[],$=0,ye=C.channels.length;$<ye;$++){var _e=C.channels[$],W=C.samplers[_e.sampler],ae=_e.target,pe=ae.node!==void 0?ae.node:ae.id,Fe=C.parameters!==void 0?C.parameters[W.input]:W.input,Ce=C.parameters!==void 0?C.parameters[W.output]:W.output;V.push(this.getDependency("node",pe)),j.push(this.getDependency("accessor",Fe)),H.push(this.getDependency("accessor",Ce)),B.push(W),w.push(ae)}return Promise.all([Promise.all(V),Promise.all(j),Promise.all(H),Promise.all(B),Promise.all(w)]).then(function(v){for(var M=v[0],y=v[1],_=v[2],D=v[3],ie=v[4],ue=[],se=0,Ue=M.length;se<Ue;se++){var it=M[se],Be=y[se],Et=_[se],bt=D[se],on=ie[se];if(it!==void 0){var Qt;switch(it.updateMatrix(),it.matrixAutoUpdate=!0,Bt[on.path]){case Bt.weights:Qt=f.NumberKeyframeTrack;break;case Bt.rotation:Qt=f.QuaternionKeyframeTrack;break;case Bt.position:case Bt.scale:default:Qt=f.VectorKeyframeTrack}var Xt=it.name?it.name:it.uuid,wn=bt.interpolation!==void 0?Wt[bt.interpolation]:f.InterpolateLinear,gn=[];Bt[on.path]===Bt.weights?it.traverse(function(En){En.isMesh===!0&&En.morphTargetInfluences&&gn.push(En.name?En.name:En.uuid)}):gn.push(Xt);var sn=Et.array;if(Et.normalized){var On;if(sn.constructor===Int8Array)On=1/127;else if(sn.constructor===Uint8Array)On=1/255;else if(sn.constructor==Int16Array)On=1/32767;else{if(sn.constructor!==Uint16Array)throw new Error("THREE.GLTFLoader: Unsupported output accessor component type.");On=1/65535}for(var Zn=new Float32Array(sn.length),Dn=0,Cn=sn.length;Dn<Cn;Dn++)Zn[Dn]=sn[Dn]*On;sn=Zn}for(Dn=0,Cn=gn.length;Dn<Cn;Dn++){var Tn=new Qt(gn[Dn]+"."+Bt[on.path],Be.array,sn,wn);bt.interpolation==="CUBICSPLINE"&&(Tn.createInterpolant=function(En){return new Re(this.times,this.values,this.getValueSize()/3,En)},Tn.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0),ue.push(Tn)}}}var Jn=C.name?C.name:"animation_"+O;return new f.AnimationClip(Jn,void 0,ue)})},he.prototype.loadNode=function(O){var C,V=this.json,j=this.extensions,H=this,B=V.nodes[O],w=B.name?H.createUniqueName(B.name):"";return(C=[],B.mesh!==void 0&&C.push(H.getDependency("mesh",B.mesh).then(function($){var ye=H._getNodeRef(H.meshCache,B.mesh,$);return B.weights!==void 0&&ye.traverse(function(_e){if(_e.isMesh)for(var W=0,ae=B.weights.length;W<ae;W++)_e.morphTargetInfluences[W]=B.weights[W]}),ye})),B.camera!==void 0&&C.push(H.getDependency("camera",B.camera).then(function($){return H._getNodeRef(H.cameraCache,B.camera,$)})),H._invokeAll(function($){return $.createNodeAttachment&&$.createNodeAttachment(O)}).forEach(function($){C.push($)}),Promise.all(C)).then(function($){var ye;if((ye=B.isBone===!0?new f.Bone:$.length>1?new f.Group:$.length===1?$[0]:new f.Object3D)!==$[0])for(var _e=0,W=$.length;_e<W;_e++)ye.add($[_e]);if(B.name&&(ye.userData.name=B.name,ye.name=w),de(ye,B),B.extensions&&be(j,ye,B),B.matrix!==void 0){var ae=new f.Matrix4;ae.fromArray(B.matrix),ye.applyMatrix4(ae)}else B.translation!==void 0&&ye.position.fromArray(B.translation),B.rotation!==void 0&&ye.quaternion.fromArray(B.rotation),B.scale!==void 0&&ye.scale.fromArray(B.scale);return H.associations.set(ye,{type:"nodes",index:O}),ye})},he.prototype.loadScene=function(){function O(C,V,j,H){var B=j.nodes[C];return H.getDependency("node",C).then(function(w){return B.skin===void 0?w:H.getDependency("skin",B.skin).then(function(ye){for(var _e=[],W=0,ae=($=ye).joints.length;W<ae;W++)_e.push(H.getDependency("node",$.joints[W]));return Promise.all(_e)}).then(function(ye){return w.traverse(function(_e){if(_e.isMesh){for(var W=[],ae=[],pe=0,Fe=ye.length;pe<Fe;pe++){var Ce=ye[pe];if(Ce){W.push(Ce);var v=new f.Matrix4;$.inverseBindMatrices!==void 0&&v.fromArray($.inverseBindMatrices.array,16*pe),ae.push(v)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',$.joints[pe])}_e.bind(new f.Skeleton(W,ae),_e.matrixWorld)}}),w});var $}).then(function(w){V.add(w);var $=[];if(B.children)for(var ye=B.children,_e=0,W=ye.length;_e<W;_e++){var ae=ye[_e];$.push(O(ae,w,j,H))}return Promise.all($)})}return function(C){var V=this.json,j=this.extensions,H=this.json.scenes[C],B=new f.Group;H.name&&(B.name=this.createUniqueName(H.name)),de(B,H),H.extensions&&be(j,B,H);for(var w=H.nodes||[],$=[],ye=0,_e=w.length;ye<_e;ye++)$.push(O(w[ye],B,V,this));return Promise.all($).then(function(){return B})}}(),P}()},function(rt,h,l){var f=this&&this.__createBinding||(Object.create?function(me,Te,Pe,Re){Re===void 0&&(Re=Pe),Object.defineProperty(me,Re,{enumerable:!0,get:function(){return Te[Pe]}})}:function(me,Te,Pe,Re){Re===void 0&&(Re=Pe),me[Re]=Te[Pe]}),A=this&&this.__exportStar||function(me,Te){for(var Pe in me)Pe==="default"||Object.prototype.hasOwnProperty.call(Te,Pe)||f(Te,me,Pe)};Object.defineProperty(h,"__esModule",{value:!0}),h.DotScreenShader=h.GlitchPass=h.ShaderPass=h.RenderPass=h.EffectComposer=h.WEBGL=h.OrbitControls=h.Water=h.Sky=h.AnimationAction=h.VRButton=h.SVGLoader=h.XRControllerModelFactory=h.GLTFLoader=h.FBXLoader=h.ConvexBufferGeometry=void 0,A(l(0),h);const P=l(15);Object.defineProperty(h,"ConvexBufferGeometry",{enumerable:!0,get:function(){return P.ConvexBufferGeometry}});const I=l(12);Object.defineProperty(h,"FBXLoader",{enumerable:!0,get:function(){return I.FBXLoader}});const E=l(3);Object.defineProperty(h,"GLTFLoader",{enumerable:!0,get:function(){return E.GLTFLoader}});const U=l(16);Object.defineProperty(h,"XRControllerModelFactory",{enumerable:!0,get:function(){return U.XRControllerModelFactory}});const G=l(5);Object.defineProperty(h,"SVGLoader",{enumerable:!0,get:function(){return G.SVGLoader}});const Y=l(6);Object.defineProperty(h,"VRButton",{enumerable:!0,get:function(){return Y.VRButton}});const we=l(17);Object.defineProperty(h,"AnimationAction",{enumerable:!0,get:function(){return we.AnimationAction}});const Se=l(7);Object.defineProperty(h,"Sky",{enumerable:!0,get:function(){return Se.Sky}});const Me=l(13);Object.defineProperty(h,"Water",{enumerable:!0,get:function(){return Me.Water}});const T=l(8);Object.defineProperty(h,"OrbitControls",{enumerable:!0,get:function(){return T.OrbitControls}});const Z=l(9);Object.defineProperty(h,"WEBGL",{enumerable:!0,get:function(){return Z.WEBGL}});var J=l(14);Object.defineProperty(h,"EffectComposer",{enumerable:!0,get:function(){return J.EffectComposer}});var L=l(10);Object.defineProperty(h,"RenderPass",{enumerable:!0,get:function(){return L.RenderPass}});var N=l(2);Object.defineProperty(h,"ShaderPass",{enumerable:!0,get:function(){return N.ShaderPass}});var X=l(18);Object.defineProperty(h,"GlitchPass",{enumerable:!0,get:function(){return X.GlitchPass}});var Q=l(11);Object.defineProperty(h,"DotScreenShader",{enumerable:!0,get:function(){return Q.DotScreenShader}});const oe="Three.js r"+l(0).REVISION;console.log(`%c %c %c %c %c ${oe} %c https://threejs.org/`,"background: #ff0000","background: #ffff00","background: #00ff00","background: #00ffff","color: #fff; background: #000000;","background: none")},function(rt,h,l){l.r(h),l.d(h,"SVGLoader",function(){return oe});var f,A,P,I,E,U,G,Y,we,Se,Me,T,Z,J,L,N,X,Q=l(0),oe=function(me){Q.Loader.call(this,me),this.defaultDPI=90,this.defaultUnit="px"};oe.prototype=Object.assign(Object.create(Q.Loader.prototype),{constructor:oe,load:function(me,Te,Pe,Re){var Ee=this,Ye=new Q.FileLoader(Ee.manager);Ye.setPath(Ee.path),Ye.setRequestHeader(Ee.requestHeader),Ye.setWithCredentials(Ee.withCredentials),Ye.load(me,function(Qe){try{Te(Ee.parse(Qe))}catch(lt){Re?Re(lt):console.error(lt),Ee.manager.itemError(me)}},Pe,Re)},parse:function(me){var Te=this;function Pe(de,re,q,he,Ze,Oe,O,C){if(re!=0&&q!=0){he=he*Math.PI/180,re=Math.abs(re),q=Math.abs(q);var V=(O.x-C.x)/2,j=(O.y-C.y)/2,H=Math.cos(he)*V+Math.sin(he)*j,B=-Math.sin(he)*V+Math.cos(he)*j,w=re*re,$=q*q,ye=H*H,_e=B*B,W=ye/w+_e/$;if(W>1){var ae=Math.sqrt(W);w=(re*=ae)*re,$=(q*=ae)*q}var pe=w*_e+$*ye,Fe=(w*$-pe)/pe,Ce=Math.sqrt(Math.max(0,Fe));Ze===Oe&&(Ce=-Ce);var v=Ce*re*B/q,M=-Ce*q*H/re,y=Math.cos(he)*v-Math.sin(he)*M+(O.x+C.x)/2,_=Math.sin(he)*v+Math.cos(he)*M+(O.y+C.y)/2,D=Re(1,0,(H-v)/re,(B-M)/q),ie=Re((H-v)/re,(B-M)/q,(-H-v)/re,(-B-M)/q)%(2*Math.PI);de.currentPath.absellipse(y,_,re,q,D,D+ie,Oe===0,he)}else de.lineTo(C.x,C.y)}function Re(de,re,q,he){var Ze=de*q+re*he,Oe=Math.sqrt(de*de+re*re)*Math.sqrt(q*q+he*he),O=Math.acos(Math.max(-1,Math.min(1,Ze/Oe)));return de*he-re*q<0&&(O=-O),O}function Ee(de,re){re=Object.assign({},re);var q={};if(de.hasAttribute("class"))for(var he=de.getAttribute("class").split(/\s/).filter(Boolean).map(V=>V.trim()),Ze=0;Ze<he.length;Ze++)q=Object.assign(q,pt["."+he[Ze]]);function Oe(V,j,H){H===void 0&&(H=function(B){return B.startsWith("url")&&console.warn("SVGLoader: url access in attributes is not implemented."),B}),de.hasAttribute(V)&&(re[j]=H(de.getAttribute(V))),q[V]&&(re[j]=H(q[V])),de.style&&de.style[V]!==""&&(re[j]=H(de.style[V]))}function O(V){return Math.max(0,Math.min(1,Ne(V)))}function C(V){return Math.max(0,Ne(V))}return de.hasAttribute("id")&&(q=Object.assign(q,pt["#"+de.getAttribute("id")])),Oe("fill","fill"),Oe("fill-opacity","fillOpacity",O),Oe("opacity","opacity",O),Oe("stroke","stroke"),Oe("stroke-opacity","strokeOpacity",O),Oe("stroke-width","strokeWidth",C),Oe("stroke-linejoin","strokeLineJoin"),Oe("stroke-linecap","strokeLineCap"),Oe("stroke-miterlimit","strokeMiterLimit",C),Oe("visibility","visibility"),re}function Ye(de,re){return de-(re-de)}function Qe(de){for(var re=de.split(/[\s,]+|(?=\s?[+\-])/),q=0;q<re.length;q++){var he=re[q];if(he.indexOf(".")!==he.lastIndexOf("."))for(var Ze=he.split("."),Oe=2;Oe<Ze.length;Oe++)re.splice(q+Oe-1,0,"0."+Ze[Oe]);re[q]=Ne(he)}return re}var lt=["mm","cm","in","pt","pc","px"],ot={mm:{mm:1,cm:.1,in:1/25.4,pt:72/25.4,pc:6/25.4,px:-1},cm:{mm:10,cm:1,in:1/2.54,pt:72/2.54,pc:6/2.54,px:-1},in:{mm:25.4,cm:2.54,in:1,pt:72,pc:6,px:-1},pt:{mm:25.4/72,cm:2.54/72,in:1/72,pt:1,pc:6/72,px:-1},pc:{mm:25.4/6,cm:2.54/6,in:1/6,pt:12,pc:1,px:-1},px:{px:1}};function Ne(de){var re="px";if(typeof de=="string"||de instanceof String)for(var q=0,he=lt.length;q<he;q++){var Ze=lt[q];if(de.endsWith(Ze)){re=Ze,de=de.substring(0,de.length-Ze.length);break}}var Oe=void 0;return re==="px"&&Te.defaultUnit!=="px"?Oe=ot.in[Te.defaultUnit]/Te.defaultDPI:(Oe=ot[re][Te.defaultUnit])<0&&(Oe=ot[re].in*Te.defaultDPI),Oe*parseFloat(de)}function at(de){var re=de.elements;return Math.sqrt(re[0]*re[0]+re[1]*re[1])}function $e(de){var re=de.elements;return Math.sqrt(re[3]*re[3]+re[4]*re[4])}var ut=[],pt={},Ot=[],It=new Q.Matrix3,Bt=new Q.Matrix3,Wt=new Q.Matrix3,Tt=new Q.Matrix3,Yt=new Q.Vector2,Kt=new Q.Vector3,Zt=new Q.Matrix3,be=new DOMParser().parseFromString(me,"image/svg+xml");return function de(re,q){if(re.nodeType===1){var he=function(H){if(!(H.hasAttribute("transform")||H.nodeName==="use"&&(H.hasAttribute("x")||H.hasAttribute("y"))))return null;var B=function(w){var $=new Q.Matrix3,ye=It;if(w.nodeName==="use"&&(w.hasAttribute("x")||w.hasAttribute("y"))){var _e=Ne(w.getAttribute("x")),W=Ne(w.getAttribute("y"));$.translate(_e,W)}if(w.hasAttribute("transform"))for(var ae=w.getAttribute("transform").split(")"),pe=ae.length-1;pe>=0;pe--){var Fe=ae[pe].trim();if(Fe!==""){var Ce=Fe.indexOf("("),v=Fe.length;if(Ce>0&&Ce<v){var M=Fe.substr(0,Ce),y=Qe(Fe.substr(Ce+1,v-Ce-1));switch(ye.identity(),M){case"translate":y.length>=1&&(W=_e=y[0],y.length>=2&&(W=y[1]),ye.translate(_e,W));break;case"rotate":if(y.length>=1){var _,D=0,ie=0;_=-y[0]*Math.PI/180,y.length>=3&&(D=y[1],ie=y[2]),Bt.identity().translate(-D,-ie),Wt.identity().rotate(_),Tt.multiplyMatrices(Wt,Bt),Bt.identity().translate(D,ie),ye.multiplyMatrices(Bt,Tt)}break;case"scale":if(y.length>=1){var ue=y[0],se=ue;y.length>=2&&(se=y[1]),ye.scale(ue,se)}break;case"skewX":y.length===1&&ye.set(1,Math.tan(y[0]*Math.PI/180),0,0,1,0,0,0,1);break;case"skewY":y.length===1&&ye.set(1,0,0,Math.tan(y[0]*Math.PI/180),1,0,0,0,1);break;case"matrix":y.length===6&&ye.set(y[0],y[2],y[4],y[1],y[3],y[5],0,0,1)}}$.premultiply(ye)}}return $}(H);return Ot.length>0&&B.premultiply(Ot[Ot.length-1]),Zt.copy(B),Ot.push(B),B}(re),Ze=!0,Oe=null;switch(re.nodeName){case"svg":break;case"style":!function(H){if(!H.sheet||!H.sheet.cssRules||!H.sheet.cssRules.length)return;for(var B=0;B<H.sheet.cssRules.length;B++){var w=H.sheet.cssRules[B];if(w.type===1)for(var $=w.selectorText.split(/,/gm).filter(Boolean).map(_e=>_e.trim()),ye=0;ye<$.length;ye++)pt[$[ye]]=Object.assign(pt[$[ye]]||{},w.style)}}(re);break;case"g":q=Ee(re,q);break;case"path":q=Ee(re,q),re.hasAttribute("d")&&(Oe=function(H){for(var B=new Q.ShapePath,w=new Q.Vector2,$=new Q.Vector2,ye=new Q.Vector2,_e=!0,W=!1,ae=H.getAttribute("d").match(/[a-df-z][^a-df-z]*/gi),pe=0,Fe=ae.length;pe<Fe;pe++){var Ce=ae[pe],v=Ce.charAt(0),M=Ce.substr(1).trim();switch(_e===!0&&(W=!0,_e=!1),v){case"M":for(var y=Qe(M),_=0,D=y.length;_<D;_+=2)w.x=y[_+0],w.y=y[_+1],$.x=w.x,$.y=w.y,_===0?B.moveTo(w.x,w.y):B.lineTo(w.x,w.y),_===0&&W===!0&&ye.copy(w);break;case"H":for(y=Qe(M),_=0,D=y.length;_<D;_++)w.x=y[_],$.x=w.x,$.y=w.y,B.lineTo(w.x,w.y),_===0&&W===!0&&ye.copy(w);break;case"V":for(y=Qe(M),_=0,D=y.length;_<D;_++)w.y=y[_],$.x=w.x,$.y=w.y,B.lineTo(w.x,w.y),_===0&&W===!0&&ye.copy(w);break;case"L":for(y=Qe(M),_=0,D=y.length;_<D;_+=2)w.x=y[_+0],w.y=y[_+1],$.x=w.x,$.y=w.y,B.lineTo(w.x,w.y),_===0&&W===!0&&ye.copy(w);break;case"C":for(y=Qe(M),_=0,D=y.length;_<D;_+=6)B.bezierCurveTo(y[_+0],y[_+1],y[_+2],y[_+3],y[_+4],y[_+5]),$.x=y[_+2],$.y=y[_+3],w.x=y[_+4],w.y=y[_+5],_===0&&W===!0&&ye.copy(w);break;case"S":for(y=Qe(M),_=0,D=y.length;_<D;_+=4)B.bezierCurveTo(Ye(w.x,$.x),Ye(w.y,$.y),y[_+0],y[_+1],y[_+2],y[_+3]),$.x=y[_+0],$.y=y[_+1],w.x=y[_+2],w.y=y[_+3],_===0&&W===!0&&ye.copy(w);break;case"Q":for(y=Qe(M),_=0,D=y.length;_<D;_+=4)B.quadraticCurveTo(y[_+0],y[_+1],y[_+2],y[_+3]),$.x=y[_+0],$.y=y[_+1],w.x=y[_+2],w.y=y[_+3],_===0&&W===!0&&ye.copy(w);break;case"T":for(y=Qe(M),_=0,D=y.length;_<D;_+=2){var ie=Ye(w.x,$.x),ue=Ye(w.y,$.y);B.quadraticCurveTo(ie,ue,y[_+0],y[_+1]),$.x=ie,$.y=ue,w.x=y[_+0],w.y=y[_+1],_===0&&W===!0&&ye.copy(w)}break;case"A":for(y=Qe(M),_=0,D=y.length;_<D;_+=7)if(y[_+5]!=w.x||y[_+6]!=w.y){var se=w.clone();w.x=y[_+5],w.y=y[_+6],$.x=w.x,$.y=w.y,Pe(B,y[_],y[_+1],y[_+2],y[_+3],y[_+4],se,w),_===0&&W===!0&&ye.copy(w)}break;case"m":for(y=Qe(M),_=0,D=y.length;_<D;_+=2)w.x+=y[_+0],w.y+=y[_+1],$.x=w.x,$.y=w.y,_===0?B.moveTo(w.x,w.y):B.lineTo(w.x,w.y),_===0&&W===!0&&ye.copy(w);break;case"h":for(y=Qe(M),_=0,D=y.length;_<D;_++)w.x+=y[_],$.x=w.x,$.y=w.y,B.lineTo(w.x,w.y),_===0&&W===!0&&ye.copy(w);break;case"v":for(y=Qe(M),_=0,D=y.length;_<D;_++)w.y+=y[_],$.x=w.x,$.y=w.y,B.lineTo(w.x,w.y),_===0&&W===!0&&ye.copy(w);break;case"l":for(y=Qe(M),_=0,D=y.length;_<D;_+=2)w.x+=y[_+0],w.y+=y[_+1],$.x=w.x,$.y=w.y,B.lineTo(w.x,w.y),_===0&&W===!0&&ye.copy(w);break;case"c":for(y=Qe(M),_=0,D=y.length;_<D;_+=6)B.bezierCurveTo(w.x+y[_+0],w.y+y[_+1],w.x+y[_+2],w.y+y[_+3],w.x+y[_+4],w.y+y[_+5]),$.x=w.x+y[_+2],$.y=w.y+y[_+3],w.x+=y[_+4],w.y+=y[_+5],_===0&&W===!0&&ye.copy(w);break;case"s":for(y=Qe(M),_=0,D=y.length;_<D;_+=4)B.bezierCurveTo(Ye(w.x,$.x),Ye(w.y,$.y),w.x+y[_+0],w.y+y[_+1],w.x+y[_+2],w.y+y[_+3]),$.x=w.x+y[_+0],$.y=w.y+y[_+1],w.x+=y[_+2],w.y+=y[_+3],_===0&&W===!0&&ye.copy(w);break;case"q":for(y=Qe(M),_=0,D=y.length;_<D;_+=4)B.quadraticCurveTo(w.x+y[_+0],w.y+y[_+1],w.x+y[_+2],w.y+y[_+3]),$.x=w.x+y[_+0],$.y=w.y+y[_+1],w.x+=y[_+2],w.y+=y[_+3],_===0&&W===!0&&ye.copy(w);break;case"t":for(y=Qe(M),_=0,D=y.length;_<D;_+=2)ie=Ye(w.x,$.x),ue=Ye(w.y,$.y),B.quadraticCurveTo(ie,ue,w.x+y[_+0],w.y+y[_+1]),$.x=ie,$.y=ue,w.x=w.x+y[_+0],w.y=w.y+y[_+1],_===0&&W===!0&&ye.copy(w);break;case"a":for(y=Qe(M),_=0,D=y.length;_<D;_+=7)(y[_+5]!=0||y[_+6]!=0)&&(se=w.clone(),w.x+=y[_+5],w.y+=y[_+6],$.x=w.x,$.y=w.y,Pe(B,y[_],y[_+1],y[_+2],y[_+3],y[_+4],se,w),_===0&&W===!0&&ye.copy(w));break;case"Z":case"z":B.currentPath.autoClose=!0,B.currentPath.curves.length>0&&(w.copy(ye),B.currentPath.currentPoint.copy(w),_e=!0);break;default:console.warn(Ce)}W=!1}return B}(re));break;case"rect":q=Ee(re,q),Oe=function(H){var B=Ne(H.getAttribute("x")||0),w=Ne(H.getAttribute("y")||0),$=Ne(H.getAttribute("rx")||0),ye=Ne(H.getAttribute("ry")||0),_e=Ne(H.getAttribute("width")),W=Ne(H.getAttribute("height")),ae=new Q.ShapePath;return ae.moveTo(B+2*$,w),ae.lineTo(B+_e-2*$,w),($!==0||ye!==0)&&ae.bezierCurveTo(B+_e,w,B+_e,w,B+_e,w+2*ye),ae.lineTo(B+_e,w+W-2*ye),($!==0||ye!==0)&&ae.bezierCurveTo(B+_e,w+W,B+_e,w+W,B+_e-2*$,w+W),ae.lineTo(B+2*$,w+W),($!==0||ye!==0)&&ae.bezierCurveTo(B,w+W,B,w+W,B,w+W-2*ye),ae.lineTo(B,w+2*ye),($!==0||ye!==0)&&ae.bezierCurveTo(B,w,B,w,B+2*$,w),ae}(re);break;case"polygon":q=Ee(re,q),Oe=function(H){function B(ye,_e,W){var ae=Ne(_e),pe=Ne(W);$===0?w.moveTo(ae,pe):w.lineTo(ae,pe),$++}var w=new Q.ShapePath,$=0;return H.getAttribute("points").replace(/(-?[\d\.?]+)[,|\s](-?[\d\.?]+)/g,B),w.currentPath.autoClose=!0,w}(re);break;case"polyline":q=Ee(re,q),Oe=function(H){function B(ye,_e,W){var ae=Ne(_e),pe=Ne(W);$===0?w.moveTo(ae,pe):w.lineTo(ae,pe),$++}var w=new Q.ShapePath,$=0;return H.getAttribute("points").replace(/(-?[\d\.?]+)[,|\s](-?[\d\.?]+)/g,B),w.currentPath.autoClose=!1,w}(re);break;case"circle":q=Ee(re,q),Oe=function(H){var B=Ne(H.getAttribute("cx")),w=Ne(H.getAttribute("cy")),$=Ne(H.getAttribute("r")),ye=new Q.Path;ye.absarc(B,w,$,0,2*Math.PI);var _e=new Q.ShapePath;return _e.subPaths.push(ye),_e}(re);break;case"ellipse":q=Ee(re,q),Oe=function(H){var B=Ne(H.getAttribute("cx")),w=Ne(H.getAttribute("cy")),$=Ne(H.getAttribute("rx")),ye=Ne(H.getAttribute("ry")),_e=new Q.Path;_e.absellipse(B,w,$,ye,0,2*Math.PI);var W=new Q.ShapePath;return W.subPaths.push(_e),W}(re);break;case"line":q=Ee(re,q),Oe=function(H){var B=Ne(H.getAttribute("x1")),w=Ne(H.getAttribute("y1")),$=Ne(H.getAttribute("x2")),ye=Ne(H.getAttribute("y2")),_e=new Q.ShapePath;return _e.moveTo(B,w),_e.lineTo($,ye),_e.currentPath.autoClose=!1,_e}(re);break;case"defs":Ze=!1;break;case"use":q=Ee(re,q);var O=re.href.baseVal.substring(1),C=re.viewportElement.getElementById(O);C?de(C,q):console.warn("SVGLoader: 'use node' references non-existent node id: "+O)}if(Oe&&(q.fill!==void 0&&q.fill!=="none"&&Oe.color.setStyle(q.fill),function(H,B){function w(Ce){Kt.set(Ce.x,Ce.y,1).applyMatrix3(B),Ce.set(Kt.x,Kt.y)}for(var $=function(Ce){return Ce.elements[1]!==0||Ce.elements[3]!==0}(B),ye=H.subPaths,_e=0,W=ye.length;_e<W;_e++)for(var ae=ye[_e].curves,pe=0;pe<ae.length;pe++){var Fe=ae[pe];Fe.isLineCurve?(w(Fe.v1),w(Fe.v2)):Fe.isCubicBezierCurve?(w(Fe.v0),w(Fe.v1),w(Fe.v2),w(Fe.v3)):Fe.isQuadraticBezierCurve?(w(Fe.v0),w(Fe.v1),w(Fe.v2)):Fe.isEllipseCurve&&($&&console.warn("SVGLoader: Elliptic arc or ellipse rotation or skewing is not implemented."),Yt.set(Fe.aX,Fe.aY),w(Yt),Fe.aX=Yt.x,Fe.aY=Yt.y,Fe.xRadius*=at(B),Fe.yRadius*=$e(B))}}(Oe,Zt),ut.push(Oe),Oe.userData={node:re,style:q}),Ze)for(var V=re.childNodes,j=0;j<V.length;j++)de(V[j],q);he&&(Ot.pop(),Ot.length>0?Zt.copy(Ot[Ot.length-1]):Zt.identity())}}(be.documentElement,{fill:"#000",fillOpacity:1,strokeOpacity:1,strokeWidth:1,strokeLineJoin:"miter",strokeLineCap:"butt",strokeMiterLimit:4}),{paths:ut,xml:be.documentElement}}}),oe.getStrokeStyle=function(me,Te,Pe,Re,Ee){return{strokeColor:Te=Te!==void 0?Te:"#000",strokeWidth:me=me!==void 0?me:1,strokeLineJoin:Pe=Pe!==void 0?Pe:"miter",strokeLineCap:Re=Re!==void 0?Re:"butt",strokeMiterLimit:Ee=Ee!==void 0?Ee:4}},oe.pointsToStroke=function(me,Te,Pe,Re){var Ee=[],Ye=[],Qe=[];if(oe.pointsToStrokeWithBuffers(me,Te,Pe,Re,Ee,Ye,Qe)===0)return null;var lt=new Q.BufferGeometry;return lt.setAttribute("position",new Q.Float32BufferAttribute(Ee,3)),lt.setAttribute("normal",new Q.Float32BufferAttribute(Ye,3)),lt.setAttribute("uv",new Q.Float32BufferAttribute(Qe,2)),lt},oe.pointsToStrokeWithBuffers=(f=new Q.Vector2,A=new Q.Vector2,P=new Q.Vector2,I=new Q.Vector2,E=new Q.Vector2,U=new Q.Vector2,G=new Q.Vector2,Y=new Q.Vector2,we=new Q.Vector2,Se=new Q.Vector2,Me=new Q.Vector2,T=new Q.Vector2,Z=new Q.Vector2,J=new Q.Vector2,L=new Q.Vector2,N=new Q.Vector2,X=new Q.Vector2,function(me,Te,Pe,Re,Ee,Ye,Qe,lt){Pe=Pe!==void 0?Pe:12,Re=Re!==void 0?Re:.001,lt=lt!==void 0?lt:0;var ot=(me=function(pe){for(var Fe=!1,Ce=1,v=pe.length-1;Ce<v;Ce++)if(pe[Ce].distanceTo(pe[Ce+1])<Re){Fe=!0;break}if(!Fe)return pe;var M=[];for(M.push(pe[0]),Ce=1,v=pe.length-1;Ce<v;Ce++)pe[Ce].distanceTo(pe[Ce+1])>=Re&&M.push(pe[Ce]);return M.push(pe[pe.length-1]),M}(me)).length;if(ot<2)return 0;var Ne,at,$e,ut,pt,Ot=me[0].equals(me[ot-1]),It=me[0],Bt=Te.strokeWidth/2,Wt=1/(ot-1),Tt=0,Yt=!1,Kt=0,Zt=3*lt,be=2*lt;B(me[0],me[1],f).multiplyScalar(Bt),Y.copy(me[0]).sub(f),we.copy(me[0]).add(f),Se.copy(Y),Me.copy(we);for(var de=1;de<ot;de++){Ne=me[de],at=de===ot-1?Ot?me[1]:void 0:me[de+1];var re=f;B(It,Ne,re),P.copy(re).multiplyScalar(Bt),T.copy(Ne).sub(P),Z.copy(Ne).add(P);var q=Tt+Wt;if($e=!1,at!==void 0){B(Ne,at,A),P.copy(A).multiplyScalar(Bt),J.copy(Ne).sub(P),L.copy(Ne).add(P),ut=!0,P.subVectors(at,It),re.dot(P)<0&&(ut=!1),de===1&&(Yt=ut),P.subVectors(at,Ne),P.normalize();var he=Math.abs(re.dot(P));if(he!==0){var Ze=Bt/he;P.multiplyScalar(-Ze),I.subVectors(Ne,It),E.copy(I).setLength(Ze).add(P),N.copy(E).negate();var Oe=E.length(),O=I.length();I.divideScalar(O),U.subVectors(at,Ne);var C=U.length();switch(U.divideScalar(C),I.dot(N)<O&&U.dot(N)<C&&($e=!0),X.copy(E).add(Ne),N.add(Ne),pt=!1,$e?ut?(L.copy(N),Z.copy(N)):(J.copy(N),T.copy(N)):ye(),Te.strokeLineJoin){case"bevel":_e(ut,$e,q);break;case"round":W(ut,$e),ut?$(Ne,T,J,q,0):$(Ne,L,Z,q,1);break;case"miter":case"miter-clip":default:var V=Bt*Te.strokeMiterLimit/Oe;if(V<1){if(Te.strokeLineJoin!=="miter-clip"){_e(ut,$e,q);break}W(ut,$e),ut?(U.subVectors(X,T).multiplyScalar(V).add(T),G.subVectors(X,J).multiplyScalar(V).add(J),w(T,q,0),w(U,q,0),w(Ne,q,.5),w(Ne,q,.5),w(U,q,0),w(G,q,0),w(Ne,q,.5),w(G,q,0),w(J,q,0)):(U.subVectors(X,Z).multiplyScalar(V).add(Z),G.subVectors(X,L).multiplyScalar(V).add(L),w(Z,q,1),w(U,q,1),w(Ne,q,.5),w(Ne,q,.5),w(U,q,1),w(G,q,1),w(Ne,q,.5),w(G,q,1),w(L,q,1))}else $e?(ut?(w(we,Tt,1),w(Y,Tt,0),w(X,q,0),w(we,Tt,1),w(X,q,0),w(N,q,1)):(w(we,Tt,1),w(Y,Tt,0),w(X,q,1),w(Y,Tt,0),w(N,q,0),w(X,q,1)),ut?J.copy(X):L.copy(X)):ut?(w(T,q,0),w(X,q,0),w(Ne,q,.5),w(Ne,q,.5),w(X,q,0),w(J,q,0)):(w(Z,q,1),w(X,q,1),w(Ne,q,.5),w(Ne,q,.5),w(X,q,1),w(L,q,1)),pt=!0}}else ye()}else ye();Ot||de!==ot-1||ae(me[0],Se,Me,ut,!0,Tt),Tt=q,It=Ne,Y.copy(J),we.copy(L)}if(Ot){if($e&&Ee){var j=X,H=N;Yt!==ut&&(j=N,H=X),ut?(pt||Yt)&&(H.toArray(Ee,0),H.toArray(Ee,9),pt&&j.toArray(Ee,3)):!pt&&Yt||(H.toArray(Ee,3),H.toArray(Ee,9),pt&&j.toArray(Ee,0))}}else ae(Ne,T,Z,ut,!1,q);return Kt;function B(pe,Fe,Ce){return Ce.subVectors(Fe,pe),Ce.set(-Ce.y,Ce.x).normalize()}function w(pe,Fe,Ce){Ee&&(Ee[Zt]=pe.x,Ee[Zt+1]=pe.y,Ee[Zt+2]=0,Ye&&(Ye[Zt]=0,Ye[Zt+1]=0,Ye[Zt+2]=1),Zt+=3,Qe&&(Qe[be]=Fe,Qe[be+1]=Ce,be+=2)),Kt+=3}function $(pe,Fe,Ce,v,M){f.copy(Fe).sub(pe).normalize(),A.copy(Ce).sub(pe).normalize();var y=Math.PI,_=f.dot(A);Math.abs(_)<1&&(y=Math.abs(Math.acos(_))),y/=Pe,P.copy(Fe);for(var D=0,ie=Pe-1;D<ie;D++)I.copy(P).rotateAround(pe,y),w(P,v,M),w(I,v,M),w(pe,v,.5),P.copy(I);w(I,v,M),w(Ce,v,M),w(pe,v,.5)}function ye(){w(we,Tt,1),w(Y,Tt,0),w(T,q,0),w(we,Tt,1),w(T,q,1),w(Z,q,0)}function _e(pe,Fe,Ce){Fe?pe?(w(we,Tt,1),w(Y,Tt,0),w(T,q,0),w(we,Tt,1),w(T,q,0),w(N,q,1),w(T,Ce,0),w(J,Ce,0),w(N,Ce,.5)):(w(we,Tt,1),w(Y,Tt,0),w(Z,q,1),w(Y,Tt,0),w(N,q,0),w(Z,q,1),w(Z,Ce,1),w(L,Ce,0),w(N,Ce,.5)):pe?(w(T,Ce,0),w(J,Ce,0),w(Ne,Ce,.5)):(w(Z,Ce,1),w(L,Ce,0),w(Ne,Ce,.5))}function W(pe,Fe){Fe&&(pe?(w(we,Tt,1),w(Y,Tt,0),w(T,q,0),w(we,Tt,1),w(T,q,0),w(N,q,1),w(T,Tt,0),w(Ne,q,.5),w(N,q,1),w(Ne,q,.5),w(J,Tt,0),w(N,q,1)):(w(we,Tt,1),w(Y,Tt,0),w(Z,q,1),w(Y,Tt,0),w(N,q,0),w(Z,q,1),w(Z,Tt,1),w(N,q,0),w(Ne,q,.5),w(Ne,q,.5),w(N,q,0),w(L,Tt,1)))}function ae(pe,Fe,Ce,v,M,y){switch(Te.strokeLineCap){case"round":M?$(pe,Ce,Fe,y,.5):$(pe,Fe,Ce,y,.5);break;case"square":if(M)f.subVectors(Fe,pe),A.set(f.y,-f.x),P.addVectors(f,A).add(pe),I.subVectors(A,f).add(pe),v?(P.toArray(Ee,3),I.toArray(Ee,0),I.toArray(Ee,9)):(P.toArray(Ee,3),P.toArray(Ee,9),I.toArray(Ee,0));else{f.subVectors(Ce,pe),A.set(f.y,-f.x),P.addVectors(f,A).add(pe),I.subVectors(A,f).add(pe);var _=Ee.length;v?(P.toArray(Ee,_-3),I.toArray(Ee,_-6),I.toArray(Ee,_-12)):(P.toArray(Ee,_-6),I.toArray(Ee,_-3),I.toArray(Ee,_-12))}}}})},function(rt,h,l){l.r(h),l.d(h,"VRButton",function(){return f});class f{static createButton(A,P){P&&console.error('THREE.VRButton: The "options" parameter has been removed. Please set the reference space type via renderer.xr.setReferenceSpaceType() instead.');const I=document.createElement("button");function E(){I.style.display="",I.style.cursor="auto",I.style.left="calc(50% - 75px)",I.style.width="150px",I.onmouseenter=null,I.onmouseleave=null,I.onclick=null,I.textContent="VR NOT SUPPORTED"}function U(G){G.style.position="absolute",G.style.bottom="20px",G.style.padding="12px 6px",G.style.border="1px solid #fff",G.style.borderRadius="4px",G.style.background="rgba(0,0,0,0.1)",G.style.color="#fff",G.style.font="normal 13px sans-serif",G.style.textAlign="center",G.style.opacity="0.5",G.style.outline="none",G.style.zIndex="999"}if("xr"in navigator)return I.id="VRButton",I.style.display="none",U(I),navigator.xr.isSessionSupported("immersive-vr").then(function(G){G?function(){let Y=null;function we(Me){Me.addEventListener("end",Se),A.xr.setSession(Me),I.textContent="EXIT VR",Y=Me}function Se(){Y.removeEventListener("end",Se),I.textContent="ENTER VR",Y=null}I.style.display="",I.style.cursor="pointer",I.style.left="calc(50% - 50px)",I.style.width="100px",I.textContent="ENTER VR",I.onmouseenter=function(){I.style.opacity="1.0"},I.onmouseleave=function(){I.style.opacity="0.5"},I.onclick=function(){if(Y===null){const Me={optionalFeatures:["local-floor","bounded-floor","hand-tracking"]};navigator.xr.requestSession("immersive-vr",Me).then(we)}else Y.end()}}():E()}),I;{const G=document.createElement("a");return window.isSecureContext===!1?(G.href=document.location.href.replace(/^http:/,"https:"),G.innerHTML="WEBXR NEEDS HTTPS"):(G.href="https://immersiveweb.dev/",G.innerHTML="WEBXR NOT AVAILABLE"),G.style.left="calc(50% - 90px)",G.style.width="180px",G.style.textDecoration="none",U(G),G}}}},function(rt,h,l){l.r(h),l.d(h,"Sky",function(){return A});var f=l(0),A=function(){var P=A.SkyShader,I=new f.ShaderMaterial({name:"SkyShader",fragmentShader:P.fragmentShader,vertexShader:P.vertexShader,uniforms:f.UniformsUtils.clone(P.uniforms),side:f.BackSide,depthWrite:!1});f.Mesh.call(this,new f.BoxBufferGeometry(1,1,1),I)};A.prototype=Object.create(f.Mesh.prototype),A.SkyShader={uniforms:{turbidity:{value:2},rayleigh:{value:1},mieCoefficient:{value:.005},mieDirectionalG:{value:.8},sunPosition:{value:new f.Vector3},up:{value:new f.Vector3(0,1,0)}},vertexShader:["uniform vec3 sunPosition;","uniform float rayleigh;","uniform float turbidity;","uniform float mieCoefficient;","uniform vec3 up;","varying vec3 vWorldPosition;","varying vec3 vSunDirection;","varying float vSunfade;","varying vec3 vBetaR;","varying vec3 vBetaM;","varying float vSunE;","const float e = 2.71828182845904523536028747135266249775724709369995957;","const float pi = 3.141592653589793238462643383279502884197169;","const vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );","const vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );","const float v = 4.0;","const vec3 K = vec3( 0.686, 0.678, 0.666 );","const vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );","const float cutoffAngle = 1.6110731556870734;","const float steepness = 1.5;","const float EE = 1000.0;","float sunIntensity( float zenithAngleCos ) {","	zenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );","	return EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );","}","vec3 totalMie( float T ) {","	float c = ( 0.2 * T ) * 10E-18;","	return 0.434 * c * MieConst;","}","void main() {","	vec4 worldPosition = modelMatrix * vec4( position, 1.0 );","	vWorldPosition = worldPosition.xyz;","	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","	gl_Position.z = gl_Position.w;","	vSunDirection = normalize( sunPosition );","	vSunE = sunIntensity( dot( vSunDirection, up ) );","	vSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );","	float rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );","	vBetaR = totalRayleigh * rayleighCoefficient;","	vBetaM = totalMie( turbidity ) * mieCoefficient;","}"].join(`
`),fragmentShader:["varying vec3 vWorldPosition;","varying vec3 vSunDirection;","varying float vSunfade;","varying vec3 vBetaR;","varying vec3 vBetaM;","varying float vSunE;","uniform float mieDirectionalG;","uniform vec3 up;","const vec3 cameraPos = vec3( 0.0, 0.0, 0.0 );","const float pi = 3.141592653589793238462643383279502884197169;","const float n = 1.0003;","const float N = 2.545E25;","const float rayleighZenithLength = 8.4E3;","const float mieZenithLength = 1.25E3;","const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;","const float THREE_OVER_SIXTEENPI = 0.05968310365946075;","const float ONE_OVER_FOURPI = 0.07957747154594767;","float rayleighPhase( float cosTheta ) {","	return THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );","}","float hgPhase( float cosTheta, float g ) {","	float g2 = pow( g, 2.0 );","	float inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );","	return ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );","}","void main() {","	vec3 direction = normalize( vWorldPosition - cameraPos );","	float zenithAngle = acos( max( 0.0, dot( up, direction ) ) );","	float inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );","	float sR = rayleighZenithLength * inverse;","	float sM = mieZenithLength * inverse;","	vec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );","	float cosTheta = dot( direction, vSunDirection );","	float rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );","	vec3 betaRTheta = vBetaR * rPhase;","	float mPhase = hgPhase( cosTheta, mieDirectionalG );","	vec3 betaMTheta = vBetaM * mPhase;","	vec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );","	Lin *= mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );","	float theta = acos( direction.y ); // elevation --> y-axis, [-pi/2, pi/2]","	float phi = atan( direction.z, direction.x ); // azimuth --> x-axis [-pi/2, pi/2]","	vec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );","	vec3 L0 = vec3( 0.1 ) * Fex;","	float sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );","	L0 += ( vSunE * 19000.0 * Fex ) * sundisk;","	vec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );","	vec3 retColor = pow( texColor, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );","	gl_FragColor = vec4( retColor, 1.0 );","#include <tonemapping_fragment>","#include <encodings_fragment>","}"].join(`
`)}},function(rt,h,l){l.r(h),l.d(h,"OrbitControls",function(){return A}),l.d(h,"MapControls",function(){return P});var f=l(0),A=function(I,E){var U,G,Y,we,Se,Me;E===void 0&&console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.'),E===document&&console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'),this.object=I,this.domElement=E,this.enabled=!0,this.target=new f.Vector3,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=.05,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.enablePan=!0,this.panSpeed=1,this.screenSpacePanning=!0,this.keyPanSpeed=7,this.autoRotate=!1,this.autoRotateSpeed=2,this.enableKeys=!0,this.keys={LEFT:37,UP:38,RIGHT:39,BOTTOM:40},this.mouseButtons={LEFT:f.MOUSE.ROTATE,MIDDLE:f.MOUSE.DOLLY,RIGHT:f.MOUSE.PAN},this.touches={ONE:f.TOUCH.ROTATE,TWO:f.TOUCH.DOLLY_PAN},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this.getPolarAngle=function(){return oe.phi},this.getAzimuthalAngle=function(){return oe.theta},this.saveState=function(){T.target0.copy(T.target),T.position0.copy(T.object.position),T.zoom0=T.object.zoom},this.reset=function(){T.target.copy(T.target0),T.object.position.copy(T.position0),T.object.zoom=T.zoom0,T.object.updateProjectionMatrix(),T.dispatchEvent(Z),T.update(),X=N.NONE},this.update=(U=new f.Vector3,G=new f.Quaternion().setFromUnitVectors(I.up,new f.Vector3(0,1,0)),Y=G.clone().invert(),we=new f.Vector3,Se=new f.Quaternion,Me=2*Math.PI,function(){var W=T.object.position;U.copy(W).sub(T.target),U.applyQuaternion(G),oe.setFromVector3(U),T.autoRotate&&X===N.NONE&&Ot(2*Math.PI/60/60*T.autoRotateSpeed),T.enableDamping?(oe.theta+=me.theta*T.dampingFactor,oe.phi+=me.phi*T.dampingFactor):(oe.theta+=me.theta,oe.phi+=me.phi);var ae=T.minAzimuthAngle,pe=T.maxAzimuthAngle;return isFinite(ae)&&isFinite(pe)&&(ae<-Math.PI?ae+=Me:ae>Math.PI&&(ae-=Me),pe<-Math.PI?pe+=Me:pe>Math.PI&&(pe-=Me),oe.theta=ae<=pe?Math.max(ae,Math.min(pe,oe.theta)):oe.theta>(ae+pe)/2?Math.max(ae,oe.theta):Math.min(pe,oe.theta)),oe.phi=Math.max(T.minPolarAngle,Math.min(T.maxPolarAngle,oe.phi)),oe.makeSafe(),oe.radius*=Te,oe.radius=Math.max(T.minDistance,Math.min(T.maxDistance,oe.radius)),T.enableDamping===!0?T.target.addScaledVector(Pe,T.dampingFactor):T.target.add(Pe),U.setFromSpherical(oe),U.applyQuaternion(Y),W.copy(T.target).add(U),T.object.lookAt(T.target),T.enableDamping===!0?(me.theta*=1-T.dampingFactor,me.phi*=1-T.dampingFactor,Pe.multiplyScalar(1-T.dampingFactor)):(me.set(0,0,0),Pe.set(0,0,0)),Te=1,!!(Re||we.distanceToSquared(T.object.position)>Q||8*(1-Se.dot(T.object.quaternion))>Q)&&(T.dispatchEvent(Z),we.copy(T.object.position),Se.copy(T.object.quaternion),Re=!1,!0)}),this.dispose=function(){T.domElement.removeEventListener("contextmenu",_e,!1),T.domElement.removeEventListener("pointerdown",C,!1),T.domElement.removeEventListener("wheel",H,!1),T.domElement.removeEventListener("touchstart",w,!1),T.domElement.removeEventListener("touchend",ye,!1),T.domElement.removeEventListener("touchmove",$,!1),T.domElement.ownerDocument.removeEventListener("pointermove",V,!1),T.domElement.ownerDocument.removeEventListener("pointerup",j,!1),T.domElement.removeEventListener("keydown",B,!1)};var T=this,Z={type:"change"},J={type:"start"},L={type:"end"},N={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6},X=N.NONE,Q=1e-6,oe=new f.Spherical,me=new f.Spherical,Te=1,Pe=new f.Vector3,Re=!1,Ee=new f.Vector2,Ye=new f.Vector2,Qe=new f.Vector2,lt=new f.Vector2,ot=new f.Vector2,Ne=new f.Vector2,at=new f.Vector2,$e=new f.Vector2,ut=new f.Vector2;function pt(){return Math.pow(.95,T.zoomSpeed)}function Ot(W){me.theta-=W}function It(W){me.phi-=W}var Bt,Wt=(Bt=new f.Vector3,function(W,ae){Bt.setFromMatrixColumn(ae,0),Bt.multiplyScalar(-W),Pe.add(Bt)}),Tt=function(){var W=new f.Vector3;return function(ae,pe){T.screenSpacePanning===!0?W.setFromMatrixColumn(pe,1):(W.setFromMatrixColumn(pe,0),W.crossVectors(T.object.up,W)),W.multiplyScalar(ae),Pe.add(W)}}(),Yt=function(){var W=new f.Vector3;return function(ae,pe){var Fe=T.domElement;if(T.object.isPerspectiveCamera){var Ce=T.object.position;W.copy(Ce).sub(T.target);var v=W.length();v*=Math.tan(T.object.fov/2*Math.PI/180),Wt(2*ae*v/Fe.clientHeight,T.object.matrix),Tt(2*pe*v/Fe.clientHeight,T.object.matrix)}else T.object.isOrthographicCamera?(Wt(ae*(T.object.right-T.object.left)/T.object.zoom/Fe.clientWidth,T.object.matrix),Tt(pe*(T.object.top-T.object.bottom)/T.object.zoom/Fe.clientHeight,T.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),T.enablePan=!1)}}();function Kt(W){T.object.isPerspectiveCamera?Te/=W:T.object.isOrthographicCamera?(T.object.zoom=Math.max(T.minZoom,Math.min(T.maxZoom,T.object.zoom*W)),T.object.updateProjectionMatrix(),Re=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),T.enableZoom=!1)}function Zt(W){T.object.isPerspectiveCamera?Te*=W:T.object.isOrthographicCamera?(T.object.zoom=Math.max(T.minZoom,Math.min(T.maxZoom,T.object.zoom/W)),T.object.updateProjectionMatrix(),Re=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),T.enableZoom=!1)}function be(W){Ee.set(W.clientX,W.clientY)}function de(W){lt.set(W.clientX,W.clientY)}function re(W){if(W.touches.length==1)Ee.set(W.touches[0].pageX,W.touches[0].pageY);else{var ae=.5*(W.touches[0].pageX+W.touches[1].pageX),pe=.5*(W.touches[0].pageY+W.touches[1].pageY);Ee.set(ae,pe)}}function q(W){if(W.touches.length==1)lt.set(W.touches[0].pageX,W.touches[0].pageY);else{var ae=.5*(W.touches[0].pageX+W.touches[1].pageX),pe=.5*(W.touches[0].pageY+W.touches[1].pageY);lt.set(ae,pe)}}function he(W){var ae=W.touches[0].pageX-W.touches[1].pageX,pe=W.touches[0].pageY-W.touches[1].pageY,Fe=Math.sqrt(ae*ae+pe*pe);at.set(0,Fe)}function Ze(W){if(W.touches.length==1)Ye.set(W.touches[0].pageX,W.touches[0].pageY);else{var ae=.5*(W.touches[0].pageX+W.touches[1].pageX),pe=.5*(W.touches[0].pageY+W.touches[1].pageY);Ye.set(ae,pe)}Qe.subVectors(Ye,Ee).multiplyScalar(T.rotateSpeed);var Fe=T.domElement;Ot(2*Math.PI*Qe.x/Fe.clientHeight),It(2*Math.PI*Qe.y/Fe.clientHeight),Ee.copy(Ye)}function Oe(W){if(W.touches.length==1)ot.set(W.touches[0].pageX,W.touches[0].pageY);else{var ae=.5*(W.touches[0].pageX+W.touches[1].pageX),pe=.5*(W.touches[0].pageY+W.touches[1].pageY);ot.set(ae,pe)}Ne.subVectors(ot,lt).multiplyScalar(T.panSpeed),Yt(Ne.x,Ne.y),lt.copy(ot)}function O(W){var ae=W.touches[0].pageX-W.touches[1].pageX,pe=W.touches[0].pageY-W.touches[1].pageY,Fe=Math.sqrt(ae*ae+pe*pe);$e.set(0,Fe),ut.set(0,Math.pow($e.y/at.y,T.zoomSpeed)),Kt(ut.y),at.copy($e)}function C(W){if(T.enabled!==!1)switch(W.pointerType){case"mouse":case"pen":!function(ae){var pe;switch(ae.preventDefault(),T.domElement.focus?T.domElement.focus():window.focus(),ae.button){case 0:pe=T.mouseButtons.LEFT;break;case 1:pe=T.mouseButtons.MIDDLE;break;case 2:pe=T.mouseButtons.RIGHT;break;default:pe=-1}switch(pe){case f.MOUSE.DOLLY:if(T.enableZoom===!1)return;!function(Fe){at.set(Fe.clientX,Fe.clientY)}(ae),X=N.DOLLY;break;case f.MOUSE.ROTATE:if(ae.ctrlKey||ae.metaKey||ae.shiftKey){if(T.enablePan===!1)return;de(ae),X=N.PAN}else{if(T.enableRotate===!1)return;be(ae),X=N.ROTATE}break;case f.MOUSE.PAN:if(ae.ctrlKey||ae.metaKey||ae.shiftKey){if(T.enableRotate===!1)return;be(ae),X=N.ROTATE}else{if(T.enablePan===!1)return;de(ae),X=N.PAN}break;default:X=N.NONE}X!==N.NONE&&(T.domElement.ownerDocument.addEventListener("pointermove",V,!1),T.domElement.ownerDocument.addEventListener("pointerup",j,!1),T.dispatchEvent(J))}(W)}}function V(W){if(T.enabled!==!1)switch(W.pointerType){case"mouse":case"pen":!function(ae){if(T.enabled===!1)return;switch(ae.preventDefault(),X){case N.ROTATE:if(T.enableRotate===!1)return;!function(pe){Ye.set(pe.clientX,pe.clientY),Qe.subVectors(Ye,Ee).multiplyScalar(T.rotateSpeed);var Fe=T.domElement;Ot(2*Math.PI*Qe.x/Fe.clientHeight),It(2*Math.PI*Qe.y/Fe.clientHeight),Ee.copy(Ye),T.update()}(ae);break;case N.DOLLY:if(T.enableZoom===!1)return;!function(pe){$e.set(pe.clientX,pe.clientY),ut.subVectors($e,at),ut.y>0?Kt(pt()):ut.y<0&&Zt(pt()),at.copy($e),T.update()}(ae);break;case N.PAN:if(T.enablePan===!1)return;!function(pe){ot.set(pe.clientX,pe.clientY),Ne.subVectors(ot,lt).multiplyScalar(T.panSpeed),Yt(Ne.x,Ne.y),lt.copy(ot),T.update()}(ae)}}(W)}}function j(W){switch(W.pointerType){case"mouse":case"pen":!function(ae){if(T.domElement.ownerDocument.removeEventListener("pointermove",V,!1),T.domElement.ownerDocument.removeEventListener("pointerup",j,!1),T.enabled===!1)return;T.dispatchEvent(L),X=N.NONE}()}}function H(W){T.enabled===!1||T.enableZoom===!1||X!==N.NONE&&X!==N.ROTATE||(W.preventDefault(),W.stopPropagation(),T.dispatchEvent(J),function(ae){ae.deltaY<0?Zt(pt()):ae.deltaY>0&&Kt(pt()),T.update()}(W),T.dispatchEvent(L))}function B(W){T.enabled!==!1&&T.enableKeys!==!1&&T.enablePan!==!1&&function(ae){var pe=!1;switch(ae.keyCode){case T.keys.UP:Yt(0,T.keyPanSpeed),pe=!0;break;case T.keys.BOTTOM:Yt(0,-T.keyPanSpeed),pe=!0;break;case T.keys.LEFT:Yt(T.keyPanSpeed,0),pe=!0;break;case T.keys.RIGHT:Yt(-T.keyPanSpeed,0),pe=!0}pe&&(ae.preventDefault(),T.update())}(W)}function w(W){if(T.enabled!==!1){switch(W.preventDefault(),W.touches.length){case 1:switch(T.touches.ONE){case f.TOUCH.ROTATE:if(T.enableRotate===!1)return;re(W),X=N.TOUCH_ROTATE;break;case f.TOUCH.PAN:if(T.enablePan===!1)return;q(W),X=N.TOUCH_PAN;break;default:X=N.NONE}break;case 2:switch(T.touches.TWO){case f.TOUCH.DOLLY_PAN:if(T.enableZoom===!1&&T.enablePan===!1)return;!function(ae){T.enableZoom&&he(ae),T.enablePan&&q(ae)}(W),X=N.TOUCH_DOLLY_PAN;break;case f.TOUCH.DOLLY_ROTATE:if(T.enableZoom===!1&&T.enableRotate===!1)return;!function(ae){T.enableZoom&&he(ae),T.enableRotate&&re(ae)}(W),X=N.TOUCH_DOLLY_ROTATE;break;default:X=N.NONE}break;default:X=N.NONE}X!==N.NONE&&T.dispatchEvent(J)}}function $(W){if(T.enabled!==!1)switch(W.preventDefault(),W.stopPropagation(),X){case N.TOUCH_ROTATE:if(T.enableRotate===!1)return;Ze(W),T.update();break;case N.TOUCH_PAN:if(T.enablePan===!1)return;Oe(W),T.update();break;case N.TOUCH_DOLLY_PAN:if(T.enableZoom===!1&&T.enablePan===!1)return;!function(ae){T.enableZoom&&O(ae),T.enablePan&&Oe(ae)}(W),T.update();break;case N.TOUCH_DOLLY_ROTATE:if(T.enableZoom===!1&&T.enableRotate===!1)return;!function(ae){T.enableZoom&&O(ae),T.enableRotate&&Ze(ae)}(W),T.update();break;default:X=N.NONE}}function ye(W){T.enabled!==!1&&(T.dispatchEvent(L),X=N.NONE)}function _e(W){T.enabled!==!1&&W.preventDefault()}T.domElement.addEventListener("contextmenu",_e,!1),T.domElement.addEventListener("pointerdown",C,!1),T.domElement.addEventListener("wheel",H,!1),T.domElement.addEventListener("touchstart",w,!1),T.domElement.addEventListener("touchend",ye,!1),T.domElement.addEventListener("touchmove",$,!1),T.domElement.addEventListener("keydown",B,!1),this.update()};A.prototype=Object.create(f.EventDispatcher.prototype),A.prototype.constructor=A;var P=function(I,E){A.call(this,I,E),this.screenSpacePanning=!1,this.mouseButtons.LEFT=f.MOUSE.PAN,this.mouseButtons.RIGHT=f.MOUSE.ROTATE,this.touches.ONE=f.TOUCH.PAN,this.touches.TWO=f.TOUCH.DOLLY_ROTATE};P.prototype=Object.create(f.EventDispatcher.prototype),P.prototype.constructor=P},function(rt,h,l){l.r(h),l.d(h,"WEBGL",function(){return f});var f={isWebGLAvailable:function(){try{var A=document.createElement("canvas");return!(!window.WebGLRenderingContext||!A.getContext("webgl")&&!A.getContext("experimental-webgl"))}catch(P){return!1}},isWebGL2Available:function(){try{var A=document.createElement("canvas");return!(!window.WebGL2RenderingContext||!A.getContext("webgl2"))}catch(P){return!1}},getWebGLErrorMessage:function(){return this.getErrorMessage(1)},getWebGL2ErrorMessage:function(){return this.getErrorMessage(2)},getErrorMessage:function(A){var P={1:window.WebGLRenderingContext,2:window.WebGL2RenderingContext},I='Your $0 does not seem to support <a href="http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation" style="color:#000">$1</a>',E=document.createElement("div");return E.id="webglmessage",E.style.fontFamily="monospace",E.style.fontSize="13px",E.style.fontWeight="normal",E.style.textAlign="center",E.style.background="#fff",E.style.color="#000",E.style.padding="1.5em",E.style.width="400px",E.style.margin="5em auto 0",I=(I=P[A]?I.replace("$0","graphics card"):I.replace("$0","browser")).replace("$1",{1:"WebGL",2:"WebGL 2"}[A]),E.innerHTML=I,E}}},function(rt,h,l){l.r(h),l.d(h,"RenderPass",function(){return A});var f=l(1),A=function(P,I,E,U,G){f.a.call(this),this.scene=P,this.camera=I,this.overrideMaterial=E,this.clearColor=U,this.clearAlpha=G!==void 0?G:0,this.clear=!0,this.clearDepth=!1,this.needsSwap=!1};A.prototype=Object.assign(Object.create(f.a.prototype),{constructor:A,render:function(P,I,E){var U,G,Y,we=P.autoClear;P.autoClear=!1,this.overrideMaterial!==void 0&&(Y=this.scene.overrideMaterial,this.scene.overrideMaterial=this.overrideMaterial),this.clearColor&&(U=P.getClearColor().getHex(),G=P.getClearAlpha(),P.setClearColor(this.clearColor,this.clearAlpha)),this.clearDepth&&P.clearDepth(),P.setRenderTarget(this.renderToScreen?null:E),this.clear&&P.clear(P.autoClearColor,P.autoClearDepth,P.autoClearStencil),P.render(this.scene,this.camera),this.clearColor&&P.setClearColor(U,G),this.overrideMaterial!==void 0&&(this.scene.overrideMaterial=Y),P.autoClear=we}})},function(rt,h,l){l.r(h),l.d(h,"DotScreenShader",function(){return A});var f=l(0),A={uniforms:{tDiffuse:{value:null},tSize:{value:new f.Vector2(256,256)},center:{value:new f.Vector2(.5,.5)},angle:{value:1.57},scale:{value:1}},vertexShader:["varying vec2 vUv;","void main() {","	vUv = uv;","	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join(`
`),fragmentShader:["uniform vec2 center;","uniform float angle;","uniform float scale;","uniform vec2 tSize;","uniform sampler2D tDiffuse;","varying vec2 vUv;","float pattern() {","	float s = sin( angle ), c = cos( angle );","	vec2 tex = vUv * tSize - center;","	vec2 point = vec2( c * tex.x - s * tex.y, s * tex.x + c * tex.y ) * scale;","	return ( sin( point.x ) * sin( point.y ) ) * 4.0;","}","void main() {","	vec4 color = texture2D( tDiffuse, vUv );","	float average = ( color.r + color.g + color.b ) / 3.0;","	gl_FragColor = vec4( vec3( average * 10.0 - 5.0 + pattern() ), color.a );","}"].join(`
`)}},function(rt,h,l){l.r(h),l.d(h,"FBXLoader",function(){return Zt});var f=l(0),A={},P=A;/** @license zlib.js 2012 - imaya [ https://github.com/imaya/zlib.js ] The MIT License */function I(be,de){var re,q=be.split("."),he=P;for(!(q[0]in he)&&he.execScript&&he.execScript("var "+q[0]);q.length&&(re=q.shift());)q.length||de===void 0?he=he[re]?he[re]:he[re]={}:he[re]=de}var E=typeof Uint8Array!="undefined"&&typeof Uint16Array!="undefined"&&typeof Uint32Array!="undefined"&&typeof DataView!="undefined";function U(be){var de,re,q,he,Ze,Oe,O,C,V,j,H=be.length,B=0,w=Number.POSITIVE_INFINITY;for(C=0;C<H;++C)be[C]>B&&(B=be[C]),be[C]<w&&(w=be[C]);for(de=1<<B,re=new(E?Uint32Array:Array)(de),q=1,he=0,Ze=2;q<=B;){for(C=0;C<H;++C)if(be[C]===q){for(Oe=0,O=he,V=0;V<q;++V)Oe=Oe<<1|1&O,O>>=1;for(j=q<<16|C,V=Oe;V<de;V+=Ze)re[V]=j;++he}++q,he<<=1,Ze<<=1}return[re,B,w]}function G(be,de){switch(this.g=[],this.h=32768,this.d=this.f=this.a=this.l=0,this.input=E?new Uint8Array(be):be,this.m=!1,this.i=we,this.r=!1,!de&&(de={})||(de.index&&(this.a=de.index),de.bufferSize&&(this.h=de.bufferSize),de.bufferType&&(this.i=de.bufferType),de.resize&&(this.r=de.resize)),this.i){case Y:this.b=32768,this.c=new(E?Uint8Array:Array)(32768+this.h+258);break;case we:this.b=0,this.c=new(E?Uint8Array:Array)(this.h),this.e=this.z,this.n=this.v,this.j=this.w;break;default:throw Error("invalid inflate mode")}}var Y=0,we=1,Se={t:Y,s:we};G.prototype.k=function(){for(;!this.m;){var be=Ne(this,3);switch(1&be&&(this.m=!0),be>>>=1){case 0:var de=this.input,re=this.a,q=this.c,he=this.b,Ze=de.length,Oe=void 0,O=q.length,C=void 0;if(this.d=this.f=0,re+1>=Ze)throw Error("invalid uncompressed block header: LEN");if(Oe=de[re++]|de[re++]<<8,re+1>=Ze)throw Error("invalid uncompressed block header: NLEN");if(Oe===~(de[re++]|de[re++]<<8))throw Error("invalid uncompressed block header: length verify");if(re+Oe>de.length)throw Error("input buffer is broken");switch(this.i){case Y:for(;he+Oe>q.length;){if(Oe-=C=O-he,E)q.set(de.subarray(re,re+C),he),he+=C,re+=C;else for(;C--;)q[he++]=de[re++];this.b=he,q=this.e(),he=this.b}break;case we:for(;he+Oe>q.length;)q=this.e({p:2});break;default:throw Error("invalid inflate mode")}if(E)q.set(de.subarray(re,re+Oe),he),he+=Oe,re+=Oe;else for(;Oe--;)q[he++]=de[re++];this.a=re,this.b=he,this.c=q;break;case 1:this.j(Qe,ot);break;case 2:var V,j,H,B,w=Ne(this,5)+257,$=Ne(this,5)+1,ye=Ne(this,4)+4,_e=new(E?Uint8Array:Array)(J.length),W=void 0,ae=void 0,pe=void 0,Fe=void 0,Ce=void 0;for(Ce=0;Ce<ye;++Ce)_e[J[Ce]]=Ne(this,3);if(!E)for(Ce=ye,ye=_e.length;Ce<ye;++Ce)_e[J[Ce]]=0;for(V=U(_e),W=new(E?Uint8Array:Array)(w+$),Ce=0,B=w+$;Ce<B;)switch(ae=at(this,V),ae){case 16:for(Fe=3+Ne(this,2);Fe--;)W[Ce++]=pe;break;case 17:for(Fe=3+Ne(this,3);Fe--;)W[Ce++]=0;pe=0;break;case 18:for(Fe=11+Ne(this,7);Fe--;)W[Ce++]=0;pe=0;break;default:pe=W[Ce++]=ae}j=U(E?W.subarray(0,w):W.slice(0,w)),H=U(E?W.subarray(w):W.slice(w)),this.j(j,H);break;default:throw Error("unknown BTYPE: "+be)}}return this.n()};var Me,T,Z=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],J=E?new Uint16Array(Z):Z,L=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,258,258],N=E?new Uint16Array(L):L,X=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0],Q=E?new Uint8Array(X):X,oe=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577],me=E?new Uint16Array(oe):oe,Te=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],Pe=E?new Uint8Array(Te):Te,Re=new(E?Uint8Array:Array)(288);for(Me=0,T=Re.length;Me<T;++Me)Re[Me]=143>=Me?8:255>=Me?9:279>=Me?7:8;var Ee,Ye,Qe=U(Re),lt=new(E?Uint8Array:Array)(30);for(Ee=0,Ye=lt.length;Ee<Ye;++Ee)lt[Ee]=5;var ot=U(lt);function Ne(be,de){for(var re,q=be.f,he=be.d,Ze=be.input,Oe=be.a,O=Ze.length;he<de;){if(Oe>=O)throw Error("input buffer is broken");q|=Ze[Oe++]<<he,he+=8}return re=q&(1<<de)-1,be.f=q>>>de,be.d=he-de,be.a=Oe,re}function at(be,de){for(var re,q,he=be.f,Ze=be.d,Oe=be.input,O=be.a,C=Oe.length,V=de[0],j=de[1];Ze<j&&!(O>=C);)he|=Oe[O++]<<Ze,Ze+=8;if((q=(re=V[he&(1<<j)-1])>>>16)>Ze)throw Error("invalid code length: "+q);return be.f=he>>q,be.d=Ze-q,be.a=O,65535&re}function $e(be,de){var re,q;switch(this.input=be,this.a=0,!de&&(de={})||(de.index&&(this.a=de.index),de.verify&&(this.A=de.verify)),re=be[this.a++],q=be[this.a++],15&re){case ut:this.method=ut;break;default:throw Error("unsupported compression method")}if(((re<<8)+q)%31!=0)throw Error("invalid fcheck flag:"+((re<<8)+q)%31);if(32&q)throw Error("fdict flag is not supported");this.q=new G(be,{index:this.a,bufferSize:de.bufferSize,bufferType:de.bufferType,resize:de.resize})}G.prototype.j=function(be,de){var re=this.c,q=this.b;this.o=be;for(var he,Ze,Oe,O,C=re.length-258;(he=at(this,be))!==256;)if(256>he)q>=C&&(this.b=q,re=this.e(),q=this.b),re[q++]=he;else for(O=N[Ze=he-257],0<Q[Ze]&&(O+=Ne(this,Q[Ze])),he=at(this,de),Oe=me[he],0<Pe[he]&&(Oe+=Ne(this,Pe[he])),q>=C&&(this.b=q,re=this.e(),q=this.b);O--;)re[q]=re[q++-Oe];for(;8<=this.d;)this.d-=8,this.a--;this.b=q},G.prototype.w=function(be,de){var re=this.c,q=this.b;this.o=be;for(var he,Ze,Oe,O,C=re.length;(he=at(this,be))!==256;)if(256>he)q>=C&&(C=(re=this.e()).length),re[q++]=he;else for(O=N[Ze=he-257],0<Q[Ze]&&(O+=Ne(this,Q[Ze])),he=at(this,de),Oe=me[he],0<Pe[he]&&(Oe+=Ne(this,Pe[he])),q+O>C&&(C=(re=this.e()).length);O--;)re[q]=re[q++-Oe];for(;8<=this.d;)this.d-=8,this.a--;this.b=q},G.prototype.e=function(){var be,de,re=new(E?Uint8Array:Array)(this.b-32768),q=this.b-32768,he=this.c;if(E)re.set(he.subarray(32768,re.length));else for(be=0,de=re.length;be<de;++be)re[be]=he[be+32768];if(this.g.push(re),this.l+=re.length,E)he.set(he.subarray(q,q+32768));else for(be=0;32768>be;++be)he[be]=he[q+be];return this.b=32768,he},G.prototype.z=function(be){var de,re,q,he=this.input.length/this.a+1|0,Ze=this.input,Oe=this.c;return be&&(typeof be.p=="number"&&(he=be.p),typeof be.u=="number"&&(he+=be.u)),2>he?re=(q=(Ze.length-this.a)/this.o[2]/2*258|0)<Oe.length?Oe.length+q:Oe.length<<1:re=Oe.length*he,E?(de=new Uint8Array(re)).set(Oe):de=Oe,this.c=de},G.prototype.n=function(){var be,de,re,q,he,Ze=0,Oe=this.c,O=this.g,C=new(E?Uint8Array:Array)(this.l+(this.b-32768));if(O.length===0)return E?this.c.subarray(32768,this.b):this.c.slice(32768,this.b);for(de=0,re=O.length;de<re;++de)for(q=0,he=(be=O[de]).length;q<he;++q)C[Ze++]=be[q];for(de=32768,re=this.b;de<re;++de)C[Ze++]=Oe[de];return this.g=[],this.buffer=C},G.prototype.v=function(){var be,de=this.b;return E?this.r?(be=new Uint8Array(de)).set(this.c.subarray(0,de)):be=this.c.subarray(0,de):(this.c.length>de&&(this.c.length=de),be=this.c),this.buffer=be},$e.prototype.k=function(){var be,de,re=this.input;if(be=this.q.k(),this.a=this.q.a,this.A){de=(re[this.a++]<<24|re[this.a++]<<16|re[this.a++]<<8|re[this.a++])>>>0;var q=be;if(typeof q=="string"){var he,Ze,Oe=q.split("");for(he=0,Ze=Oe.length;he<Ze;he++)Oe[he]=(255&Oe[he].charCodeAt(0))>>>0;q=Oe}for(var O,C=1,V=0,j=q.length,H=0;0<j;){j-=O=1024<j?1024:j;do V+=C+=q[H++];while(--O);C%=65521,V%=65521}if(de!==(V<<16|C)>>>0)throw Error("invalid adler-32 checksum")}return be};var ut=8;I("Zlib.Inflate",$e),I("Zlib.Inflate.prototype.decompress",$e.prototype.k);var pt,Ot,It,Bt,Wt={ADAPTIVE:Se.s,BLOCK:Se.t};if(Object.keys)pt=Object.keys(Wt);else for(Ot in pt=[],It=0,Wt)pt[It++]=Ot;for(It=0,Bt=pt.length;It<Bt;++It)I("Zlib.Inflate.BufferType."+(Ot=pt[It]),Wt[Ot]);var Tt=A.Zlib.Inflate,Yt={findSpan:function(be,de,re){var q=re.length-be-1;if(de>=re[q])return q-1;if(de<=re[be])return be;for(var he=be,Ze=q,Oe=Math.floor((he+Ze)/2);de<re[Oe]||de>=re[Oe+1];)de<re[Oe]?Ze=Oe:he=Oe,Oe=Math.floor((he+Ze)/2);return Oe},calcBasisFunctions:function(be,de,re,q){var he=[],Ze=[],Oe=[];he[0]=1;for(var O=1;O<=re;++O){Ze[O]=de-q[be+1-O],Oe[O]=q[be+O]-de;for(var C=0,V=0;V<O;++V){var j=Oe[V+1],H=Ze[O-V],B=he[V]/(j+H);he[V]=C+j*B,C=H*B}he[O]=C}return he},calcBSplinePoint:function(be,de,re,q){for(var he=this.findSpan(be,q,de),Ze=this.calcBasisFunctions(he,q,be,de),Oe=new f.Vector4(0,0,0,0),O=0;O<=be;++O){var C=re[he-be+O],V=Ze[O],j=C.w*V;Oe.x+=C.x*j,Oe.y+=C.y*j,Oe.z+=C.z*j,Oe.w+=C.w*V}return Oe},calcBasisFunctionDerivatives:function(be,de,re,q,he){for(var Ze=[],Oe=0;Oe<=re;++Oe)Ze[Oe]=0;var O=[];for(Oe=0;Oe<=q;++Oe)O[Oe]=Ze.slice(0);var C=[];for(Oe=0;Oe<=re;++Oe)C[Oe]=Ze.slice(0);C[0][0]=1;for(var V=Ze.slice(0),j=Ze.slice(0),H=1;H<=re;++H){V[H]=de-he[be+1-H],j[H]=he[be+H]-de;for(var B=0,w=0;w<H;++w){var $=j[w+1],ye=V[H-w];C[H][w]=$+ye;var _e=C[w][H-1]/C[H][w];C[w][H]=B+$*_e,B=ye*_e}C[H][H]=B}for(H=0;H<=re;++H)O[0][H]=C[H][re];for(w=0;w<=re;++w){var W=0,ae=1,pe=[];for(Oe=0;Oe<=re;++Oe)pe[Oe]=Ze.slice(0);pe[0][0]=1;for(var Fe=1;Fe<=q;++Fe){var Ce=0,v=w-Fe,M=re-Fe;w>=Fe&&(pe[ae][0]=pe[W][0]/C[M+1][v],Ce=pe[ae][0]*C[v][M]);var y=w-1<=M?Fe-1:re-w;for(H=v>=-1?1:-v;H<=y;++H)pe[ae][H]=(pe[W][H]-pe[W][H-1])/C[M+1][v+H],Ce+=pe[ae][H]*C[v+H][M];w<=M&&(pe[ae][Fe]=-pe[W][Fe-1]/C[M+1][w],Ce+=pe[ae][Fe]*C[w][M]),O[Fe][w]=Ce,H=W,W=ae,ae=H}}for(w=re,Fe=1;Fe<=q;++Fe){for(H=0;H<=re;++H)O[Fe][H]*=w;w*=re-Fe}return O},calcBSplineDerivatives:function(be,de,re,q,he){for(var Ze=he<be?he:be,Oe=[],O=this.findSpan(be,q,de),C=this.calcBasisFunctionDerivatives(O,q,be,Ze,de),V=[],j=0;j<re.length;++j){var H=(w=re[j].clone()).w;w.x*=H,w.y*=H,w.z*=H,V[j]=w}for(var B=0;B<=Ze;++B){for(var w=V[O-be].clone().multiplyScalar(C[B][0]),$=1;$<=be;++$)w.add(V[O-be+$].clone().multiplyScalar(C[B][$]));Oe[B]=w}for(B=Ze+1;B<=he+1;++B)Oe[B]=new f.Vector4(0,0,0);return Oe},calcKoverI:function(be,de){for(var re=1,q=2;q<=be;++q)re*=q;var he=1;for(q=2;q<=de;++q)he*=q;for(q=2;q<=be-de;++q)he*=q;return re/he},calcRationalCurveDerivatives:function(be){for(var de=be.length,re=[],q=[],he=0;he<de;++he){var Ze=be[he];re[he]=new f.Vector3(Ze.x,Ze.y,Ze.z),q[he]=Ze.w}for(var Oe=[],O=0;O<de;++O){var C=re[O].clone();for(he=1;he<=O;++he)C.sub(Oe[O-he].clone().multiplyScalar(this.calcKoverI(O,he)*q[he]));Oe[O]=C.divideScalar(q[0])}return Oe},calcNURBSDerivatives:function(be,de,re,q,he){var Ze=this.calcBSplineDerivatives(be,de,re,q,he);return this.calcRationalCurveDerivatives(Ze)},calcSurfacePoint:function(be,de,re,q,he,Ze,Oe,O){for(var C=this.findSpan(be,Ze,re),V=this.findSpan(de,Oe,q),j=this.calcBasisFunctions(C,Ze,be,re),H=this.calcBasisFunctions(V,Oe,de,q),B=[],w=0;w<=de;++w){B[w]=new f.Vector4(0,0,0,0);for(var $=0;$<=be;++$){var ye=he[C-be+$][V-de+w].clone(),_e=ye.w;ye.x*=_e,ye.y*=_e,ye.z*=_e,B[w].add(ye.multiplyScalar(j[$]))}}var W=new f.Vector4(0,0,0,0);for(w=0;w<=de;++w)W.add(B[w].multiplyScalar(H[w]));W.divideScalar(W.w),O.set(W.x,W.y,W.z)}},Kt=function(be,de,re,q,he){f.Curve.call(this),this.degree=be,this.knots=de,this.controlPoints=[],this.startKnot=q||0,this.endKnot=he||this.knots.length-1;for(var Ze=0;Ze<re.length;++Ze){var Oe=re[Ze];this.controlPoints[Ze]=new f.Vector4(Oe.x,Oe.y,Oe.z,Oe.w)}};(Kt.prototype=Object.create(f.Curve.prototype)).constructor=Kt,Kt.prototype.getPoint=function(be,de){var re=de||new f.Vector3,q=this.knots[this.startKnot]+be*(this.knots[this.endKnot]-this.knots[this.startKnot]),he=Yt.calcBSplinePoint(this.degree,this.knots,this.controlPoints,q);return he.w!=1&&he.divideScalar(he.w),re.set(he.x,he.y,he.z)},Kt.prototype.getTangent=function(be,de){var re=de||new f.Vector3,q=this.knots[0]+be*(this.knots[this.knots.length-1]-this.knots[0]),he=Yt.calcNURBSDerivatives(this.degree,this.knots,this.controlPoints,q,1);return re.copy(he[1]).normalize(),re};var Zt=function(){var be,de,re;function q(v){f.Loader.call(this,v)}function he(v,M){this.textureLoader=v,this.manager=M}function Ze(){}function Oe(){}function O(){}function C(){}function V(v,M){this.dv=new DataView(v),this.offset=0,this.littleEndian=M===void 0||M}function j(){}function H(v){var M=v.match(/FBXVersion: (\d+)/);if(M)return parseInt(M[1]);throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.")}function B(v){return v/46186158e3}q.prototype=Object.assign(Object.create(f.Loader.prototype),{constructor:q,load:function(v,M,y,_){var D=this,ie=D.path===""?f.LoaderUtils.extractUrlBase(v):D.path,ue=new f.FileLoader(this.manager);ue.setPath(D.path),ue.setResponseType("arraybuffer"),ue.setRequestHeader(D.requestHeader),ue.setWithCredentials(D.withCredentials),ue.load(v,function(se){try{M(D.parse(se,ie))}catch(Ue){_?_(Ue):console.error(Ue),D.manager.itemError(v)}},y,_)},parse:function(v,M){if(D="Kaydara FBX Binary  \0",(_=v).byteLength>=D.length&&D===Fe(_,0,D.length))be=new C().parse(v);else{var y=Fe(v);if(!function(ie){for(var ue=["K","a","y","d","a","r","a","\\","F","B","X","\\","B","i","n","a","r","y","\\","\\"],se=0,Ue=0;Ue<ue.length;++Ue)if((Be=void 0,Be=ie[(it=1)-1],ie=ie.slice(se+it),se++,Be)===ue[Ue])return!1;var it,Be;return!0}(y))throw new Error("THREE.FBXLoader: Unknown format.");if(H(y)<7e3)throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: "+H(y));be=new O().parse(y)}var _,D;return new he(new f.TextureLoader(this.manager).setPath(this.resourcePath||M).setCrossOrigin(this.crossOrigin),this.manager).parse(be)}}),he.prototype={constructor:he,parse:function(){de=this.parseConnections();var v=this.parseImages(),M=this.parseTextures(v),y=this.parseMaterials(M),_=this.parseDeformers(),D=new Ze().parse(_);return this.parseScene(_,D,y),re},parseConnections:function(){var v=new Map;return"Connections"in be&&be.Connections.connections.forEach(function(M){var y=M[0],_=M[1],D=M[2];v.has(y)||v.set(y,{parents:[],children:[]});var ie={ID:_,relationship:D};v.get(y).parents.push(ie),v.has(_)||v.set(_,{parents:[],children:[]});var ue={ID:y,relationship:D};v.get(_).children.push(ue)}),v},parseImages:function(){var v={},M={};if("Video"in be.Objects){var y=be.Objects.Video;for(var _ in y){var D=y[_];if(v[Ue=parseInt(_)]=D.RelativeFilename||D.Filename,"Content"in D){var ie=D.Content instanceof ArrayBuffer&&D.Content.byteLength>0,ue=typeof D.Content=="string"&&D.Content!=="";if(ie||ue){var se=this.parseImage(y[_]);M[D.RelativeFilename||D.Filename]=se}}}}for(var Ue in v){var it=v[Ue];M[it]!==void 0?v[Ue]=M[it]:v[Ue]=v[Ue].split("\\").pop()}return v},parseImage:function(v){var M,y=v.Content,_=v.RelativeFilename||v.Filename,D=_.slice(_.lastIndexOf(".")+1).toLowerCase();switch(D){case"bmp":M="image/bmp";break;case"jpg":case"jpeg":M="image/jpeg";break;case"png":M="image/png";break;case"tif":M="image/tiff";break;case"tga":this.manager.getHandler(".tga")===null&&console.warn("FBXLoader: TGA loader not found, skipping ",_),M="image/tga";break;default:return void console.warn('FBXLoader: Image type "'+D+'" is not supported.')}if(typeof y=="string")return"data:"+M+";base64,"+y;var ie=new Uint8Array(y);return window.URL.createObjectURL(new Blob([ie],{type:M}))},parseTextures:function(v){var M=new Map;if("Texture"in be.Objects){var y=be.Objects.Texture;for(var _ in y){var D=this.parseTexture(y[_],v);M.set(parseInt(_),D)}}return M},parseTexture:function(v,M){var y=this.loadTexture(v,M);y.ID=v.id,y.name=v.attrName;var _=v.WrapModeU,D=v.WrapModeV,ie=_!==void 0?_.value:0,ue=D!==void 0?D.value:0;if(y.wrapS=ie===0?f.RepeatWrapping:f.ClampToEdgeWrapping,y.wrapT=ue===0?f.RepeatWrapping:f.ClampToEdgeWrapping,"Scaling"in v){var se=v.Scaling.value;y.repeat.x=se[0],y.repeat.y=se[1]}return y},loadTexture:function(v,M){var y,_,D=this.textureLoader.path,ie=de.get(v.id).children;ie!==void 0&&ie.length>0&&M[ie[0].ID]!==void 0&&((y=M[ie[0].ID]).indexOf("blob:")!==0&&y.indexOf("data:")!==0||this.textureLoader.setPath(void 0));var ue=v.FileName.slice(-3).toLowerCase();if(ue==="tga"){var se=this.manager.getHandler(".tga");se===null?(console.warn("FBXLoader: TGA loader not found, creating placeholder texture for",v.RelativeFilename),_=new f.Texture):_=se.load(y)}else ue==="psd"?(console.warn("FBXLoader: PSD textures are not supported, creating placeholder texture for",v.RelativeFilename),_=new f.Texture):_=this.textureLoader.load(y);return this.textureLoader.setPath(D),_},parseMaterials:function(v){var M=new Map;if("Material"in be.Objects){var y=be.Objects.Material;for(var _ in y){var D=this.parseMaterial(y[_],v);D!==null&&M.set(parseInt(_),D)}}return M},parseMaterial:function(v,M){var y=v.id,_=v.attrName,D=v.ShadingModel;if(typeof D=="object"&&(D=D.value),!de.has(y))return null;var ie,ue=this.parseParameters(v,M,y);switch(D.toLowerCase()){case"phong":ie=new f.MeshPhongMaterial;break;case"lambert":ie=new f.MeshLambertMaterial;break;default:console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.',D),ie=new f.MeshPhongMaterial}return ie.setValues(ue),ie.name=_,ie},parseParameters:function(v,M,y){var _={};v.BumpFactor&&(_.bumpScale=v.BumpFactor.value),v.Diffuse?_.color=new f.Color().fromArray(v.Diffuse.value):!v.DiffuseColor||v.DiffuseColor.type!=="Color"&&v.DiffuseColor.type!=="ColorRGB"||(_.color=new f.Color().fromArray(v.DiffuseColor.value)),v.DisplacementFactor&&(_.displacementScale=v.DisplacementFactor.value),v.Emissive?_.emissive=new f.Color().fromArray(v.Emissive.value):!v.EmissiveColor||v.EmissiveColor.type!=="Color"&&v.EmissiveColor.type!=="ColorRGB"||(_.emissive=new f.Color().fromArray(v.EmissiveColor.value)),v.EmissiveFactor&&(_.emissiveIntensity=parseFloat(v.EmissiveFactor.value)),v.Opacity&&(_.opacity=parseFloat(v.Opacity.value)),_.opacity<1&&(_.transparent=!0),v.ReflectionFactor&&(_.reflectivity=v.ReflectionFactor.value),v.Shininess&&(_.shininess=v.Shininess.value),v.Specular?_.specular=new f.Color().fromArray(v.Specular.value):v.SpecularColor&&v.SpecularColor.type==="Color"&&(_.specular=new f.Color().fromArray(v.SpecularColor.value));var D=this;return de.get(y).children.forEach(function(ie){var ue=ie.relationship;switch(ue){case"Bump":_.bumpMap=D.getTexture(M,ie.ID);break;case"Maya|TEX_ao_map":_.aoMap=D.getTexture(M,ie.ID);break;case"DiffuseColor":case"Maya|TEX_color_map":_.map=D.getTexture(M,ie.ID),_.map.encoding=f.sRGBEncoding;break;case"DisplacementColor":_.displacementMap=D.getTexture(M,ie.ID);break;case"EmissiveColor":_.emissiveMap=D.getTexture(M,ie.ID),_.emissiveMap.encoding=f.sRGBEncoding;break;case"NormalMap":case"Maya|TEX_normal_map":_.normalMap=D.getTexture(M,ie.ID);break;case"ReflectionColor":_.envMap=D.getTexture(M,ie.ID),_.envMap.mapping=f.EquirectangularReflectionMapping,_.envMap.encoding=f.sRGBEncoding;break;case"SpecularColor":_.specularMap=D.getTexture(M,ie.ID),_.specularMap.encoding=f.sRGBEncoding;break;case"TransparentColor":case"TransparencyFactor":_.alphaMap=D.getTexture(M,ie.ID),_.transparent=!0;break;case"AmbientColor":case"ShininessExponent":case"SpecularFactor":case"VectorDisplacementColor":default:console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.",ue)}}),_},getTexture:function(v,M){return"LayeredTexture"in be.Objects&&M in be.Objects.LayeredTexture&&(console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."),M=de.get(M).children[0].ID),v.get(M)},parseDeformers:function(){var v={},M={};if("Deformer"in be.Objects){var y=be.Objects.Deformer;for(var _ in y){var D=y[_],ie=de.get(parseInt(_));if(D.attrType==="Skin"){var ue=this.parseSkeleton(ie,y);ue.ID=_,ie.parents.length>1&&console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported."),ue.geometryID=ie.parents[0].ID,v[_]=ue}else if(D.attrType==="BlendShape"){var se={id:_};se.rawTargets=this.parseMorphTargets(ie,y),se.id=_,ie.parents.length>1&&console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported."),M[_]=se}}}return{skeletons:v,morphTargets:M}},parseSkeleton:function(v,M){var y=[];return v.children.forEach(function(_){var D=M[_.ID];if(D.attrType==="Cluster"){var ie={ID:_.ID,indices:[],weights:[],transformLink:new f.Matrix4().fromArray(D.TransformLink.a)};"Indexes"in D&&(ie.indices=D.Indexes.a,ie.weights=D.Weights.a),y.push(ie)}}),{rawBones:y,bones:[]}},parseMorphTargets:function(v,M){for(var y=[],_=0;_<v.children.length;_++){var D=v.children[_],ie=M[D.ID],ue={name:ie.attrName,initialWeight:ie.DeformPercent,id:ie.id,fullWeights:ie.FullWeights.a};if(ie.attrType!=="BlendShapeChannel")return;ue.geoID=de.get(parseInt(D.ID)).children.filter(function(se){return se.relationship===void 0})[0].ID,y.push(ue)}return y},parseScene:function(v,M,y){re=new f.Group;var _=this.parseModels(v.skeletons,M,y),D=be.Objects.Model,ie=this;_.forEach(function(se){var Ue=D[se.ID];ie.setLookAtProperties(se,Ue),de.get(se.ID).parents.forEach(function(it){var Be=_.get(it.ID);Be!==void 0&&Be.add(se)}),se.parent===null&&re.add(se)}),this.bindSkeleton(v.skeletons,M,_),this.createAmbientLight(),this.setupMorphMaterials(),re.traverse(function(se){if(se.userData.transformData){se.parent&&(se.userData.transformData.parentMatrixWorld=se.parent.matrix);var Ue=W(se.userData.transformData);se.applyMatrix4(Ue)}});var ue=new Oe().parse();re.children.length===1&&re.children[0].isGroup&&(re.children[0].animations=ue,re=re.children[0]),re.animations=ue},parseModels:function(v,M,y){var _=new Map,D=be.Objects.Model;for(var ie in D){var ue=parseInt(ie),se=D[ie],Ue=de.get(ue),it=this.buildSkeleton(Ue,v,ue,se.attrName);if(!it){switch(se.attrType){case"Camera":it=this.createCamera(Ue);break;case"Light":it=this.createLight(Ue);break;case"Mesh":it=this.createMesh(Ue,M,y);break;case"NurbsCurve":it=this.createCurve(Ue,M);break;case"LimbNode":case"Root":it=new f.Bone;break;case"Null":default:it=new f.Group}it.name=se.attrName?f.PropertyBinding.sanitizeNodeName(se.attrName):"",it.ID=ue}this.getTransformData(it,se),_.set(ue,it)}return _},buildSkeleton:function(v,M,y,_){var D=null;return v.parents.forEach(function(ie){for(var ue in M){var se=M[ue];se.rawBones.forEach(function(Ue,it){if(Ue.ID===ie.ID){var Be=D;(D=new f.Bone).matrixWorld.copy(Ue.transformLink),D.name=_?f.PropertyBinding.sanitizeNodeName(_):"",D.ID=y,se.bones[it]=D,Be!==null&&D.add(Be)}})}}),D},createCamera:function(v){var M,y;if(v.children.forEach(function(Et){var bt=be.Objects.NodeAttribute[Et.ID];bt!==void 0&&(y=bt)}),y===void 0)M=new f.Object3D;else{var _=0;y.CameraProjectionType!==void 0&&y.CameraProjectionType.value===1&&(_=1);var D=1;y.NearPlane!==void 0&&(D=y.NearPlane.value/1e3);var ie=1e3;y.FarPlane!==void 0&&(ie=y.FarPlane.value/1e3);var ue=window.innerWidth,se=window.innerHeight;y.AspectWidth!==void 0&&y.AspectHeight!==void 0&&(ue=y.AspectWidth.value,se=y.AspectHeight.value);var Ue=ue/se,it=45;y.FieldOfView!==void 0&&(it=y.FieldOfView.value);var Be=y.FocalLength?y.FocalLength.value:null;switch(_){case 0:M=new f.PerspectiveCamera(it,Ue,D,ie),Be!==null&&M.setFocalLength(Be);break;case 1:M=new f.OrthographicCamera(-ue/2,ue/2,se/2,-se/2,D,ie);break;default:console.warn("THREE.FBXLoader: Unknown camera type "+_+"."),M=new f.Object3D}}return M},createLight:function(v){var M,y;if(v.children.forEach(function(it){var Be=be.Objects.NodeAttribute[it.ID];Be!==void 0&&(y=Be)}),y===void 0)M=new f.Object3D;else{var _;_=y.LightType===void 0?0:y.LightType.value;var D=16777215;y.Color!==void 0&&(D=new f.Color().fromArray(y.Color.value));var ie=y.Intensity===void 0?1:y.Intensity.value/100;y.CastLightOnObject!==void 0&&y.CastLightOnObject.value===0&&(ie=0);var ue=0;y.FarAttenuationEnd!==void 0&&(ue=y.EnableFarAttenuation!==void 0&&y.EnableFarAttenuation.value===0?0:y.FarAttenuationEnd.value);switch(_){case 0:M=new f.PointLight(D,ie,ue,1);break;case 1:M=new f.DirectionalLight(D,ie);break;case 2:var se=Math.PI/3;y.InnerAngle!==void 0&&(se=f.MathUtils.degToRad(y.InnerAngle.value));var Ue=0;y.OuterAngle!==void 0&&(Ue=f.MathUtils.degToRad(y.OuterAngle.value),Ue=Math.max(Ue,1)),M=new f.SpotLight(D,ie,ue,se,Ue,1);break;default:console.warn("THREE.FBXLoader: Unknown light type "+y.LightType.value+", defaulting to a PointLight."),M=new f.PointLight(D,ie)}y.CastShadows!==void 0&&y.CastShadows.value===1&&(M.castShadow=!0)}return M},createMesh:function(v,M,y){var _,D=null,ie=null,ue=[];return v.children.forEach(function(se){M.has(se.ID)&&(D=M.get(se.ID)),y.has(se.ID)&&ue.push(y.get(se.ID))}),ue.length>1?ie=ue:ue.length>0?ie=ue[0]:(ie=new f.MeshPhongMaterial({color:13421772}),ue.push(ie)),"color"in D.attributes&&ue.forEach(function(se){se.vertexColors=!0}),D.FBX_Deformer?(ue.forEach(function(se){se.skinning=!0}),(_=new f.SkinnedMesh(D,ie)).normalizeSkinWeights()):_=new f.Mesh(D,ie),_},createCurve:function(v,M){var y=v.children.reduce(function(D,ie){return M.has(ie.ID)&&(D=M.get(ie.ID)),D},null),_=new f.LineBasicMaterial({color:3342591,linewidth:1});return new f.Line(y,_)},getTransformData:function(v,M){var y={};"InheritType"in M&&(y.inheritType=parseInt(M.InheritType.value)),y.eulerOrder="RotationOrder"in M?ae(M.RotationOrder.value):"ZYX","Lcl_Translation"in M&&(y.translation=M.Lcl_Translation.value),"PreRotation"in M&&(y.preRotation=M.PreRotation.value),"Lcl_Rotation"in M&&(y.rotation=M.Lcl_Rotation.value),"PostRotation"in M&&(y.postRotation=M.PostRotation.value),"Lcl_Scaling"in M&&(y.scale=M.Lcl_Scaling.value),"ScalingOffset"in M&&(y.scalingOffset=M.ScalingOffset.value),"ScalingPivot"in M&&(y.scalingPivot=M.ScalingPivot.value),"RotationOffset"in M&&(y.rotationOffset=M.RotationOffset.value),"RotationPivot"in M&&(y.rotationPivot=M.RotationPivot.value),v.userData.transformData=y},setLookAtProperties:function(v,M){"LookAtProperty"in M&&de.get(v.ID).children.forEach(function(y){if(y.relationship==="LookAtProperty"){var _=be.Objects.Model[y.ID];if("Lcl_Translation"in _){var D=_.Lcl_Translation.value;v.target!==void 0?(v.target.position.fromArray(D),re.add(v.target)):v.lookAt(new f.Vector3().fromArray(D))}}})},bindSkeleton:function(v,M,y){var _=this.parsePoseNodes();for(var D in v){var ie=v[D];de.get(parseInt(ie.ID)).parents.forEach(function(ue){if(M.has(ue.ID)){var se=ue.ID;de.get(se).parents.forEach(function(Ue){y.has(Ue.ID)&&y.get(Ue.ID).bind(new f.Skeleton(ie.bones),_[Ue.ID])})}})}},parsePoseNodes:function(){var v={};if("Pose"in be.Objects){var M=be.Objects.Pose;for(var y in M)if(M[y].attrType==="BindPose"){var _=M[y].PoseNode;Array.isArray(_)?_.forEach(function(D){v[D.Node]=new f.Matrix4().fromArray(D.Matrix.a)}):v[_.Node]=new f.Matrix4().fromArray(_.Matrix.a)}}return v},createAmbientLight:function(){if("GlobalSettings"in be&&"AmbientColor"in be.GlobalSettings){var v=be.GlobalSettings.AmbientColor.value,M=v[0],y=v[1],_=v[2];if(M!==0||y!==0||_!==0){var D=new f.Color(M,y,_);re.add(new f.AmbientLight(D,1))}}},setupMorphMaterials:function(){var v=this;re.traverse(function(M){M.isMesh&&M.geometry.morphAttributes.position&&M.geometry.morphAttributes.position.length&&(Array.isArray(M.material)?M.material.forEach(function(y,_){v.setupMorphMaterial(M,y,_)}):v.setupMorphMaterial(M,M.material))})},setupMorphMaterial:function(v,M,y){var _=v.uuid,D=M.uuid,ie=!1;if(re.traverse(function(se){se.isMesh&&(Array.isArray(se.material)?se.material.forEach(function(Ue){Ue.uuid===D&&se.uuid!==_&&(ie=!0)}):se.material.uuid===D&&se.uuid!==_&&(ie=!0))}),ie===!0){var ue=M.clone();ue.morphTargets=!0,y===void 0?v.material=ue:v.material[y]=ue}else M.morphTargets=!0}},Ze.prototype={constructor:Ze,parse:function(v){var M=new Map;if("Geometry"in be.Objects){var y=be.Objects.Geometry;for(var _ in y){var D=de.get(parseInt(_)),ie=this.parseGeometry(D,y[_],v);M.set(parseInt(_),ie)}}return M},parseGeometry:function(v,M,y){switch(M.attrType){case"Mesh":return this.parseMeshGeometry(v,M,y);case"NurbsCurve":return this.parseNurbsGeometry(M)}},parseMeshGeometry:function(v,M,y){var _=y.skeletons,D=[],ie=v.parents.map(function(Be){return be.Objects.Model[Be.ID]});if(ie.length!==0){var ue=v.children.reduce(function(Be,Et){return _[Et.ID]!==void 0&&(Be=_[Et.ID]),Be},null);v.children.forEach(function(Be){y.morphTargets[Be.ID]!==void 0&&D.push(y.morphTargets[Be.ID])});var se=ie[0],Ue={};"RotationOrder"in se&&(Ue.eulerOrder=ae(se.RotationOrder.value)),"InheritType"in se&&(Ue.inheritType=parseInt(se.InheritType.value)),"GeometricTranslation"in se&&(Ue.translation=se.GeometricTranslation.value),"GeometricRotation"in se&&(Ue.rotation=se.GeometricRotation.value),"GeometricScaling"in se&&(Ue.scale=se.GeometricScaling.value);var it=W(Ue);return this.genGeometry(M,ue,D,it)}},genGeometry:function(v,M,y,_){var D=new f.BufferGeometry;v.attrName&&(D.name=v.attrName);var ie=this.parseGeoNode(v,M),ue=this.genBuffers(ie),se=new f.Float32BufferAttribute(ue.vertex,3);if(se.applyMatrix4(_),D.setAttribute("position",se),ue.colors.length>0&&D.setAttribute("color",new f.Float32BufferAttribute(ue.colors,3)),M&&(D.setAttribute("skinIndex",new f.Uint16BufferAttribute(ue.weightsIndices,4)),D.setAttribute("skinWeight",new f.Float32BufferAttribute(ue.vertexWeights,4)),D.FBX_Deformer=M),ue.normal.length>0){var Ue=new f.Matrix3().getNormalMatrix(_),it=new f.Float32BufferAttribute(ue.normal,3);it.applyNormalMatrix(Ue),D.setAttribute("normal",it)}if(ue.uvs.forEach(function(Qt,Xt){var wn="uv"+(Xt+1).toString();Xt===0&&(wn="uv"),D.setAttribute(wn,new f.Float32BufferAttribute(ue.uvs[Xt],2))}),ie.material&&ie.material.mappingType!=="AllSame"){var Be=ue.materialIndex[0],Et=0;if(ue.materialIndex.forEach(function(Qt,Xt){Qt!==Be&&(D.addGroup(Et,Xt-Et,Be),Be=Qt,Et=Xt)}),D.groups.length>0){var bt=D.groups[D.groups.length-1],on=bt.start+bt.count;on!==ue.materialIndex.length&&D.addGroup(on,ue.materialIndex.length-on,Be)}D.groups.length===0&&D.addGroup(0,ue.materialIndex.length,ue.materialIndex[0])}return this.addMorphTargets(D,v,y,_),D},parseGeoNode:function(v,M){var y={};if(y.vertexPositions=v.Vertices!==void 0?v.Vertices.a:[],y.vertexIndices=v.PolygonVertexIndex!==void 0?v.PolygonVertexIndex.a:[],v.LayerElementColor&&(y.color=this.parseVertexColors(v.LayerElementColor[0])),v.LayerElementMaterial&&(y.material=this.parseMaterialIndices(v.LayerElementMaterial[0])),v.LayerElementNormal&&(y.normal=this.parseNormals(v.LayerElementNormal[0])),v.LayerElementUV){y.uv=[];for(var _=0;v.LayerElementUV[_];)v.LayerElementUV[_].UV&&y.uv.push(this.parseUVs(v.LayerElementUV[_])),_++}return y.weightTable={},M!==null&&(y.skeleton=M,M.rawBones.forEach(function(D,ie){D.indices.forEach(function(ue,se){y.weightTable[ue]===void 0&&(y.weightTable[ue]=[]),y.weightTable[ue].push({id:ie,weight:D.weights[se]})})})),y},genBuffers:function(v){var M={vertex:[],normal:[],colors:[],uvs:[],materialIndex:[],vertexWeights:[],weightsIndices:[]},y=0,_=0,D=!1,ie=[],ue=[],se=[],Ue=[],it=[],Be=[],Et=this;return v.vertexIndices.forEach(function(bt,on){var Qt=!1;bt<0&&(bt^=-1,Qt=!0);var Xt=[],wn=[];if(ie.push(3*bt,3*bt+1,3*bt+2),v.color){var gn=$(on,y,bt,v.color);se.push(gn[0],gn[1],gn[2])}if(v.skeleton){if(v.weightTable[bt]!==void 0&&v.weightTable[bt].forEach(function(Cn){wn.push(Cn.weight),Xt.push(Cn.id)}),wn.length>4){D||(console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."),D=!0);var sn=[0,0,0,0],On=[0,0,0,0];wn.forEach(function(Cn,Tn){var Jn=Cn,En=Xt[Tn];On.forEach(function(In,ji,La){if(Jn>In){La[ji]=Jn,Jn=In;var Ca=sn[ji];sn[ji]=En,En=Ca}})}),Xt=sn,wn=On}for(;wn.length<4;)wn.push(0),Xt.push(0);for(var Zn=0;Zn<4;++Zn)it.push(wn[Zn]),Be.push(Xt[Zn])}if(v.normal&&(gn=$(on,y,bt,v.normal),ue.push(gn[0],gn[1],gn[2])),v.material&&v.material.mappingType!=="AllSame")var Dn=$(on,y,bt,v.material)[0];v.uv&&v.uv.forEach(function(Cn,Tn){var Jn=$(on,y,bt,Cn);Ue[Tn]===void 0&&(Ue[Tn]=[]),Ue[Tn].push(Jn[0]),Ue[Tn].push(Jn[1])}),_++,Qt&&(Et.genFace(M,v,ie,Dn,ue,se,Ue,it,Be,_),y++,_=0,ie=[],ue=[],se=[],Ue=[],it=[],Be=[])}),M},genFace:function(v,M,y,_,D,ie,ue,se,Ue,it){for(var Be=2;Be<it;Be++)v.vertex.push(M.vertexPositions[y[0]]),v.vertex.push(M.vertexPositions[y[1]]),v.vertex.push(M.vertexPositions[y[2]]),v.vertex.push(M.vertexPositions[y[3*(Be-1)]]),v.vertex.push(M.vertexPositions[y[3*(Be-1)+1]]),v.vertex.push(M.vertexPositions[y[3*(Be-1)+2]]),v.vertex.push(M.vertexPositions[y[3*Be]]),v.vertex.push(M.vertexPositions[y[3*Be+1]]),v.vertex.push(M.vertexPositions[y[3*Be+2]]),M.skeleton&&(v.vertexWeights.push(se[0]),v.vertexWeights.push(se[1]),v.vertexWeights.push(se[2]),v.vertexWeights.push(se[3]),v.vertexWeights.push(se[4*(Be-1)]),v.vertexWeights.push(se[4*(Be-1)+1]),v.vertexWeights.push(se[4*(Be-1)+2]),v.vertexWeights.push(se[4*(Be-1)+3]),v.vertexWeights.push(se[4*Be]),v.vertexWeights.push(se[4*Be+1]),v.vertexWeights.push(se[4*Be+2]),v.vertexWeights.push(se[4*Be+3]),v.weightsIndices.push(Ue[0]),v.weightsIndices.push(Ue[1]),v.weightsIndices.push(Ue[2]),v.weightsIndices.push(Ue[3]),v.weightsIndices.push(Ue[4*(Be-1)]),v.weightsIndices.push(Ue[4*(Be-1)+1]),v.weightsIndices.push(Ue[4*(Be-1)+2]),v.weightsIndices.push(Ue[4*(Be-1)+3]),v.weightsIndices.push(Ue[4*Be]),v.weightsIndices.push(Ue[4*Be+1]),v.weightsIndices.push(Ue[4*Be+2]),v.weightsIndices.push(Ue[4*Be+3])),M.color&&(v.colors.push(ie[0]),v.colors.push(ie[1]),v.colors.push(ie[2]),v.colors.push(ie[3*(Be-1)]),v.colors.push(ie[3*(Be-1)+1]),v.colors.push(ie[3*(Be-1)+2]),v.colors.push(ie[3*Be]),v.colors.push(ie[3*Be+1]),v.colors.push(ie[3*Be+2])),M.material&&M.material.mappingType!=="AllSame"&&(v.materialIndex.push(_),v.materialIndex.push(_),v.materialIndex.push(_)),M.normal&&(v.normal.push(D[0]),v.normal.push(D[1]),v.normal.push(D[2]),v.normal.push(D[3*(Be-1)]),v.normal.push(D[3*(Be-1)+1]),v.normal.push(D[3*(Be-1)+2]),v.normal.push(D[3*Be]),v.normal.push(D[3*Be+1]),v.normal.push(D[3*Be+2])),M.uv&&M.uv.forEach(function(Et,bt){v.uvs[bt]===void 0&&(v.uvs[bt]=[]),v.uvs[bt].push(ue[bt][0]),v.uvs[bt].push(ue[bt][1]),v.uvs[bt].push(ue[bt][2*(Be-1)]),v.uvs[bt].push(ue[bt][2*(Be-1)+1]),v.uvs[bt].push(ue[bt][2*Be]),v.uvs[bt].push(ue[bt][2*Be+1])})},addMorphTargets:function(v,M,y,_){if(y.length!==0){v.morphTargetsRelative=!0,v.morphAttributes.position=[];var D=this;y.forEach(function(ie){ie.rawTargets.forEach(function(ue){var se=be.Objects.Geometry[ue.geoID];se!==void 0&&D.genMorphGeometry(v,M,se,_,ue.name)})})}},genMorphGeometry:function(v,M,y,_,D){for(var ie=M.PolygonVertexIndex!==void 0?M.PolygonVertexIndex.a:[],ue=y.Vertices!==void 0?y.Vertices.a:[],se=y.Indexes!==void 0?y.Indexes.a:[],Ue=3*v.attributes.position.count,it=new Float32Array(Ue),Be=0;Be<se.length;Be++){var Et=3*se[Be];it[Et]=ue[3*Be],it[Et+1]=ue[3*Be+1],it[Et+2]=ue[3*Be+2]}var bt={vertexIndices:ie,vertexPositions:it},on=this.genBuffers(bt),Qt=new f.Float32BufferAttribute(on.vertex,3);Qt.name=D||y.attrName,Qt.applyMatrix4(_),v.morphAttributes.position.push(Qt)},parseNormals:function(v){var M=v.MappingInformationType,y=v.ReferenceInformationType,_=v.Normals.a,D=[];return y==="IndexToDirect"&&("NormalIndex"in v?D=v.NormalIndex.a:"NormalsIndex"in v&&(D=v.NormalsIndex.a)),{dataSize:3,buffer:_,indices:D,mappingType:M,referenceType:y}},parseUVs:function(v){var M=v.MappingInformationType,y=v.ReferenceInformationType,_=v.UV.a,D=[];return y==="IndexToDirect"&&(D=v.UVIndex.a),{dataSize:2,buffer:_,indices:D,mappingType:M,referenceType:y}},parseVertexColors:function(v){var M=v.MappingInformationType,y=v.ReferenceInformationType,_=v.Colors.a,D=[];return y==="IndexToDirect"&&(D=v.ColorIndex.a),{dataSize:4,buffer:_,indices:D,mappingType:M,referenceType:y}},parseMaterialIndices:function(v){var M=v.MappingInformationType,y=v.ReferenceInformationType;if(M==="NoMappingInformation")return{dataSize:1,buffer:[0],indices:[0],mappingType:"AllSame",referenceType:y};for(var _=v.Materials.a,D=[],ie=0;ie<_.length;++ie)D.push(ie);return{dataSize:1,buffer:_,indices:D,mappingType:M,referenceType:y}},parseNurbsGeometry:function(v){if(Kt===void 0)return console.error("THREE.FBXLoader: The loader relies on NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry."),new f.BufferGeometry;var M=parseInt(v.Order);if(isNaN(M))return console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s",v.Order,v.id),new f.BufferGeometry;for(var y,_,D=M-1,ie=v.KnotVector.a,ue=[],se=v.Points.a,Ue=0,it=se.length;Ue<it;Ue+=4)ue.push(new f.Vector4().fromArray(se,Ue));if(v.Form==="Closed")ue.push(ue[0]);else if(v.Form==="Periodic")for(y=D,_=ie.length-1-y,Ue=0;Ue<D;++Ue)ue.push(ue[Ue]);var Be=new Kt(D,ie,ue,y,_).getPoints(7*ue.length),Et=new Float32Array(3*Be.length);Be.forEach(function(on,Qt){on.toArray(Et,3*Qt)});var bt=new f.BufferGeometry;return bt.setAttribute("position",new f.BufferAttribute(Et,3)),bt}},Oe.prototype={constructor:Oe,parse:function(){var v=[],M=this.parseClips();if(M!==void 0)for(var y in M){var _=M[y],D=this.addClip(_);v.push(D)}return v},parseClips:function(){if(be.Objects.AnimationCurve!==void 0){var v=this.parseAnimationCurveNodes();this.parseAnimationCurves(v);var M=this.parseAnimationLayers(v);return this.parseAnimStacks(M)}},parseAnimationCurveNodes:function(){var v=be.Objects.AnimationCurveNode,M=new Map;for(var y in v){var _=v[y];if(_.attrName.match(/S|R|T|DeformPercent/)!==null){var D={id:_.id,attr:_.attrName,curves:{}};M.set(D.id,D)}}return M},parseAnimationCurves:function(v){var M=be.Objects.AnimationCurve;for(var y in M){var _={id:M[y].id,times:M[y].KeyTime.a.map(B),values:M[y].KeyValueFloat.a},D=de.get(_.id);if(D!==void 0){var ie=D.parents[0].ID,ue=D.parents[0].relationship;ue.match(/X/)?v.get(ie).curves.x=_:ue.match(/Y/)?v.get(ie).curves.y=_:ue.match(/Z/)?v.get(ie).curves.z=_:ue.match(/d|DeformPercent/)&&v.has(ie)&&(v.get(ie).curves.morph=_)}}},parseAnimationLayers:function(v){var M=be.Objects.AnimationLayer,y=new Map;for(var _ in M){var D=[],ie=de.get(parseInt(_));ie!==void 0&&(ie.children.forEach(function(ue,se){if(v.has(ue.ID)){var Ue=v.get(ue.ID);if(Ue.curves.x!==void 0||Ue.curves.y!==void 0||Ue.curves.z!==void 0){if(D[se]===void 0&&(Qt=de.get(ue.ID).parents.filter(function(Xt){return Xt.relationship!==void 0})[0].ID)!==void 0){if((Be=be.Objects.Model[Qt.toString()])===void 0)return void console.warn("THREE.FBXLoader: Encountered a unused curve.",ue);var it={modelName:Be.attrName?f.PropertyBinding.sanitizeNodeName(Be.attrName):"",ID:Be.id,initialPosition:[0,0,0],initialRotation:[0,0,0],initialScale:[1,1,1]};re.traverse(function(Xt){Xt.ID===Be.id&&(it.transform=Xt.matrix,Xt.userData.transformData&&(it.eulerOrder=Xt.userData.transformData.eulerOrder))}),it.transform||(it.transform=new f.Matrix4),"PreRotation"in Be&&(it.preRotation=Be.PreRotation.value),"PostRotation"in Be&&(it.postRotation=Be.PostRotation.value),D[se]=it}D[se]&&(D[se][Ue.attr]=Ue)}else if(Ue.curves.morph!==void 0){if(D[se]===void 0){var Be,Et=de.get(ue.ID).parents.filter(function(Xt){return Xt.relationship!==void 0})[0].ID,bt=de.get(Et).parents[0].ID,on=de.get(bt).parents[0].ID,Qt=de.get(on).parents[0].ID;it={modelName:(Be=be.Objects.Model[Qt]).attrName?f.PropertyBinding.sanitizeNodeName(Be.attrName):"",morphName:be.Objects.Deformer[Et].attrName},D[se]=it}D[se][Ue.attr]=Ue}}}),y.set(parseInt(_),D))}return y},parseAnimStacks:function(v){var M=be.Objects.AnimationStack,y={};for(var _ in M){var D=de.get(parseInt(_)).children;D.length>1&&console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.");var ie=v.get(D[0].ID);y[_]={name:M[_].attrName,layer:ie}}return y},addClip:function(v){var M=[],y=this;return v.layer.forEach(function(_){M=M.concat(y.generateTracks(_))}),new f.AnimationClip(v.name,-1,M)},generateTracks:function(v){var M=[],y=new f.Vector3,_=new f.Quaternion,D=new f.Vector3;if(v.transform&&v.transform.decompose(y,_,D),y=y.toArray(),_=new f.Euler().setFromQuaternion(_,v.eulerOrder).toArray(),D=D.toArray(),v.T!==void 0&&Object.keys(v.T.curves).length>0){var ie=this.generateVectorTrack(v.modelName,v.T.curves,y,"position");ie!==void 0&&M.push(ie)}if(v.R!==void 0&&Object.keys(v.R.curves).length>0){var ue=this.generateRotationTrack(v.modelName,v.R.curves,_,v.preRotation,v.postRotation,v.eulerOrder);ue!==void 0&&M.push(ue)}if(v.S!==void 0&&Object.keys(v.S.curves).length>0){var se=this.generateVectorTrack(v.modelName,v.S.curves,D,"scale");se!==void 0&&M.push(se)}if(v.DeformPercent!==void 0){var Ue=this.generateMorphTrack(v);Ue!==void 0&&M.push(Ue)}return M},generateVectorTrack:function(v,M,y,_){var D=this.getTimesForAllAxes(M),ie=this.getKeyframeTrackValues(D,M,y);return new f.VectorKeyframeTrack(v+"."+_,D,ie)},generateRotationTrack:function(v,M,y,_,D,ie){M.x!==void 0&&(this.interpolateRotations(M.x),M.x.values=M.x.values.map(f.MathUtils.degToRad)),M.y!==void 0&&(this.interpolateRotations(M.y),M.y.values=M.y.values.map(f.MathUtils.degToRad)),M.z!==void 0&&(this.interpolateRotations(M.z),M.z.values=M.z.values.map(f.MathUtils.degToRad));var ue=this.getTimesForAllAxes(M),se=this.getKeyframeTrackValues(ue,M,y);_!==void 0&&((_=_.map(f.MathUtils.degToRad)).push(ie),_=new f.Euler().fromArray(_),_=new f.Quaternion().setFromEuler(_)),D!==void 0&&((D=D.map(f.MathUtils.degToRad)).push(ie),D=new f.Euler().fromArray(D),D=new f.Quaternion().setFromEuler(D).invert());for(var Ue=new f.Quaternion,it=new f.Euler,Be=[],Et=0;Et<se.length;Et+=3)it.set(se[Et],se[Et+1],se[Et+2],ie),Ue.setFromEuler(it),_!==void 0&&Ue.premultiply(_),D!==void 0&&Ue.multiply(D),Ue.toArray(Be,Et/3*4);return new f.QuaternionKeyframeTrack(v+".quaternion",ue,Be)},generateMorphTrack:function(v){var M=v.DeformPercent.curves.morph,y=M.values.map(function(D){return D/100}),_=re.getObjectByName(v.modelName).morphTargetDictionary[v.morphName];return new f.NumberKeyframeTrack(v.modelName+".morphTargetInfluences["+_+"]",M.times,y)},getTimesForAllAxes:function(v){var M=[];return v.x!==void 0&&(M=M.concat(v.x.times)),v.y!==void 0&&(M=M.concat(v.y.times)),v.z!==void 0&&(M=M.concat(v.z.times)),M=M.sort(function(y,_){return y-_}).filter(function(y,_,D){return D.indexOf(y)==_})},getKeyframeTrackValues:function(v,M,y){var _=y,D=[],ie=-1,ue=-1,se=-1;return v.forEach(function(Ue){if(M.x&&(ie=M.x.times.indexOf(Ue)),M.y&&(ue=M.y.times.indexOf(Ue)),M.z&&(se=M.z.times.indexOf(Ue)),ie!==-1){var it=M.x.values[ie];D.push(it),_[0]=it}else D.push(_[0]);if(ue!==-1){var Be=M.y.values[ue];D.push(Be),_[1]=Be}else D.push(_[1]);if(se!==-1){var Et=M.z.values[se];D.push(Et),_[2]=Et}else D.push(_[2])}),D},interpolateRotations:function(v){for(var M=1;M<v.values.length;M++){var y=v.values[M-1],_=v.values[M]-y,D=Math.abs(_);if(D>=180){for(var ie=D/180,ue=_/ie,se=y+ue,Ue=v.times[M-1],it=(v.times[M]-Ue)/ie,Be=Ue+it,Et=[],bt=[];Be<v.times[M];)Et.push(Be),Be+=it,bt.push(se),se+=ue;v.times=Ce(v.times,M,Et),v.values=Ce(v.values,M,bt)}}}},O.prototype={constructor:O,getPrevNode:function(){return this.nodeStack[this.currentIndent-2]},getCurrentNode:function(){return this.nodeStack[this.currentIndent-1]},getCurrentProp:function(){return this.currentProp},pushStack:function(v){this.nodeStack.push(v),this.currentIndent+=1},popStack:function(){this.nodeStack.pop(),this.currentIndent-=1},setCurrentProp:function(v,M){this.currentProp=v,this.currentPropName=M},parse:function(v){this.currentIndent=0,this.allNodes=new j,this.nodeStack=[],this.currentProp=[],this.currentPropName="";var M=this,y=v.split(/[\r\n]+/);return y.forEach(function(_,D){var ie=_.match(/^[\s\t]*;/),ue=_.match(/^[\s\t]*$/);if(!ie&&!ue){var se=_.match("^\\t{"+M.currentIndent+"}(\\w+):(.*){",""),Ue=_.match("^\\t{"+M.currentIndent+"}(\\w+):[\\s\\t\\r\\n](.*)"),it=_.match("^\\t{"+(M.currentIndent-1)+"}}");se?M.parseNodeBegin(_,se):Ue?M.parseNodeProperty(_,Ue,y[++D]):it?M.popStack():_.match(/^[^\s\t}]/)&&M.parseNodePropertyContinued(_)}}),this.allNodes},parseNodeBegin:function(v,M){var y=M[1].trim().replace(/^"/,"").replace(/"$/,""),_=M[2].split(",").map(function(se){return se.trim().replace(/^"/,"").replace(/"$/,"")}),D={name:y},ie=this.parseNodeAttr(_),ue=this.getCurrentNode();this.currentIndent===0?this.allNodes.add(y,D):y in ue?(y==="PoseNode"?ue.PoseNode.push(D):ue[y].id!==void 0&&(ue[y]={},ue[y][ue[y].id]=ue[y]),ie.id!==""&&(ue[y][ie.id]=D)):typeof ie.id=="number"?(ue[y]={},ue[y][ie.id]=D):y!=="Properties70"&&(ue[y]=y==="PoseNode"?[D]:D),typeof ie.id=="number"&&(D.id=ie.id),ie.name!==""&&(D.attrName=ie.name),ie.type!==""&&(D.attrType=ie.type),this.pushStack(D)},parseNodeAttr:function(v){var M=v[0];v[0]!==""&&(M=parseInt(v[0]),isNaN(M)&&(M=v[0]));var y="",_="";return v.length>1&&(y=v[1].replace(/^(\w+)::/,""),_=v[2]),{id:M,name:y,type:_}},parseNodeProperty:function(v,M,y){var _=M[1].replace(/^"/,"").replace(/"$/,"").trim(),D=M[2].replace(/^"/,"").replace(/"$/,"").trim();_==="Content"&&D===","&&(D=y.replace(/"/g,"").replace(/,$/,"").trim());var ie=this.getCurrentNode();if(ie.name!=="Properties70"){if(_==="C"){var ue=D.split(",").slice(1),se=parseInt(ue[0]),Ue=parseInt(ue[1]),it=D.split(",").slice(3);_="connections",function(Be,Et){for(var bt=0,on=Be.length,Qt=Et.length;bt<Qt;bt++,on++)Be[on]=Et[bt]}(D=[se,Ue],it=it.map(function(Be){return Be.trim().replace(/^"/,"")})),ie[_]===void 0&&(ie[_]=[])}_==="Node"&&(ie.id=D),_ in ie&&Array.isArray(ie[_])?ie[_].push(D):_!=="a"?ie[_]=D:ie.a=D,this.setCurrentProp(ie,_),_==="a"&&D.slice(-1)!==","&&(ie.a=pe(D))}else this.parseNodeSpecialProperty(v,_,D)},parseNodePropertyContinued:function(v){var M=this.getCurrentNode();M.a+=v,v.slice(-1)!==","&&(M.a=pe(M.a))},parseNodeSpecialProperty:function(v,M,y){var _=y.split('",').map(function(it){return it.trim().replace(/^\"/,"").replace(/\s/,"_")}),D=_[0],ie=_[1],ue=_[2],se=_[3],Ue=_[4];switch(ie){case"int":case"enum":case"bool":case"ULongLong":case"double":case"Number":case"FieldOfView":Ue=parseFloat(Ue);break;case"Color":case"ColorRGB":case"Vector3D":case"Lcl_Translation":case"Lcl_Rotation":case"Lcl_Scaling":Ue=pe(Ue)}this.getPrevNode()[D]={type:ie,type2:ue,flag:se,value:Ue},this.setCurrentProp(this.getPrevNode(),D)}},C.prototype={constructor:C,parse:function(v){var M=new V(v);M.skip(23);var y=M.getUint32();if(y<6400)throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: "+y);for(var _=new j;!this.endOfContent(M);){var D=this.parseNode(M,y);D!==null&&_.add(D.name,D)}return _},endOfContent:function(v){return v.size()%16==0?(v.getOffset()+160+16&-16)>=v.size():v.getOffset()+160+16>=v.size()},parseNode:function(v,M){var y={},_=M>=7500?v.getUint64():v.getUint32(),D=M>=7500?v.getUint64():v.getUint32();M>=7500?v.getUint64():v.getUint32();var ie=v.getUint8(),ue=v.getString(ie);if(_===0)return null;for(var se=[],Ue=0;Ue<D;Ue++)se.push(this.parseProperty(v));var it=se.length>0?se[0]:"",Be=se.length>1?se[1]:"",Et=se.length>2?se[2]:"";for(y.singleProperty=D===1&&v.getOffset()===_;_>v.getOffset();){var bt=this.parseNode(v,M);bt!==null&&this.parseSubNode(ue,y,bt)}return y.propertyList=se,typeof it=="number"&&(y.id=it),Be!==""&&(y.attrName=Be),Et!==""&&(y.attrType=Et),ue!==""&&(y.name=ue),y},parseSubNode:function(v,M,y){if(y.singleProperty===!0){var _=y.propertyList[0];Array.isArray(_)?(M[y.name]=y,y.a=_):M[y.name]=_}else if(v==="Connections"&&y.name==="C"){var D=[];y.propertyList.forEach(function(Be,Et){Et!==0&&D.push(Be)}),M.connections===void 0&&(M.connections=[]),M.connections.push(D)}else if(y.name==="Properties70")Object.keys(y).forEach(function(Be){M[Be]=y[Be]});else if(v==="Properties70"&&y.name==="P"){var ie,ue=y.propertyList[0],se=y.propertyList[1],Ue=y.propertyList[2],it=y.propertyList[3];ue.indexOf("Lcl ")===0&&(ue=ue.replace("Lcl ","Lcl_")),se.indexOf("Lcl ")===0&&(se=se.replace("Lcl ","Lcl_")),ie=se==="Color"||se==="ColorRGB"||se==="Vector"||se==="Vector3D"||se.indexOf("Lcl_")===0?[y.propertyList[4],y.propertyList[5],y.propertyList[6]]:y.propertyList[4],M[ue]={type:se,type2:Ue,flag:it,value:ie}}else M[y.name]===void 0?typeof y.id=="number"?(M[y.name]={},M[y.name][y.id]=y):M[y.name]=y:y.name==="PoseNode"?(Array.isArray(M[y.name])||(M[y.name]=[M[y.name]]),M[y.name].push(y)):M[y.name][y.id]===void 0&&(M[y.name][y.id]=y)},parseProperty:function(v){var M=v.getString(1);switch(M){case"C":return v.getBoolean();case"D":return v.getFloat64();case"F":return v.getFloat32();case"I":return v.getInt32();case"L":return v.getInt64();case"R":var y=v.getUint32();return v.getArrayBuffer(y);case"S":return y=v.getUint32(),v.getString(y);case"Y":return v.getInt16();case"b":case"c":case"d":case"f":case"i":case"l":var _=v.getUint32(),D=v.getUint32(),ie=v.getUint32();if(D===0)switch(M){case"b":case"c":return v.getBooleanArray(_);case"d":return v.getFloat64Array(_);case"f":return v.getFloat32Array(_);case"i":return v.getInt32Array(_);case"l":return v.getInt64Array(_)}Tt===void 0&&console.error("THREE.FBXLoader: External library Inflate.min.js required, obtain or import from https://github.com/imaya/zlib.js");var ue=new V(new Tt(new Uint8Array(v.getArrayBuffer(ie))).decompress().buffer);switch(M){case"b":case"c":return ue.getBooleanArray(_);case"d":return ue.getFloat64Array(_);case"f":return ue.getFloat32Array(_);case"i":return ue.getInt32Array(_);case"l":return ue.getInt64Array(_)}default:throw new Error("THREE.FBXLoader: Unknown property type "+M)}}},V.prototype={constructor:V,getOffset:function(){return this.offset},size:function(){return this.dv.buffer.byteLength},skip:function(v){this.offset+=v},getBoolean:function(){return(1&this.getUint8())==1},getBooleanArray:function(v){for(var M=[],y=0;y<v;y++)M.push(this.getBoolean());return M},getUint8:function(){var v=this.dv.getUint8(this.offset);return this.offset+=1,v},getInt16:function(){var v=this.dv.getInt16(this.offset,this.littleEndian);return this.offset+=2,v},getInt32:function(){var v=this.dv.getInt32(this.offset,this.littleEndian);return this.offset+=4,v},getInt32Array:function(v){for(var M=[],y=0;y<v;y++)M.push(this.getInt32());return M},getUint32:function(){var v=this.dv.getUint32(this.offset,this.littleEndian);return this.offset+=4,v},getInt64:function(){var v,M;return this.littleEndian?(v=this.getUint32(),M=this.getUint32()):(M=this.getUint32(),v=this.getUint32()),2147483648&M?(M=4294967295&~M,(v=4294967295&~v)===4294967295&&(M=M+1&4294967295),-(4294967296*M+(v=v+1&4294967295))):4294967296*M+v},getInt64Array:function(v){for(var M=[],y=0;y<v;y++)M.push(this.getInt64());return M},getUint64:function(){var v,M;return this.littleEndian?(v=this.getUint32(),M=this.getUint32()):(M=this.getUint32(),v=this.getUint32()),4294967296*M+v},getFloat32:function(){var v=this.dv.getFloat32(this.offset,this.littleEndian);return this.offset+=4,v},getFloat32Array:function(v){for(var M=[],y=0;y<v;y++)M.push(this.getFloat32());return M},getFloat64:function(){var v=this.dv.getFloat64(this.offset,this.littleEndian);return this.offset+=8,v},getFloat64Array:function(v){for(var M=[],y=0;y<v;y++)M.push(this.getFloat64());return M},getArrayBuffer:function(v){var M=this.dv.buffer.slice(this.offset,this.offset+v);return this.offset+=v,M},getString:function(v){for(var M=[],y=0;y<v;y++)M[y]=this.getUint8();var _=M.indexOf(0);return _>=0&&(M=M.slice(0,_)),f.LoaderUtils.decodeText(new Uint8Array(M))}},j.prototype={constructor:j,add:function(v,M){this[v]=M}};var w=[];function $(v,M,y,_){var D;switch(_.mappingType){case"ByPolygonVertex":D=v;break;case"ByPolygon":D=M;break;case"ByVertice":D=y;break;case"AllSame":D=_.indices[0];break;default:console.warn("THREE.FBXLoader: unknown attribute mapping type "+_.mappingType)}_.referenceType==="IndexToDirect"&&(D=_.indices[D]);var ie=D*_.dataSize,ue=ie+_.dataSize;return function(se,Ue,it,Be){for(var Et=it,bt=0;Et<Be;Et++,bt++)se[bt]=Ue[Et];return se}(w,_.buffer,ie,ue)}var ye=new f.Euler,_e=new f.Vector3;function W(v){var M,y=new f.Matrix4,_=new f.Matrix4,D=new f.Matrix4,ie=new f.Matrix4,ue=new f.Matrix4,se=new f.Matrix4,Ue=new f.Matrix4,it=new f.Matrix4,Be=new f.Matrix4,Et=new f.Matrix4,bt=new f.Matrix4,on=v.inheritType?v.inheritType:0;(v.translation&&y.setPosition(_e.fromArray(v.translation)),v.preRotation)&&((M=v.preRotation.map(f.MathUtils.degToRad)).push(v.eulerOrder),_.makeRotationFromEuler(ye.fromArray(M))),v.rotation&&((M=v.rotation.map(f.MathUtils.degToRad)).push(v.eulerOrder),D.makeRotationFromEuler(ye.fromArray(M))),v.postRotation&&((M=v.postRotation.map(f.MathUtils.degToRad)).push(v.eulerOrder),ie.makeRotationFromEuler(ye.fromArray(M))),v.scale&&ue.scale(_e.fromArray(v.scale)),v.scalingOffset&&Ue.setPosition(_e.fromArray(v.scalingOffset)),v.scalingPivot&&se.setPosition(_e.fromArray(v.scalingPivot)),v.rotationOffset&&it.setPosition(_e.fromArray(v.rotationOffset)),v.rotationPivot&&Be.setPosition(_e.fromArray(v.rotationPivot)),v.parentMatrixWorld&&(Et=v.parentMatrixWorld);var Qt=_.multiply(D).multiply(ie),Xt=new f.Matrix4;Et.extractRotation(Xt),new f.Matrix4().copyPosition(Et);var wn=new f.Matrix4;wn.copy(Xt).invert().multiply(Et);var gn=new f.Matrix4;if(on===0)gn.copy(Xt).multiply(Qt).multiply(wn).multiply(ue);else if(on===1)gn.copy(Xt).multiply(wn).multiply(Qt).multiply(ue);else{var sn=new f.Matrix4;sn.copy(ue).invert();var On=new f.Matrix4().multiply(wn).multiply(sn);gn.copy(Xt).multiply(Qt).multiply(On).multiply(ue)}var Zn=new f.Matrix4;Zn.copy(Be).invert();var Dn=new f.Matrix4;Dn.copy(se).invert();var Cn=new f.Matrix4;Cn.copy(y).multiply(it).multiply(Be).multiply(_).multiply(D).multiply(ie).multiply(Zn).multiply(Ue).multiply(se).multiply(ue).multiply(Dn);var Tn=new f.Matrix4().copyPosition(Cn),Jn=new f.Matrix4().copy(Et).multiply(Tn);return bt.copyPosition(Jn),Cn=new f.Matrix4().multiply(bt).multiply(gn)}function ae(v){var M=["ZYX","YZX","XZY","ZXY","YXZ","XYZ"];return(v=v||0)===6?(console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."),M[0]):M[v]}function pe(v){return v.split(",").map(function(M){return parseFloat(M)})}function Fe(v,M,y){return M===void 0&&(M=0),y===void 0&&(y=v.byteLength),f.LoaderUtils.decodeText(new Uint8Array(v,M,y))}function Ce(v,M,y){return v.slice(0,M).concat(y).concat(v.slice(M))}return q}()},function(rt,h,l){l.r(h),l.d(h,"Water",function(){return I});var f=l(0),A=function(E,U){f.Mesh.call(this,E),this.type="Reflector";var G=this,Y=(U=U||{}).color!==void 0?new f.Color(U.color):new f.Color(8355711),we=U.textureWidth||512,Se=U.textureHeight||512,Me=U.clipBias||0,T=U.shader||A.ReflectorShader,Z=new f.Plane,J=new f.Vector3,L=new f.Vector3,N=new f.Vector3,X=new f.Matrix4,Q=new f.Vector3(0,0,-1),oe=new f.Vector4,me=new f.Vector3,Te=new f.Vector3,Pe=new f.Vector4,Re=new f.Matrix4,Ee=new f.PerspectiveCamera,Ye={minFilter:f.LinearFilter,magFilter:f.LinearFilter,format:f.RGBFormat},Qe=new f.WebGLRenderTarget(we,Se,Ye);f.MathUtils.isPowerOfTwo(we)&&f.MathUtils.isPowerOfTwo(Se)||(Qe.texture.generateMipmaps=!1);var lt=new f.ShaderMaterial({uniforms:f.UniformsUtils.clone(T.uniforms),fragmentShader:T.fragmentShader,vertexShader:T.vertexShader});lt.uniforms.tDiffuse.value=Qe.texture,lt.uniforms.color.value=Y,lt.uniforms.textureMatrix.value=Re,this.material=lt,this.onBeforeRender=function(ot,Ne,at){if(L.setFromMatrixPosition(G.matrixWorld),N.setFromMatrixPosition(at.matrixWorld),X.extractRotation(G.matrixWorld),J.set(0,0,1),J.applyMatrix4(X),me.subVectors(L,N),!(me.dot(J)>0)){me.reflect(J).negate(),me.add(L),X.extractRotation(at.matrixWorld),Q.set(0,0,-1),Q.applyMatrix4(X),Q.add(N),Te.subVectors(L,Q),Te.reflect(J).negate(),Te.add(L),Ee.position.copy(me),Ee.up.set(0,1,0),Ee.up.applyMatrix4(X),Ee.up.reflect(J),Ee.lookAt(Te),Ee.far=at.far,Ee.updateMatrixWorld(),Ee.projectionMatrix.copy(at.projectionMatrix),Re.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),Re.multiply(Ee.projectionMatrix),Re.multiply(Ee.matrixWorldInverse),Re.multiply(G.matrixWorld),Z.setFromNormalAndCoplanarPoint(J,L),Z.applyMatrix4(Ee.matrixWorldInverse),oe.set(Z.normal.x,Z.normal.y,Z.normal.z,Z.constant);var $e=Ee.projectionMatrix;Pe.x=(Math.sign(oe.x)+$e.elements[8])/$e.elements[0],Pe.y=(Math.sign(oe.y)+$e.elements[9])/$e.elements[5],Pe.z=-1,Pe.w=(1+$e.elements[10])/$e.elements[14],oe.multiplyScalar(2/oe.dot(Pe)),$e.elements[2]=oe.x,$e.elements[6]=oe.y,$e.elements[10]=oe.z+1-Me,$e.elements[14]=oe.w,Qe.texture.encoding=ot.outputEncoding,G.visible=!1;var ut=ot.getRenderTarget(),pt=ot.xr.enabled,Ot=ot.shadowMap.autoUpdate;ot.xr.enabled=!1,ot.shadowMap.autoUpdate=!1,ot.setRenderTarget(Qe),ot.state.buffers.depth.setMask(!0),ot.autoClear===!1&&ot.clear(),ot.render(Ne,Ee),ot.xr.enabled=pt,ot.shadowMap.autoUpdate=Ot,ot.setRenderTarget(ut);var It=at.viewport;It!==void 0&&ot.state.viewport(It),G.visible=!0}},this.getRenderTarget=function(){return Qe}};A.prototype=Object.create(f.Mesh.prototype),A.prototype.constructor=A,A.ReflectorShader={uniforms:{color:{value:null},tDiffuse:{value:null},textureMatrix:{value:null}},vertexShader:["uniform mat4 textureMatrix;","varying vec4 vUv;","void main() {","	vUv = textureMatrix * vec4( position, 1.0 );","	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join(`
`),fragmentShader:["uniform vec3 color;","uniform sampler2D tDiffuse;","varying vec4 vUv;","float blendOverlay( float base, float blend ) {","	return( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );","}","vec3 blendOverlay( vec3 base, vec3 blend ) {","	return vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );","}","void main() {","	vec4 base = texture2DProj( tDiffuse, vUv );","	gl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );","}"].join(`
`)};var P=function(E,U){f.Mesh.call(this,E),this.type="Refractor";var G=this,Y=(U=U||{}).color!==void 0?new f.Color(U.color):new f.Color(8355711),we=U.textureWidth||512,Se=U.textureHeight||512,Me=U.clipBias||0,T=U.shader||P.RefractorShader,Z=new f.PerspectiveCamera;Z.matrixAutoUpdate=!1,Z.userData.refractor=!0;var J=new f.Plane,L=new f.Matrix4,N={minFilter:f.LinearFilter,magFilter:f.LinearFilter,format:f.RGBFormat},X=new f.WebGLRenderTarget(we,Se,N);f.MathUtils.isPowerOfTwo(we)&&f.MathUtils.isPowerOfTwo(Se)||(X.texture.generateMipmaps=!1),this.material=new f.ShaderMaterial({uniforms:f.UniformsUtils.clone(T.uniforms),vertexShader:T.vertexShader,fragmentShader:T.fragmentShader,transparent:!0}),this.material.uniforms.color.value=Y,this.material.uniforms.tDiffuse.value=X.texture,this.material.uniforms.textureMatrix.value=L;var Q,oe,me,Te,Pe,Re,Ee,Ye,Qe=(Q=new f.Vector3,oe=new f.Vector3,me=new f.Matrix4,Te=new f.Vector3,Pe=new f.Vector3,function(Ne){return Q.setFromMatrixPosition(G.matrixWorld),oe.setFromMatrixPosition(Ne.matrixWorld),Te.subVectors(Q,oe),me.extractRotation(G.matrixWorld),Pe.set(0,0,1),Pe.applyMatrix4(me),Te.dot(Pe)<0}),lt=function(){var Ne=new f.Vector3,at=new f.Vector3,$e=new f.Quaternion,ut=new f.Vector3;return function(){G.matrixWorld.decompose(at,$e,ut),Ne.set(0,0,1).applyQuaternion($e).normalize(),Ne.negate(),J.setFromNormalAndCoplanarPoint(Ne,at)}}(),ot=(Re=new f.Plane,Ee=new f.Vector4,Ye=new f.Vector4,function(Ne){Z.matrixWorld.copy(Ne.matrixWorld),Z.matrixWorldInverse.copy(Z.matrixWorld).invert(),Z.projectionMatrix.copy(Ne.projectionMatrix),Z.far=Ne.far,Re.copy(J),Re.applyMatrix4(Z.matrixWorldInverse),Ee.set(Re.normal.x,Re.normal.y,Re.normal.z,Re.constant);var at=Z.projectionMatrix;Ye.x=(Math.sign(Ee.x)+at.elements[8])/at.elements[0],Ye.y=(Math.sign(Ee.y)+at.elements[9])/at.elements[5],Ye.z=-1,Ye.w=(1+at.elements[10])/at.elements[14],Ee.multiplyScalar(2/Ee.dot(Ye)),at.elements[2]=Ee.x,at.elements[6]=Ee.y,at.elements[10]=Ee.z+1-Me,at.elements[14]=Ee.w});this.onBeforeRender=function(Ne,at,$e){X.texture.encoding=Ne.outputEncoding,$e.userData.refractor!==!0&&!Qe($e)!=!0&&(lt(),function(ut){L.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),L.multiply(ut.projectionMatrix),L.multiply(ut.matrixWorldInverse),L.multiply(G.matrixWorld)}($e),ot($e),function(ut,pt,Ot){G.visible=!1;var It=ut.getRenderTarget(),Bt=ut.xr.enabled,Wt=ut.shadowMap.autoUpdate;ut.xr.enabled=!1,ut.shadowMap.autoUpdate=!1,ut.setRenderTarget(X),ut.autoClear===!1&&ut.clear(),ut.render(pt,Z),ut.xr.enabled=Bt,ut.shadowMap.autoUpdate=Wt,ut.setRenderTarget(It);var Tt=Ot.viewport;Tt!==void 0&&ut.state.viewport(Tt),G.visible=!0}(Ne,at,$e))},this.getRenderTarget=function(){return X}};P.prototype=Object.create(f.Mesh.prototype),P.prototype.constructor=P,P.RefractorShader={uniforms:{color:{value:null},tDiffuse:{value:null},textureMatrix:{value:null}},vertexShader:["uniform mat4 textureMatrix;","varying vec4 vUv;","void main() {","	vUv = textureMatrix * vec4( position, 1.0 );","	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join(`
`),fragmentShader:["uniform vec3 color;","uniform sampler2D tDiffuse;","varying vec4 vUv;","float blendOverlay( float base, float blend ) {","	return( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );","}","vec3 blendOverlay( vec3 base, vec3 blend ) {","	return vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );","}","void main() {","	vec4 base = texture2DProj( tDiffuse, vUv );","	gl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );","}"].join(`
`)};var I=function(E,U){f.Mesh.call(this,E),this.type="Water";var G=this,Y=(U=U||{}).color!==void 0?new f.Color(U.color):new f.Color(16777215),we=U.textureWidth||512,Se=U.textureHeight||512,Me=U.clipBias||0,T=U.flowDirection||new f.Vector2(1,0),Z=U.flowSpeed||.03,J=U.reflectivity||.02,L=U.scale||1,N=U.shader||I.WaterShader,X=U.encoding!==void 0?U.encoding:f.LinearEncoding,Q=new f.TextureLoader,oe=U.flowMap||void 0,me=U.normalMap0||Q.load("textures/water/Water_1_M_Normal.jpg"),Te=U.normalMap1||Q.load("textures/water/Water_2_M_Normal.jpg"),Pe=new f.Matrix4,Re=new f.Clock;if(A!==void 0)if(P!==void 0){var Ee=new A(E,{textureWidth:we,textureHeight:Se,clipBias:Me,encoding:X}),Ye=new P(E,{textureWidth:we,textureHeight:Se,clipBias:Me,encoding:X});Ee.matrixAutoUpdate=!1,Ye.matrixAutoUpdate=!1,this.material=new f.ShaderMaterial({uniforms:f.UniformsUtils.merge([f.UniformsLib.fog,N.uniforms]),vertexShader:N.vertexShader,fragmentShader:N.fragmentShader,transparent:!0,fog:!0}),oe!==void 0?(this.material.defines.USE_FLOWMAP="",this.material.uniforms.tFlowMap={type:"t",value:oe}):this.material.uniforms.flowDirection={type:"v2",value:T},me.wrapS=me.wrapT=f.RepeatWrapping,Te.wrapS=Te.wrapT=f.RepeatWrapping,this.material.uniforms.tReflectionMap.value=Ee.getRenderTarget().texture,this.material.uniforms.tRefractionMap.value=Ye.getRenderTarget().texture,this.material.uniforms.tNormalMap0.value=me,this.material.uniforms.tNormalMap1.value=Te,this.material.uniforms.color.value=Y,this.material.uniforms.reflectivity.value=J,this.material.uniforms.textureMatrix.value=Pe,this.material.uniforms.config.value.x=0,this.material.uniforms.config.value.y=.075,this.material.uniforms.config.value.z=.075,this.material.uniforms.config.value.w=L,this.onBeforeRender=function(Qe,lt,ot){var Ne,at;!function($e){Pe.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),Pe.multiply($e.projectionMatrix),Pe.multiply($e.matrixWorldInverse),Pe.multiply(G.matrixWorld)}(ot),Ne=Re.getDelta(),(at=G.material.uniforms.config).value.x+=Z*Ne,at.value.y=at.value.x+.075,at.value.x>=.15?(at.value.x=0,at.value.y=.075):at.value.y>=.15&&(at.value.y=at.value.y-.15),G.visible=!1,Ee.matrixWorld.copy(G.matrixWorld),Ye.matrixWorld.copy(G.matrixWorld),Ee.onBeforeRender(Qe,lt,ot),Ye.onBeforeRender(Qe,lt,ot),G.visible=!0}}else console.error("THREE.Water: Required component Refractor not found.");else console.error("THREE.Water: Required component Reflector not found.")};I.prototype=Object.create(f.Mesh.prototype),I.prototype.constructor=I,I.WaterShader={uniforms:{color:{type:"c",value:null},reflectivity:{type:"f",value:0},tReflectionMap:{type:"t",value:null},tRefractionMap:{type:"t",value:null},tNormalMap0:{type:"t",value:null},tNormalMap1:{type:"t",value:null},textureMatrix:{type:"m4",value:null},config:{type:"v4",value:new f.Vector4}},vertexShader:["#include <common>","#include <fog_pars_vertex>","#include <logdepthbuf_pars_vertex>","uniform mat4 textureMatrix;","varying vec4 vCoord;","varying vec2 vUv;","varying vec3 vToEye;","void main() {","	vUv = uv;","	vCoord = textureMatrix * vec4( position, 1.0 );","	vec4 worldPosition = modelMatrix * vec4( position, 1.0 );","	vToEye = cameraPosition - worldPosition.xyz;","	vec4 mvPosition =  viewMatrix * worldPosition;","	gl_Position = projectionMatrix * mvPosition;","	#include <logdepthbuf_vertex>","	#include <fog_vertex>","}"].join(`
`),fragmentShader:["#include <common>","#include <fog_pars_fragment>","#include <logdepthbuf_pars_fragment>","uniform sampler2D tReflectionMap;","uniform sampler2D tRefractionMap;","uniform sampler2D tNormalMap0;","uniform sampler2D tNormalMap1;","#ifdef USE_FLOWMAP","	uniform sampler2D tFlowMap;","#else","	uniform vec2 flowDirection;","#endif","uniform vec3 color;","uniform float reflectivity;","uniform vec4 config;","varying vec4 vCoord;","varying vec2 vUv;","varying vec3 vToEye;","void main() {","	#include <logdepthbuf_fragment>","	float flowMapOffset0 = config.x;","	float flowMapOffset1 = config.y;","	float halfCycle = config.z;","	float scale = config.w;","	vec3 toEye = normalize( vToEye );","	vec2 flow;","	#ifdef USE_FLOWMAP","		flow = texture2D( tFlowMap, vUv ).rg * 2.0 - 1.0;","	#else","		flow = flowDirection;","	#endif","	flow.x *= - 1.0;","	vec4 normalColor0 = texture2D( tNormalMap0, ( vUv * scale ) + flow * flowMapOffset0 );","	vec4 normalColor1 = texture2D( tNormalMap1, ( vUv * scale ) + flow * flowMapOffset1 );","	float flowLerp = abs( halfCycle - flowMapOffset0 ) / halfCycle;","	vec4 normalColor = mix( normalColor0, normalColor1, flowLerp );","	vec3 normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );","	float theta = max( dot( toEye, normal ), 0.0 );","	float reflectance = reflectivity + ( 1.0 - reflectivity ) * pow( ( 1.0 - theta ), 5.0 );","	vec3 coord = vCoord.xyz / vCoord.w;","	vec2 uv = coord.xy + coord.z * normal.xz * 0.05;","	vec4 reflectColor = texture2D( tReflectionMap, vec2( 1.0 - uv.x, uv.y ) );","	vec4 refractColor = texture2D( tRefractionMap, uv );","	gl_FragColor = vec4( color, 1.0 ) * mix( refractColor, reflectColor, reflectance );","	#include <tonemapping_fragment>","	#include <encodings_fragment>","	#include <fog_fragment>","}"].join(`
`)}},function(rt,h,l){l.r(h),l.d(h,"EffectComposer",function(){return G}),l.d(h,"Pass",function(){return Me});var f=l(0),A={uniforms:{tDiffuse:{value:null},opacity:{value:1}},vertexShader:["varying vec2 vUv;","void main() {","	vUv = uv;","	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join(`
`),fragmentShader:["uniform float opacity;","uniform sampler2D tDiffuse;","varying vec2 vUv;","void main() {","	vec4 texel = texture2D( tDiffuse, vUv );","	gl_FragColor = opacity * texel;","}"].join(`
`)},P=l(2),I=l(1),E=function(T,Z){I.a.call(this),this.scene=T,this.camera=Z,this.clear=!0,this.needsSwap=!1,this.inverse=!1};E.prototype=Object.assign(Object.create(I.a.prototype),{constructor:E,render:function(T,Z,J){var L,N,X=T.getContext(),Q=T.state;Q.buffers.color.setMask(!1),Q.buffers.depth.setMask(!1),Q.buffers.color.setLocked(!0),Q.buffers.depth.setLocked(!0),this.inverse?(L=0,N=1):(L=1,N=0),Q.buffers.stencil.setTest(!0),Q.buffers.stencil.setOp(X.REPLACE,X.REPLACE,X.REPLACE),Q.buffers.stencil.setFunc(X.ALWAYS,L,4294967295),Q.buffers.stencil.setClear(N),Q.buffers.stencil.setLocked(!0),T.setRenderTarget(J),this.clear&&T.clear(),T.render(this.scene,this.camera),T.setRenderTarget(Z),this.clear&&T.clear(),T.render(this.scene,this.camera),Q.buffers.color.setLocked(!1),Q.buffers.depth.setLocked(!1),Q.buffers.stencil.setLocked(!1),Q.buffers.stencil.setFunc(X.EQUAL,1,4294967295),Q.buffers.stencil.setOp(X.KEEP,X.KEEP,X.KEEP),Q.buffers.stencil.setLocked(!0)}});var U=function(){I.a.call(this),this.needsSwap=!1};U.prototype=Object.create(I.a.prototype),Object.assign(U.prototype,{render:function(T){T.state.buffers.stencil.setLocked(!1),T.state.buffers.stencil.setTest(!1)}});var G=function(T,Z){if(this.renderer=T,Z===void 0){var J={minFilter:f.LinearFilter,magFilter:f.LinearFilter,format:f.RGBAFormat},L=T.getSize(new f.Vector2);this._pixelRatio=T.getPixelRatio(),this._width=L.width,this._height=L.height,(Z=new f.WebGLRenderTarget(this._width*this._pixelRatio,this._height*this._pixelRatio,J)).texture.name="EffectComposer.rt1"}else this._pixelRatio=1,this._width=Z.width,this._height=Z.height;this.renderTarget1=Z,this.renderTarget2=Z.clone(),this.renderTarget2.texture.name="EffectComposer.rt2",this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2,this.renderToScreen=!0,this.passes=[],A===void 0&&console.error("THREE.EffectComposer relies on CopyShader"),P.ShaderPass===void 0&&console.error("THREE.EffectComposer relies on ShaderPass"),this.copyPass=new P.ShaderPass(A),this.clock=new f.Clock};Object.assign(G.prototype,{swapBuffers:function(){var T=this.readBuffer;this.readBuffer=this.writeBuffer,this.writeBuffer=T},addPass:function(T){this.passes.push(T),T.setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)},insertPass:function(T,Z){this.passes.splice(Z,0,T),T.setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)},removePass:function(T){const Z=this.passes.indexOf(T);Z!==-1&&this.passes.splice(Z,1)},isLastEnabledPass:function(T){for(var Z=T+1;Z<this.passes.length;Z++)if(this.passes[Z].enabled)return!1;return!0},render:function(T){T===void 0&&(T=this.clock.getDelta());var Z,J,L=this.renderer.getRenderTarget(),N=!1,X=this.passes.length;for(J=0;J<X;J++)if((Z=this.passes[J]).enabled!==!1){if(Z.renderToScreen=this.renderToScreen&&this.isLastEnabledPass(J),Z.render(this.renderer,this.writeBuffer,this.readBuffer,T,N),Z.needsSwap){if(N){var Q=this.renderer.getContext(),oe=this.renderer.state.buffers.stencil;oe.setFunc(Q.NOTEQUAL,1,4294967295),this.copyPass.render(this.renderer,this.writeBuffer,this.readBuffer,T),oe.setFunc(Q.EQUAL,1,4294967295)}this.swapBuffers()}E!==void 0&&(Z instanceof E?N=!0:Z instanceof U&&(N=!1))}this.renderer.setRenderTarget(L)},reset:function(T){if(T===void 0){var Z=this.renderer.getSize(new f.Vector2);this._pixelRatio=this.renderer.getPixelRatio(),this._width=Z.width,this._height=Z.height,(T=this.renderTarget1.clone()).setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}this.renderTarget1.dispose(),this.renderTarget2.dispose(),this.renderTarget1=T,this.renderTarget2=T.clone(),this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2},setSize:function(T,Z){this._width=T,this._height=Z;var J=this._width*this._pixelRatio,L=this._height*this._pixelRatio;this.renderTarget1.setSize(J,L),this.renderTarget2.setSize(J,L);for(var N=0;N<this.passes.length;N++)this.passes[N].setSize(J,L)},setPixelRatio:function(T){this._pixelRatio=T,this.setSize(this._width,this._height)}});var Y,we,Se,Me=function(){this.enabled=!0,this.needsSwap=!0,this.clear=!1,this.renderToScreen=!1};Object.assign(Me.prototype,{setSize:function(){},render:function(){console.error("THREE.Pass: .render() must be implemented in derived pass.")}}),Me.FullScreenQuad=(Y=new f.OrthographicCamera(-1,1,1,-1,0,1),we=new f.PlaneBufferGeometry(2,2),Se=function(T){this._mesh=new f.Mesh(we,T)},Object.defineProperty(Se.prototype,"material",{get:function(){return this._mesh.material},set:function(T){this._mesh.material=T}}),Object.assign(Se.prototype,{dispose:function(){this._mesh.geometry.dispose()},render:function(T){T.render(this._mesh,Y)}}),Se)},function(rt,h,l){l.r(h),l.d(h,"ConvexGeometry",function(){return P}),l.d(h,"ConvexBufferGeometry",function(){return I});var f=l(0),A=function(){var E,U,G,Y,we=new f.Vector3;function Se(){this.tolerance=-1,this.faces=[],this.newFaces=[],this.assigned=new J,this.unassigned=new J,this.vertices=[]}function Me(){this.normal=new f.Vector3,this.midpoint=new f.Vector3,this.area=0,this.constant=0,this.outside=null,this.mark=0,this.edge=null}function T(L,N){this.vertex=L,this.prev=null,this.next=null,this.twin=null,this.face=N}function Z(L){this.point=L,this.prev=null,this.next=null,this.face=null}function J(){this.head=null,this.tail=null}return Object.assign(Se.prototype,{setFromPoints:function(L){Array.isArray(L)!==!0&&console.error("THREE.ConvexHull: Points parameter is not an array."),L.length<4&&console.error("THREE.ConvexHull: The algorithm needs at least four points."),this.makeEmpty();for(var N=0,X=L.length;N<X;N++)this.vertices.push(new Z(L[N]));return this.compute(),this},setFromObject:function(L){var N=[];return L.updateMatrixWorld(!0),L.traverse(function(X){var Q,oe,me,Te=X.geometry;if(Te!==void 0){if(Te.isGeometry){var Pe=Te.vertices;for(Q=0,oe=Pe.length;Q<oe;Q++)(me=Pe[Q].clone()).applyMatrix4(X.matrixWorld),N.push(me)}else if(Te.isBufferGeometry){var Re=Te.attributes.position;if(Re!==void 0)for(Q=0,oe=Re.count;Q<oe;Q++)(me=new f.Vector3).fromBufferAttribute(Re,Q).applyMatrix4(X.matrixWorld),N.push(me)}}}),this.setFromPoints(N)},containsPoint:function(L){for(var N=this.faces,X=0,Q=N.length;X<Q;X++)if(N[X].distanceToPoint(L)>this.tolerance)return!1;return!0},intersectRay:function(L,N){for(var X=this.faces,Q=-1/0,oe=1/0,me=0,Te=X.length;me<Te;me++){var Pe=X[me],Re=Pe.distanceToPoint(L.origin),Ee=Pe.normal.dot(L.direction);if(Re>0&&Ee>=0)return null;var Ye=Ee!==0?-Re/Ee:0;if(!(Ye<=0)&&(Ee>0?oe=Math.min(Ye,oe):Q=Math.max(Ye,Q),Q>oe))return null}return Q!==-1/0?L.at(Q,N):L.at(oe,N),N},intersectsRay:function(L){return this.intersectRay(L,we)!==null},makeEmpty:function(){return this.faces=[],this.vertices=[],this},addVertexToFace:function(L,N){return L.face=N,N.outside===null?this.assigned.append(L):this.assigned.insertBefore(N.outside,L),N.outside=L,this},removeVertexFromFace:function(L,N){return L===N.outside&&(L.next!==null&&L.next.face===N?N.outside=L.next:N.outside=null),this.assigned.remove(L),this},removeAllVerticesFromFace:function(L){if(L.outside!==null){for(var N=L.outside,X=L.outside;X.next!==null&&X.next.face===L;)X=X.next;return this.assigned.removeSubList(N,X),N.prev=X.next=null,L.outside=null,N}},deleteFaceVertices:function(L,N){var X=this.removeAllVerticesFromFace(L);if(X!==void 0)if(N===void 0)this.unassigned.appendChain(X);else{var Q=X;do{var oe=Q.next;N.distanceToPoint(Q.point)>this.tolerance?this.addVertexToFace(Q,N):this.unassigned.append(Q),Q=oe}while(Q!==null)}return this},resolveUnassignedPoints:function(L){if(this.unassigned.isEmpty()===!1){var N=this.unassigned.first();do{for(var X=N.next,Q=this.tolerance,oe=null,me=0;me<L.length;me++){var Te=L[me];if(Te.mark===0){var Pe=Te.distanceToPoint(N.point);if(Pe>Q&&(Q=Pe,oe=Te),Q>1e3*this.tolerance)break}}oe!==null&&this.addVertexToFace(N,oe),N=X}while(N!==null)}return this},computeExtremes:function(){var L,N,X,Q=new f.Vector3,oe=new f.Vector3,me=[],Te=[];for(L=0;L<3;L++)me[L]=Te[L]=this.vertices[0];for(Q.copy(this.vertices[0].point),oe.copy(this.vertices[0].point),L=0,N=this.vertices.length;L<N;L++){var Pe=this.vertices[L],Re=Pe.point;for(X=0;X<3;X++)Re.getComponent(X)<Q.getComponent(X)&&(Q.setComponent(X,Re.getComponent(X)),me[X]=Pe);for(X=0;X<3;X++)Re.getComponent(X)>oe.getComponent(X)&&(oe.setComponent(X,Re.getComponent(X)),Te[X]=Pe)}return this.tolerance=3*Number.EPSILON*(Math.max(Math.abs(Q.x),Math.abs(oe.x))+Math.max(Math.abs(Q.y),Math.abs(oe.y))+Math.max(Math.abs(Q.z),Math.abs(oe.z))),{min:me,max:Te}},computeInitialHull:function(){E===void 0&&(E=new f.Line3,U=new f.Plane,G=new f.Vector3);var L,N,X,Q,oe,me,Te,Pe,Re,Ee=this.vertices,Ye=this.computeExtremes(),Qe=Ye.min,lt=Ye.max,ot=0,Ne=0;for(me=0;me<3;me++)(Re=lt[me].point.getComponent(me)-Qe[me].point.getComponent(me))>ot&&(ot=Re,Ne=me);for(N=Qe[Ne],X=lt[Ne],ot=0,E.set(N.point,X.point),me=0,Te=this.vertices.length;me<Te;me++)(L=Ee[me])!==N&&L!==X&&(E.closestPointToPoint(L.point,!0,G),(Re=G.distanceToSquared(L.point))>ot&&(ot=Re,Q=L));for(ot=-1,U.setFromCoplanarPoints(N.point,X.point,Q.point),me=0,Te=this.vertices.length;me<Te;me++)(L=Ee[me])!==N&&L!==X&&L!==Q&&(Re=Math.abs(U.distanceToPoint(L.point)))>ot&&(ot=Re,oe=L);var at=[];if(U.distanceToPoint(oe.point)<0)for(at.push(Me.create(N,X,Q),Me.create(oe,X,N),Me.create(oe,Q,X),Me.create(oe,N,Q)),me=0;me<3;me++)Pe=(me+1)%3,at[me+1].getEdge(2).setTwin(at[0].getEdge(Pe)),at[me+1].getEdge(1).setTwin(at[Pe+1].getEdge(0));else for(at.push(Me.create(N,Q,X),Me.create(oe,N,X),Me.create(oe,X,Q),Me.create(oe,Q,N)),me=0;me<3;me++)Pe=(me+1)%3,at[me+1].getEdge(2).setTwin(at[0].getEdge((3-me)%3)),at[me+1].getEdge(0).setTwin(at[Pe+1].getEdge(1));for(me=0;me<4;me++)this.faces.push(at[me]);for(me=0,Te=Ee.length;me<Te;me++)if((L=Ee[me])!==N&&L!==X&&L!==Q&&L!==oe){ot=this.tolerance;var $e=null;for(Pe=0;Pe<4;Pe++)(Re=this.faces[Pe].distanceToPoint(L.point))>ot&&(ot=Re,$e=this.faces[Pe]);$e!==null&&this.addVertexToFace(L,$e)}return this},reindexFaces:function(){for(var L=[],N=0;N<this.faces.length;N++){var X=this.faces[N];X.mark===0&&L.push(X)}return this.faces=L,this},nextVertexToAdd:function(){if(this.assigned.isEmpty()===!1){var L,N=0,X=this.assigned.first().face,Q=X.outside;do{var oe=X.distanceToPoint(Q.point);oe>N&&(N=oe,L=Q),Q=Q.next}while(Q!==null&&Q.face===X);return L}},computeHorizon:function(L,N,X,Q){var oe;this.deleteFaceVertices(X),X.mark=1,oe=N===null?N=X.getEdge(0):N.next;do{var me=oe.twin,Te=me.face;Te.mark===0&&(Te.distanceToPoint(L)>this.tolerance?this.computeHorizon(L,me,Te,Q):Q.push(oe)),oe=oe.next}while(oe!==N);return this},addAdjoiningFace:function(L,N){var X=Me.create(L,N.tail(),N.head());return this.faces.push(X),X.getEdge(-1).setTwin(N.twin),X.getEdge(0)},addNewFaces:function(L,N){this.newFaces=[];for(var X=null,Q=null,oe=0;oe<N.length;oe++){var me=N[oe],Te=this.addAdjoiningFace(L,me);X===null?X=Te:Te.next.setTwin(Q),this.newFaces.push(Te.face),Q=Te}return X.next.setTwin(Q),this},addVertexToHull:function(L){var N=[];return this.unassigned.clear(),this.removeVertexFromFace(L,L.face),this.computeHorizon(L.point,null,L.face,N),this.addNewFaces(L,N),this.resolveUnassignedPoints(this.newFaces),this},cleanup:function(){return this.assigned.clear(),this.unassigned.clear(),this.newFaces=[],this},compute:function(){var L;for(this.computeInitialHull();(L=this.nextVertexToAdd())!==void 0;)this.addVertexToHull(L);return this.reindexFaces(),this.cleanup(),this}}),Object.assign(Me,{create:function(L,N,X){var Q=new Me,oe=new T(L,Q),me=new T(N,Q),Te=new T(X,Q);return oe.next=Te.prev=me,me.next=oe.prev=Te,Te.next=me.prev=oe,Q.edge=oe,Q.compute()}}),Object.assign(Me.prototype,{getEdge:function(L){for(var N=this.edge;L>0;)N=N.next,L--;for(;L<0;)N=N.prev,L++;return N},compute:function(){Y===void 0&&(Y=new f.Triangle);var L=this.edge.tail(),N=this.edge.head(),X=this.edge.next.head();return Y.set(L.point,N.point,X.point),Y.getNormal(this.normal),Y.getMidpoint(this.midpoint),this.area=Y.getArea(),this.constant=this.normal.dot(this.midpoint),this},distanceToPoint:function(L){return this.normal.dot(L)-this.constant}}),Object.assign(T.prototype,{head:function(){return this.vertex},tail:function(){return this.prev?this.prev.vertex:null},length:function(){var L=this.head(),N=this.tail();return N!==null?N.point.distanceTo(L.point):-1},lengthSquared:function(){var L=this.head(),N=this.tail();return N!==null?N.point.distanceToSquared(L.point):-1},setTwin:function(L){return this.twin=L,L.twin=this,this}}),Object.assign(J.prototype,{first:function(){return this.head},last:function(){return this.tail},clear:function(){return this.head=this.tail=null,this},insertBefore:function(L,N){return N.prev=L.prev,N.next=L,N.prev===null?this.head=N:N.prev.next=N,L.prev=N,this},insertAfter:function(L,N){return N.prev=L,N.next=L.next,N.next===null?this.tail=N:N.next.prev=N,L.next=N,this},append:function(L){return this.head===null?this.head=L:this.tail.next=L,L.prev=this.tail,L.next=null,this.tail=L,this},appendChain:function(L){for(this.head===null?this.head=L:this.tail.next=L,L.prev=this.tail;L.next!==null;)L=L.next;return this.tail=L,this},remove:function(L){return L.prev===null?this.head=L.next:L.prev.next=L.next,L.next===null?this.tail=L.prev:L.next.prev=L.prev,this},removeSubList:function(L,N){return L.prev===null?this.head=N.next:L.prev.next=N.next,N.next===null?this.tail=L.prev:N.next.prev=L.prev,this},isEmpty:function(){return this.head===null}}),Se}(),P=function(E){f.Geometry.call(this),this.fromBufferGeometry(new I(E)),this.mergeVertices()};P.prototype=Object.create(f.Geometry.prototype),P.prototype.constructor=P;var I=function(E){f.BufferGeometry.call(this);var U=[],G=[];A===void 0&&console.error("THREE.ConvexBufferGeometry: ConvexBufferGeometry relies on ConvexHull");for(var Y=new A().setFromPoints(E).faces,we=0;we<Y.length;we++){var Se=Y[we],Me=Se.edge;do{var T=Me.head().point;U.push(T.x,T.y,T.z),G.push(Se.normal.x,Se.normal.y,Se.normal.z),Me=Me.next}while(Me!==Se.edge)}this.setAttribute("position",new f.Float32BufferAttribute(U,3)),this.setAttribute("normal",new f.Float32BufferAttribute(G,3))};I.prototype=Object.create(f.BufferGeometry.prototype),I.prototype.constructor=I},function(rt,h,l){l.r(h),l.d(h,"XRControllerModelFactory",function(){return T});var f=l(0),A=l(3);const P={Handedness:Object.freeze({NONE:"none",LEFT:"left",RIGHT:"right"}),ComponentState:Object.freeze({DEFAULT:"default",TOUCHED:"touched",PRESSED:"pressed"}),ComponentProperty:Object.freeze({BUTTON:"button",X_AXIS:"xAxis",Y_AXIS:"yAxis",STATE:"state"}),ComponentType:Object.freeze({TRIGGER:"trigger",SQUEEZE:"squeeze",TOUCHPAD:"touchpad",THUMBSTICK:"thumbstick",BUTTON:"button"}),ButtonTouchThreshold:.05,AxisTouchThreshold:.1,VisualResponseProperty:Object.freeze({TRANSFORM:"transform",VISIBILITY:"visibility"})};async function I(Z){const J=await fetch(Z);if(J.ok)return J.json();throw new Error(J.statusText)}async function E(Z,J,L=null,N=!0){if(!Z)throw new Error("No xrInputSource supplied");if(!J)throw new Error("No basePath supplied");const X=await async function(Te){if(!Te)throw new Error("No basePath supplied");return await I(Te+"/profilesList.json")}(J);let Q;if(Z.profiles.some(Te=>{const Pe=X[Te];return Pe&&(Q={profileId:Te,profilePath:`${J}/${Pe.path}`,deprecated:!!Pe.deprecated}),!!Q}),!Q){if(!L)throw new Error("No matching profile name found");const Te=X[L];if(!Te)throw new Error(`No matching profile name found and default profile "${L}" missing.`);Q={profileId:L,profilePath:`${J}/${Te.path}`,deprecated:!!Te.deprecated}}const oe=await I(Q.profilePath);let me;if(N){let Te;if(Te=Z.handedness==="any"?oe.layouts[Object.keys(oe.layouts)[0]]:oe.layouts[Z.handedness],!Te)throw new Error(`No matching handedness, ${Z.handedness}, in profile ${Q.profileId}`);Te.assetPath&&(me=Q.profilePath.replace("profile.json",Te.assetPath))}return{profile:oe,assetPath:me}}const U={xAxis:0,yAxis:0,button:0,state:P.ComponentState.DEFAULT};class G{constructor(Z){this.componentProperty=Z.componentProperty,this.states=Z.states,this.valueNodeName=Z.valueNodeName,this.valueNodeProperty=Z.valueNodeProperty,this.valueNodeProperty===P.VisualResponseProperty.TRANSFORM&&(this.minNodeName=Z.minNodeName,this.maxNodeName=Z.maxNodeName),this.value=0,this.updateFromComponent(U)}updateFromComponent({xAxis:Z,yAxis:J,button:L,state:N}){const{normalizedXAxis:X,normalizedYAxis:Q}=function(oe=0,me=0){let Te=oe,Pe=me;if(Math.sqrt(oe*oe+me*me)>1){const Re=Math.atan2(me,oe);Te=Math.cos(Re),Pe=Math.sin(Re)}return{normalizedXAxis:.5*Te+.5,normalizedYAxis:.5*Pe+.5}}(Z,J);switch(this.componentProperty){case P.ComponentProperty.X_AXIS:this.value=this.states.includes(N)?X:.5;break;case P.ComponentProperty.Y_AXIS:this.value=this.states.includes(N)?Q:.5;break;case P.ComponentProperty.BUTTON:this.value=this.states.includes(N)?L:0;break;case P.ComponentProperty.STATE:this.valueNodeProperty===P.VisualResponseProperty.VISIBILITY?this.value=this.states.includes(N):this.value=this.states.includes(N)?1:0;break;default:throw new Error("Unexpected visualResponse componentProperty "+this.componentProperty)}}}class Y{constructor(Z,J){if(!(Z&&J&&J.visualResponses&&J.gamepadIndices&&Object.keys(J.gamepadIndices).length!==0))throw new Error("Invalid arguments supplied");this.id=Z,this.type=J.type,this.rootNodeName=J.rootNodeName,this.touchPointNodeName=J.touchPointNodeName,this.visualResponses={},Object.keys(J.visualResponses).forEach(L=>{const N=new G(J.visualResponses[L]);this.visualResponses[L]=N}),this.gamepadIndices=Object.assign({},J.gamepadIndices),this.values={state:P.ComponentState.DEFAULT,button:this.gamepadIndices.button!==void 0?0:void 0,xAxis:this.gamepadIndices.xAxis!==void 0?0:void 0,yAxis:this.gamepadIndices.yAxis!==void 0?0:void 0}}get data(){return{id:this.id,...this.values}}updateFromGamepad(Z){if(this.values.state=P.ComponentState.DEFAULT,this.gamepadIndices.button!==void 0&&Z.buttons.length>this.gamepadIndices.button){const J=Z.buttons[this.gamepadIndices.button];this.values.button=J.value,this.values.button=this.values.button<0?0:this.values.button,this.values.button=this.values.button>1?1:this.values.button,J.pressed||this.values.button===1?this.values.state=P.ComponentState.PRESSED:(J.touched||this.values.button>P.ButtonTouchThreshold)&&(this.values.state=P.ComponentState.TOUCHED)}this.gamepadIndices.xAxis!==void 0&&Z.axes.length>this.gamepadIndices.xAxis&&(this.values.xAxis=Z.axes[this.gamepadIndices.xAxis],this.values.xAxis=this.values.xAxis<-1?-1:this.values.xAxis,this.values.xAxis=this.values.xAxis>1?1:this.values.xAxis,this.values.state===P.ComponentState.DEFAULT&&Math.abs(this.values.xAxis)>P.AxisTouchThreshold&&(this.values.state=P.ComponentState.TOUCHED)),this.gamepadIndices.yAxis!==void 0&&Z.axes.length>this.gamepadIndices.yAxis&&(this.values.yAxis=Z.axes[this.gamepadIndices.yAxis],this.values.yAxis=this.values.yAxis<-1?-1:this.values.yAxis,this.values.yAxis=this.values.yAxis>1?1:this.values.yAxis,this.values.state===P.ComponentState.DEFAULT&&Math.abs(this.values.yAxis)>P.AxisTouchThreshold&&(this.values.state=P.ComponentState.TOUCHED)),Object.values(this.visualResponses).forEach(J=>{J.updateFromComponent(this.values)})}}class we{constructor(Z,J,L){if(!Z)throw new Error("No xrInputSource supplied");if(!J)throw new Error("No profile supplied");this.xrInputSource=Z,this.assetUrl=L,this.id=J.profileId,this.layoutDescription=J.layouts[Z.handedness],this.components={},Object.keys(this.layoutDescription.components).forEach(N=>{const X=this.layoutDescription.components[N];this.components[N]=new Y(N,X)}),this.updateFromGamepad()}get gripSpace(){return this.xrInputSource.gripSpace}get targetRaySpace(){return this.xrInputSource.targetRaySpace}get data(){const Z=[];return Object.values(this.components).forEach(J=>{Z.push(J.data)}),Z}updateFromGamepad(){Object.values(this.components).forEach(Z=>{Z.updateFromGamepad(this.xrInputSource.gamepad)})}}function Se(){f.Object3D.call(this),this.motionController=null,this.envMap=null}function Me(Z,J){!function(L,N){Object.values(L.components).forEach(X=>{const{type:Q,touchPointNodeName:oe,visualResponses:me}=X;if(Q===P.ComponentType.TOUCHPAD)if(X.touchPointNode=N.getObjectByName(oe),X.touchPointNode){const Te=new f.SphereBufferGeometry(.001),Pe=new f.MeshBasicMaterial({color:255}),Re=new f.Mesh(Te,Pe);X.touchPointNode.add(Re)}else console.warn(`Could not find touch dot, ${X.touchPointNodeName}, in touchpad component ${X.id}`);Object.values(me).forEach(Te=>{const{valueNodeName:Pe,minNodeName:Re,maxNodeName:Ee,valueNodeProperty:Ye}=Te;if(Ye===P.VisualResponseProperty.TRANSFORM){if(Te.minNode=N.getObjectByName(Re),Te.maxNode=N.getObjectByName(Ee),!Te.minNode)return void console.warn(`Could not find ${Re} in the model`);if(!Te.maxNode)return void console.warn(`Could not find ${Ee} in the model`)}Te.valueNode=N.getObjectByName(Pe),Te.valueNode||console.warn(`Could not find ${Pe} in the model`)})})}(Z.motionController,J),Z.envMap&&J.traverse(L=>{L.isMesh&&(L.material.envMap=Z.envMap,L.material.needsUpdate=!0)}),Z.add(J)}Se.prototype=Object.assign(Object.create(f.Object3D.prototype),{constructor:Se,setEnvironmentMap:function(Z){return this.envMap==Z||(this.envMap=Z,this.traverse(J=>{J.isMesh&&(J.material.envMap=this.envMap,J.material.needsUpdate=!0)})),this},updateMatrixWorld:function(Z){f.Object3D.prototype.updateMatrixWorld.call(this,Z),this.motionController&&(this.motionController.updateFromGamepad(),Object.values(this.motionController.components).forEach(J=>{Object.values(J.visualResponses).forEach(L=>{const{valueNode:N,minNode:X,maxNode:Q,value:oe,valueNodeProperty:me}=L;N&&(me===P.VisualResponseProperty.VISIBILITY?N.visible=oe:me===P.VisualResponseProperty.TRANSFORM&&(f.Quaternion.slerp(X.quaternion,Q.quaternion,N.quaternion,oe),N.position.lerpVectors(X.position,Q.position,oe)))})}))}});var T=function(){function Z(J=null){this.gltfLoader=J,this.path="https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles",this._assetCache={},this.gltfLoader||(this.gltfLoader=new A.GLTFLoader)}return Z.prototype={constructor:Z,createControllerModel:function(J){const L=new Se;let N=null;return J.addEventListener("connected",X=>{const Q=X.data;Q.targetRayMode==="tracked-pointer"&&Q.gamepad&&E(Q,this.path,"generic-trigger").then(({profile:oe,assetPath:me})=>{L.motionController=new we(Q,oe,me);const Te=this._assetCache[L.motionController.assetUrl];if(Te)N=Te.scene.clone(),Me(L,N);else{if(!this.gltfLoader)throw new Error("GLTFLoader not set.");this.gltfLoader.setPath(""),this.gltfLoader.load(L.motionController.assetUrl,Pe=>{this._assetCache[L.motionController.assetUrl]=Pe,N=Pe.scene.clone(),Me(L,N)},null,()=>{throw new Error(`Asset ${L.motionController.assetUrl} missing or malformed.`)})}}).catch(oe=>{console.warn(oe)})}),J.addEventListener("disconnected",()=>{L.motionController=null,L.remove(N),N=null}),L}},Z}()},function(rt,h,l){l.r(h),l.d(h,"AnimationAction",function(){return f});class f{constructor(A,P,I=null,E=P.blendMode){this._mixer=A,this._clip=P,this._localRoot=I,this.blendMode=E;const U=P.tracks,G=U.length,Y=new Array(G),we={endingStart:2400,endingEnd:2400};for(let Se=0;Se!==G;++Se){const Me=U[Se].createInterpolant(null);Y[Se]=Me,Me.settings=we}this._interpolantSettings=we,this._interpolants=Y,this._propertyBindings=new Array(G),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=2201,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&this.timeScale!==0&&this._startTime===null&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(A){return this._startTime=A,this}setLoop(A,P){return this.loop=A,this.repetitions=P,this}setEffectiveWeight(A){return this.weight=A,this._effectiveWeight=this.enabled?A:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(A){return this._scheduleFading(A,0,1)}fadeOut(A){return this._scheduleFading(A,1,0)}crossFadeFrom(A,P,I){if(A.fadeOut(P),this.fadeIn(P),I){const E=this._clip.duration,U=A._clip.duration,G=U/E,Y=E/U;A.warp(1,G,P),this.warp(Y,1,P)}return this}crossFadeTo(A,P,I){return A.crossFadeFrom(this,P,I)}stopFading(){const A=this._weightInterpolant;return A!==null&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(A)),this}setEffectiveTimeScale(A){return this.timeScale=A,this._effectiveTimeScale=this.paused?0:A,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(A){return this.timeScale=this._clip.duration/A,this.stopWarping()}syncWith(A){return this.time=A.time,this.timeScale=A.timeScale,this.stopWarping()}halt(A){return this.warp(this._effectiveTimeScale,0,A)}warp(A,P,I){const E=this._mixer,U=E.time,G=this.timeScale;let Y=this._timeScaleInterpolant;Y===null&&(Y=E._lendControlInterpolant(),this._timeScaleInterpolant=Y);const we=Y.parameterPositions,Se=Y.sampleValues;return we[0]=U,we[1]=U+I,Se[0]=A/G,Se[1]=P/G,this}stopWarping(){const A=this._timeScaleInterpolant;return A!==null&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(A)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(A,P,I,E){if(!this.enabled)return void this._updateWeight(A);const U=this._startTime;if(U!==null){const we=(A-U)*I;if(we<0||I===0)return;this._startTime=null,P=I*we}P*=this._updateTimeScale(A);const G=this._updateTime(P),Y=this._updateWeight(A);if(Y>0){const we=this._interpolants,Se=this._propertyBindings;switch(this.blendMode){case 2501:for(let Me=0,T=we.length;Me!==T;++Me)we[Me].evaluate(G),Se[Me].accumulateAdditive(Y);break;case 2500:default:for(let Me=0,T=we.length;Me!==T;++Me)we[Me].evaluate(G),Se[Me].accumulate(E,Y)}}}_updateWeight(A){let P=0;if(this.enabled){P=this.weight;const I=this._weightInterpolant;if(I!==null){const E=I.evaluate(A)[0];P*=E,A>I.parameterPositions[1]&&(this.stopFading(),E===0&&(this.enabled=!1))}}return this._effectiveWeight=P,P}_updateTimeScale(A){let P=0;if(!this.paused){P=this.timeScale;const I=this._timeScaleInterpolant;I!==null&&(P*=I.evaluate(A)[0],A>I.parameterPositions[1]&&(this.stopWarping(),P===0?this.paused=!0:this.timeScale=P))}return this._effectiveTimeScale=P,P}_updateTime(A){const P=this._clip.duration,I=this.loop;let E=this.time+A,U=this._loopCount;const G=I===2202;if(A===0)return U===-1?E:G&&(1&U)==1?P-E:E;if(I===2200){U===-1&&(this._loopCount=0,this._setEndings(!0,!0,!1));e:{if(E>=P)E=P;else{if(!(E<0)){this.time=E;break e}E=0}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=E,this._mixer.dispatchEvent({type:"finished",action:this,direction:A<0?-1:1})}}else{if(U===-1&&(A>=0?(U=0,this._setEndings(!0,this.repetitions===0,G)):this._setEndings(this.repetitions===0,!0,G)),E>=P||E<0){const Y=Math.floor(E/P);E-=P*Y,U+=Math.abs(Y);const we=this.repetitions-U;if(we<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,E=A>0?P:0,this.time=E,this._mixer.dispatchEvent({type:"finished",action:this,direction:A>0?1:-1});else{if(we===1){const Se=A<0;this._setEndings(Se,!Se,G)}else this._setEndings(!1,!1,G);this._loopCount=U,this.time=E,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:Y})}}else this.time=E;if(G&&(1&U)==1)return P-E}return E}_setEndings(A,P,I){const E=this._interpolantSettings;I?(E.endingStart=2401,E.endingEnd=2401):(E.endingStart=A?this.zeroSlopeAtStart?2401:2400:2402,E.endingEnd=P?this.zeroSlopeAtEnd?2401:2400:2402)}_scheduleFading(A,P,I){const E=this._mixer,U=E.time;let G=this._weightInterpolant;G===null&&(G=E._lendControlInterpolant(),this._weightInterpolant=G);const Y=G.parameterPositions,we=G.sampleValues;return Y[0]=U,we[0]=P,Y[1]=U+A,we[1]=I,this}}},function(rt,h,l){l.r(h),l.d(h,"GlitchPass",function(){return I});var f=l(0),A=l(1),P={uniforms:{tDiffuse:{value:null},tDisp:{value:null},byp:{value:0},amount:{value:.08},angle:{value:.02},seed:{value:.02},seed_x:{value:.02},seed_y:{value:.02},distortion_x:{value:.5},distortion_y:{value:.6},col_s:{value:.05}},vertexShader:["varying vec2 vUv;","void main() {","	vUv = uv;","	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join(`
`),fragmentShader:["uniform int byp;","uniform sampler2D tDiffuse;","uniform sampler2D tDisp;","uniform float amount;","uniform float angle;","uniform float seed;","uniform float seed_x;","uniform float seed_y;","uniform float distortion_x;","uniform float distortion_y;","uniform float col_s;","varying vec2 vUv;","float rand(vec2 co){","	return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);","}","void main() {","	if(byp<1) {","		vec2 p = vUv;","		float xs = floor(gl_FragCoord.x / 0.5);","		float ys = floor(gl_FragCoord.y / 0.5);","		vec4 normal = texture2D (tDisp, p*seed*seed);","		if(p.y<distortion_x+col_s && p.y>distortion_x-col_s*seed) {","			if(seed_x>0.){","				p.y = 1. - (p.y + distortion_y);","			}","			else {","				p.y = distortion_y;","			}","		}","		if(p.x<distortion_y+col_s && p.x>distortion_y-col_s*seed) {","			if(seed_y>0.){","				p.x=distortion_x;","			}","			else {","				p.x = 1. - (p.x + distortion_x);","			}","		}","		p.x+=normal.x*seed_x*(seed/5.);","		p.y+=normal.y*seed_y*(seed/5.);","		vec2 offset = amount * vec2( cos(angle), sin(angle));","		vec4 cr = texture2D(tDiffuse, p + offset);","		vec4 cga = texture2D(tDiffuse, p);","		vec4 cb = texture2D(tDiffuse, p - offset);","		gl_FragColor = vec4(cr.r, cga.g, cb.b, cga.a);","		vec4 snow = 200.*amount*vec4(rand(vec2(xs * seed,ys * seed*50.))*0.2);","		gl_FragColor = gl_FragColor+ snow;","	}","	else {","		gl_FragColor=texture2D (tDiffuse, vUv);","	}","}"].join(`
`)},I=function(E){A.a.call(this),P===void 0&&console.error("GlitchPass relies on DigitalGlitch");var U=P;this.uniforms=f.UniformsUtils.clone(U.uniforms),E==null&&(E=64),this.uniforms.tDisp.value=this.generateHeightmap(E),this.material=new f.ShaderMaterial({uniforms:this.uniforms,vertexShader:U.vertexShader,fragmentShader:U.fragmentShader}),this.fsQuad=new A.a.FullScreenQuad(this.material),this.goWild=!1,this.curF=0,this.generateTrigger()};I.prototype=Object.assign(Object.create(A.a.prototype),{constructor:I,render:function(E,U,G){this.uniforms.tDiffuse.value=G.texture,this.uniforms.seed.value=Math.random(),this.uniforms.byp.value=0,this.curF%this.randX==0||this.goWild==1?(this.uniforms.amount.value=Math.random()/30,this.uniforms.angle.value=f.MathUtils.randFloat(-Math.PI,Math.PI),this.uniforms.seed_x.value=f.MathUtils.randFloat(-1,1),this.uniforms.seed_y.value=f.MathUtils.randFloat(-1,1),this.uniforms.distortion_x.value=f.MathUtils.randFloat(0,1),this.uniforms.distortion_y.value=f.MathUtils.randFloat(0,1),this.curF=0,this.generateTrigger()):this.curF%this.randX<this.randX/5?(this.uniforms.amount.value=Math.random()/90,this.uniforms.angle.value=f.MathUtils.randFloat(-Math.PI,Math.PI),this.uniforms.distortion_x.value=f.MathUtils.randFloat(0,1),this.uniforms.distortion_y.value=f.MathUtils.randFloat(0,1),this.uniforms.seed_x.value=f.MathUtils.randFloat(-.3,.3),this.uniforms.seed_y.value=f.MathUtils.randFloat(-.3,.3)):this.goWild==0&&(this.uniforms.byp.value=1),this.curF++,this.renderToScreen?(E.setRenderTarget(null),this.fsQuad.render(E)):(E.setRenderTarget(U),this.clear&&E.clear(),this.fsQuad.render(E))},generateTrigger:function(){this.randX=f.MathUtils.randInt(120,240)},generateHeightmap:function(E){for(var U=new Float32Array(E*E*3),G=E*E,Y=0;Y<G;Y++){var we=f.MathUtils.randFloat(0,1);U[3*Y+0]=we,U[3*Y+1]=we,U[3*Y+2]=we}return new f.DataTexture(U,E,E,f.RGBFormat,f.FloatType)}})}]))}),zg=dn(function(an,fe){/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|GNU GPLv3}
 */Object.defineProperty(fe,"__esModule",{value:!0});class rt{constructor(h,l){this.physics=h,this.ammo=l,this.ignoreScale=!1,this.isSoftBody=!1,this.offset={x:0,y:0,z:0},this.errors=[],this.checkCollisions=!1,this.breakable=!1,this.didUpdate=!1,this.skipUpdate=!1,this._emitUpdateEvents=!1,this._needUpdate=!1,this.tmpEuler=new We.Euler,this.tmpQuaternion=new We.Quaternion,this.tmpBtVector3=new Ammo.btVector3,this.tmpBtVector3_1=new Ammo.btVector3,this.tmpBtQuaternion=new Ammo.btQuaternion(0,0,0,1),this.eventEmitter=new Aa.EventEmitter,this.name=l.name}destructor(){this.eventEmitter&&this.eventEmitter.removeAllListeners(),Ammo.destroy(this.tmpBtVector3),Ammo.destroy(this.tmpBtVector3_1),Ammo.destroy(this.tmpBtQuaternion),Ammo.destroy(this.ammo.getCollisionShape()),Ammo.destroy(this.ammo)}setupEventEmitter(){typeof this.eventEmitter=="undefined"&&(this.eventEmitter=new Aa.EventEmitter)}get needUpdate(){return this._needUpdate}set needUpdate(h){!h&&this._needUpdate&&(this.didUpdate=!0),this._needUpdate=h}onUpdateEvent(h,l=!1){this.setupEventEmitter(),this._emitUpdateEvents=!0,l?this.eventEmitter.once("update",()=>{h()}):this.eventEmitter.on("update",()=>{h()})}get on(){return{update:h=>this.onUpdateEvent(h),collision:h=>this.onCollision(h)}}get once(){return{update:h=>this.onUpdateEvent(h,!0)}}onCollision(h){this.checkCollisions=!0,this.physics.collisionEvents.on("collision",l=>{const{bodies:f,event:A}=l;f[0].name===this.name?h(f[1],A):f[1].name===this.name&&h(f[0],A)})}transform(){const h=this.physics.worldTransform;this.ammo.getMotionState().getWorldTransform(h)}refresh(){const h=this.physics.worldTransform;this.ammo.getMotionState().setWorldTransform(h)}setRotation(h,l,f){const A=this.tmpEuler.set(h,l,f),P=this.tmpQuaternion.set(0,0,0,1);P.setFromEuler(A),this.tmpBtQuaternion.setValue(0,0,0,1);const I=this.tmpBtQuaternion;I.setValue(P.x,P.y,P.z,P.w);const E=this.physics.worldTransform;E.setRotation(I)}get rotation(){let h,l,f;const A=this.physics.worldTransform,P=A.getRotation();let I=this.tmpQuaternion.set(P.x(),P.y(),P.z(),P.w());I.w>1&&(I=I.normalize());const E=2*Math.acos(I.w),U=Math.sqrt(1-I.w*I.w);return U<.001?(h=I.x,l=I.y,f=I.z):(h=I.x/U,l=I.y/U,f=I.z/U),{x:h*E,y:l*E,z:f*E}}setPosition(h,l,f){const A=this.physics.worldTransform;A.getOrigin().setValue(h,l,f)}get position(){const h=this.physics.worldTransform;return{x:h.getOrigin().x(),y:h.getOrigin().y(),z:h.getOrigin().z()}}get velocity(){return{x:this.ammo.getLinearVelocity().x(),y:this.ammo.getLinearVelocity().y(),z:this.ammo.getLinearVelocity().z()}}get angularVelocity(){return{x:this.ammo.getAngularVelocity().x(),y:this.ammo.getAngularVelocity().y(),z:this.ammo.getAngularVelocity().z()}}setVelocity(h,l,f){this.tmpBtVector3.setValue(h,l,f),this.ammo.setLinearVelocity(this.tmpBtVector3)}setVelocityX(h){this.tmpBtVector3.setValue(h,this.velocity.y,this.velocity.z),this.ammo.setLinearVelocity(this.tmpBtVector3)}setVelocityY(h){this.tmpBtVector3.setValue(this.velocity.x,h,this.velocity.z),this.ammo.setLinearVelocity(this.tmpBtVector3)}setVelocityZ(h){this.tmpBtVector3.setValue(this.velocity.x,this.velocity.y,h),this.ammo.setLinearVelocity(this.tmpBtVector3)}setAngularVelocity(h,l,f){this.tmpBtVector3.setValue(h,l,f),this.ammo.setAngularVelocity(this.tmpBtVector3)}setAngularVelocityX(h){this.tmpBtVector3.setValue(h,this.angularVelocity.y,this.angularVelocity.z),this.ammo.setAngularVelocity(this.tmpBtVector3)}setAngularVelocityY(h){this.tmpBtVector3.setValue(this.angularVelocity.x,h,this.angularVelocity.z),this.ammo.setAngularVelocity(this.tmpBtVector3)}setAngularVelocityZ(h){this.tmpBtVector3.setValue(this.angularVelocity.x,this.angularVelocity.y,h),this.ammo.setAngularVelocity(this.tmpBtVector3)}applyForce(h,l,f){this.tmpBtVector3.setValue(h,l,f),this.ammo.applyCentralImpulse(this.tmpBtVector3)}applyForceX(h){this.tmpBtVector3.setValue(h,0,0),this.ammo.applyCentralImpulse(this.tmpBtVector3)}applyForceY(h){this.tmpBtVector3.setValue(0,h,0),this.ammo.applyCentralImpulse(this.tmpBtVector3)}applyForceZ(h){this.tmpBtVector3.setValue(0,0,h),this.ammo.applyCentralImpulse(this.tmpBtVector3)}applyCentralForce(h,l,f){this.tmpBtVector3.setValue(h,l,f),this.ammo.applyCentralForce(this.tmpBtVector3)}applyCentralImpulse(h,l,f){this.tmpBtVector3.setValue(h,l,f),this.ammo.applyCentralImpulse(this.tmpBtVector3)}applyCentralLocalForce(h,l,f){this.tmpBtVector3.setValue(h,l,f),this.ammo.applyCentralLocalForce(this.tmpBtVector3)}applyImpulse(h,l){this.tmpBtVector3.setValue(h.x||0,h.y||0,h.z||0),this.tmpBtVector3_1.setValue(l.x||0,l.y||0,l.z||0),this.ammo.applyImpulse(this.tmpBtVector3,this.tmpBtVector3_1)}applyLocalTorque(h,l,f){this.tmpBtVector3.setValue(h,l,f),this.ammo.applyLocalTorque(this.tmpBtVector3)}applyTorque(h,l,f){this.tmpBtVector3.setValue(h,l,f),this.ammo.applyTorque(this.tmpBtVector3)}applyTorqueImpulse(h,l,f){this.tmpBtVector3.setValue(h,l,f),this.ammo.applyTorqueImpulse(this.tmpBtVector3)}setCollisionFlags(h){this.ammo.setCollisionFlags(h)}getCollisionFlags(){return this.ammo.getCollisionFlags()}setRestitution(h){this.ammo.setRestitution(h)}setBounciness(h){this.setRestitution(h)}setFriction(h){this.ammo.setFriction(h)}setGravity(h,l,f){this.tmpBtVector3.setValue(h,l,f),this.ammo.setGravity(this.tmpBtVector3)}setLinearFactor(h,l,f){this.tmpBtVector3.setValue(h,l,f),this.ammo.setLinearFactor(this.tmpBtVector3)}setAngularFactor(h,l,f){this.tmpBtVector3.setValue(h,l,f),this.ammo.setAngularFactor(this.tmpBtVector3)}setCcdMotionThreshold(h){this.ammo.setCcdMotionThreshold(h)}setCcdSweptSphereRadius(h){this.ammo.setCcdSweptSphereRadius(h)}}fe.default=rt}),ql=dn(function(an,fe){/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|GNU GPLv3}
 */Object.defineProperty(fe,"__esModule",{value:!0}),fe.ExtendedObject3D=void 0;class rt extends We.Object3D{constructor(){super();this.vector3=new We.Vector3,this.isGroup=!1,this.hasBody=!1,this.anims={},this._currentAnimation="",this._animationActions=new Map,this.name=`object-${this.id}`}setAction(h){console.warn("[enable3d] setAction(name) is deprecated. Use animation.play(name) instead!"),this.animationPlay(h)}get world(){return{theta:this.worldTheta,phi:this.worldPhi}}get worldTheta(){return this.getWorldDirection(this.vector3),Math.atan2(this.vector3.x,this.vector3.z)}get worldPhi(){return this.getWorldDirection(this.vector3),Math.acos(this.vector3.y)}get animation(){return{current:this._currentAnimation,add:(h,l)=>this.animationAdd(h,l),play:(h,l=500,f=!0)=>this.animationPlay(h,l,f),mixer:this.animationMixer}}set animationMixer(h){this._animationMixer=h}get animationMixer(){return this._animationMixer||(this._animationMixer=new We.AnimationMixer(this)),this._animationMixer}animationAdd(h,l){this._animationActions.set(h,this.animationMixer.clipAction(l))}animationPlay(h,l=500,f=!0){const A=this._animationActions.get(h),P=this._animationActions.get(this._currentAnimation);A&&(A.reset(),P&&(A.crossFadeFrom(P,l/1e3,!0),A.clampWhenFinished=!0),f||A.setLoop(We.LoopOnce,0),A.play()),this._currentAnimation=h}}fe.ExtendedObject3D=rt,fe.default=rt}),Zs=dn(function(an,fe){/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|GNU GPLv3}
 */Object.defineProperty(fe,"__esModule",{value:!0}),fe.ExtendedMesh=void 0;class rt extends We.Mesh{constructor(h,l){super(h,l);this.vector3=new We.Vector3,this.isGroup=!1,this.hasBody=!1,this.name=`object-${this.id}`}get world(){return{theta:this.worldTheta,phi:this.worldPhi}}get worldTheta(){return this.getWorldDirection(this.vector3),Math.atan2(this.vector3.x,this.vector3.z)}get worldPhi(){return this.getWorldDirection(this.vector3),Math.acos(this.vector3.y)}}fe.ExtendedMesh=rt}),ep=dn(function(an,fe){/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|GNU GPLv3}
 */Object.defineProperty(fe,"__esModule",{value:!0}),fe.ExtendedGroup=void 0;class rt extends We.Group{constructor(){super();this.isMesh=!1,this.hasBody=!1,this.name=`object-${this.id}`}}fe.ExtendedGroup=rt}),kg=dn(function(an,fe){/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|GNU GPLv3}
 */Object.defineProperty(fe,"__esModule",{value:!0});class rt{constructor(h,l){this.factory=h,this.addExisting=l}addPlane(h={},l={}){const f=this.factory.add.plane(h,l);return this.addExisting(f,h),f}addSphere(h={},l={}){const f=this.factory.add.sphere(h,l);return this.addExisting(f,h),f}addBox(h={},l={}){const f=this.factory.add.box(h,l);return this.addExisting(f,h),f}addGround(h,l={}){const f=this.factory.add.ground(h,l),A=Object.assign(Object.assign({},h),{mass:0,collisionFlags:1});return this.addExisting(f,A),f}addCylinder(h={},l={}){const f=this.factory.add.cylinder(h,l);return this.addExisting(f,h),f}addCone(h={},l={}){const f=this.factory.add.cone(h,l);return this.addExisting(f,h),f}addTorus(h={},l={}){const f=this.factory.add.torus(h,l);return this.addExisting(f,h),f}addExtrude(h,l={}){const f=this.factory.add.extrude(h,l);return f.translateX(1),this.addExisting(f),f}}fe.default=rt}),Hg=dn(function(an,fe){/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|GNU GPLv3}
 */Object.defineProperty(fe,"__esModule",{value:!0});class rt{constructor(h,l){this.worldTransform=h,this.physicsWorld=l,this.tmpBtVector3=new Ammo.btVector3}toAmmoV3(h,l=0){return new Ammo.btVector3(typeof(h==null?void 0:h.x)!="undefined"?h.x:l,typeof(h==null?void 0:h.y)!="undefined"?h.y:l,typeof(h==null?void 0:h.z)!="undefined"?h.z:l)}get addConstraints(){return{lock:(h,l,f)=>this.lock(h,l,f),fixed:(h,l,f)=>this.fixed(h,l,f),pointToPoint:(h,l,f,A)=>this.pointToPoint(h,l,f,A),hinge:(h,l,f,A)=>this.hinge(h,l,f,A),slider:(h,l,f={},A)=>this.slider(h,l,f,A),spring:(h,l,f={},A)=>this.spring(h,l,f,A),coneTwist:(h,l,f={frameA:{},frameB:{}},A)=>this.coneTwist(h,l,f,A),dof:(h,l,f,A)=>this.dof(h,l,f,A)}}getTransform(h,l,f={x:0,y:0,z:0},A=!1){f=Object.assign({x:0,y:0,z:0},f);const P=(E,U)=>{var G=(E.x()-U.x())/2+f.x,Y=(E.y()-U.y())/2+f.y,we=(E.z()-U.z())/2+f.z;return new Ammo.btVector3(G,Y,we)},I=new Ammo.btTransform;if(I.setIdentity(),A){const E=P(h.getWorldTransform().getOrigin(),l.getWorldTransform().getOrigin()),U=new Ammo.btTransform;U.setIdentity(),U.setOrigin(E);const G=h.getCenterOfMassTransform().inverse().op_mul(l.getWorldTransform());return G.op_mul(U),{transformA:G,transformB:U}}else{I.setOrigin(new Ammo.btVector3(f.x,f.y,f.z));const E=h.getCenterOfMassTransform().inverse().op_mul(l.getWorldTransform()).op_mul(I);return{transformA:E,transformB:I}}}lock(h,l,f=!0){const A={x:0,y:0,z:0};return this.dof(h,l,{angularLowerLimit:A,angularUpperLimit:A},f)}fixed(h,l,f=!0){const A=this.getTransform(h.ammo,l.ammo);A.transformA.setRotation(h.ammo.getWorldTransform().getRotation()),A.transformB.setRotation(l.ammo.getWorldTransform().getRotation());const P=new Ammo.btFixedConstraint(h.ammo,l.ammo,A.transformA,A.transformB);return this.physicsWorld.addConstraint(P,f),P}pointToPoint(h,l,f={},A=!0){const{pivotA:P,pivotB:I}=f,E=new Ammo.btVector3((P==null?void 0:P.x)||0,(P==null?void 0:P.y)||0,(P==null?void 0:P.z)||0),U=new Ammo.btVector3((I==null?void 0:I.x)||0,(I==null?void 0:I.y)||0,(I==null?void 0:I.z)||0),G=new Ammo.btPoint2PointConstraint(h.ammo,l.ammo,E,U);return this.physicsWorld.addConstraint(G,A),G}hinge(h,l,f={},A=!0){const{pivotA:P,pivotB:I,axisA:E,axisB:U}=f,G=new Ammo.btVector3((P==null?void 0:P.x)||0,(P==null?void 0:P.y)||0,(P==null?void 0:P.z)||0),Y=new Ammo.btVector3((I==null?void 0:I.x)||0,(I==null?void 0:I.y)||0,(I==null?void 0:I.z)||0),we=new Ammo.btVector3((E==null?void 0:E.x)||0,(E==null?void 0:E.y)||0,(E==null?void 0:E.z)||0),Se=new Ammo.btVector3((U==null?void 0:U.x)||0,(U==null?void 0:U.y)||0,(U==null?void 0:U.z)||0),Me=new Ammo.btHingeConstraint(h.ammo,l.ammo,G,Y,we,Se,!0);return this.physicsWorld.addConstraint(Me,A),Me}slider(h,l,f={},A=!0){const P=this.getTransform(h.ammo,l.ammo),{frameA:I={},frameB:E={},linearLowerLimit:U=0,linearUpperLimit:G=0,angularLowerLimit:Y=0,angularUpperLimit:we=0}=f,Se=P.transformA.getRotation();Se.setEulerZYX(I.x||0,I.y||0,I.z||0),P.transformA.setRotation(Se);const Me=P.transformB.getRotation();Me.setEulerZYX(E.x||0,E.y||0,E.z||0),P.transformB.setRotation(Me);const T=new Ammo.btSliderConstraint(h.ammo,l.ammo,P.transformA,P.transformB,!0);return T.setLowerLinLimit(U),T.setUpperLinLimit(G),T.setLowerAngLimit(Y),T.setUpperAngLimit(we),this.physicsWorld.addConstraint(T,A),T}spring(h,l,f={},A=!0){const{stiffness:P=50,damping:I=.01,angularLock:E=!1,linearLowerLimit:U={},linearUpperLimit:G={},angularLowerLimit:Y={},angularUpperLimit:we={},offset:Se={},center:Me=!1,enableSpring:T=!0}=f,Z=Object.assign({x:0,y:0,z:0},Se),J=this.getTransform(h.ammo,l.ammo,Z,Me),L=new Ammo.btGeneric6DofSpringConstraint(h.ammo,l.ammo,J.transformA,J.transformB,!0);this.tmpBtVector3.setValue(U.x||0,U.y||0,U.z||0),L.setLinearLowerLimit(this.tmpBtVector3),this.tmpBtVector3.setValue(G.x||0,G.y||0,G.z||0),L.setLinearUpperLimit(this.tmpBtVector3),E?(this.tmpBtVector3.setValue(0,0,0),L.setAngularLowerLimit(this.tmpBtVector3),L.setAngularUpperLimit(this.tmpBtVector3)):(console.log(Y,we),L.setAngularLowerLimit(this.toAmmoV3(Y,-Math.PI)),L.setAngularUpperLimit(this.toAmmoV3(we,Math.PI)));for(let N=0;N<3;N++)L.enableSpring(N,T),L.setStiffness(N,P),L.setDamping(N,I);return this.physicsWorld.addConstraint(L,A),L}coneTwist(h,l,f,A=!0){const{frameA:P,frameB:I}=f,E=new Ammo.btTransform;E.setIdentity(),E.getOrigin().setValue((P==null?void 0:P.x)||0,(P==null?void 0:P.y)||0,(P==null?void 0:P.z)||0);const U=new Ammo.btTransform;U.setIdentity(),U.getOrigin().setValue((I==null?void 0:I.x)||0,(I==null?void 0:I.y)||0,(I==null?void 0:I.z)||0);const G=this.getTransform(h.ammo,l.ammo),Y=new Ammo.btConeTwistConstraint(l.ammo,h.ammo,E,U);return Y.setAngularOnly(!0),this.physicsWorld.addConstraint(Y,A),Y}dof(h,l,f={},A=!0){const{offset:P,center:I=!1}=f,E=Object.assign({x:0,y:0,z:0},P),U=this.getTransform(h.ammo,l.ammo,E,I),G=new Ammo.btGeneric6DofConstraint(h.ammo,l.ammo,U.transformA,U.transformB,!0),{linearLowerLimit:Y,linearUpperLimit:we,angularLowerLimit:Se,angularUpperLimit:Me}=f,T=this.toAmmoV3(Y),Z=this.toAmmoV3(we),J=this.toAmmoV3(Se,-Math.PI),L=this.toAmmoV3(Me,Math.PI);return G.setLinearLowerLimit(T),G.setLinearUpperLimit(Z),G.setAngularLowerLimit(J),G.setAngularUpperLimit(L),Ammo.destroy(T),Ammo.destroy(Z),Ammo.destroy(J),Ammo.destroy(L),this.physicsWorld.addConstraint(G,A),G}}fe.default=rt}),Vi=dn(function(an,fe){Object.defineProperty(fe,"__esModule",{value:!0}),fe.iterateGeometries=fe.createHeightfieldTerrainShape=fe.createTriMeshShape=fe.createVHACDShapes=fe.createHACDShapes=fe.createHullShape=fe.createSphereShape=fe.createConeShape=fe.createCapsuleShape=fe.createCylinderShape=fe.createBoxShape=fe.createCollisionShapes=fe.HEIGHTFIELD_DATA_TYPE=fe.FIT=fe.TYPE=void 0,fe.TYPE={BOX:"box",CYLINDER:"cylinder",SPHERE:"sphere",CAPSULE:"capsule",CONE:"cone",HULL:"hull",HACD:"hacd",VHACD:"vhacd",MESH:"mesh",HEIGHTFIELD:"heightfield"},fe.FIT={ALL:"all",MANUAL:"manual"},fe.HEIGHTFIELD_DATA_TYPE={short:"short",float:"float"};const rt=function(T,Z,J,L,N={}){switch(N.type){case fe.TYPE.BOX:return[fe.createBoxShape(T,Z,L,N)];case fe.TYPE.CYLINDER:return[fe.createCylinderShape(T,Z,L,N)];case fe.TYPE.CAPSULE:return[fe.createCapsuleShape(T,Z,L,N)];case fe.TYPE.CONE:return[fe.createConeShape(T,Z,L,N)];case fe.TYPE.SPHERE:return[fe.createSphereShape(T,Z,L,N)];case fe.TYPE.HULL:return[fe.createHullShape(T,Z,L,N)];case fe.TYPE.HACD:return fe.createHACDShapes(T,Z,J,L,N);case fe.TYPE.VHACD:return fe.createVHACDShapes(T,Z,J,L,N);case fe.TYPE.MESH:return[fe.createTriMeshShape(T,Z,J,L,N)];case fe.TYPE.HEIGHTFIELD:return[fe.createHeightfieldTerrainShape(N)];default:return console.warn(N.type+" is not currently supported"),[]}};fe.createCollisionShapes=rt;const h=function(T,Z,J,L={}){L.type=fe.TYPE.BOX,E(L),L.fit===fe.FIT.ALL&&(L.halfExtents=we(Se(T,Z),L.minHalfExtent,L.maxHalfExtent));const N=new Ammo.btVector3(L.halfExtents.x,L.halfExtents.y,L.halfExtents.z),X=new Ammo.btBoxShape(N);return Ammo.destroy(N),U(X,L,G(J,L)),X};fe.createBoxShape=h;const l=function(T,Z,J,L={}){L.type=fe.TYPE.CYLINDER,E(L),L.fit===fe.FIT.ALL&&(L.halfExtents=we(Se(T,Z),L.minHalfExtent,L.maxHalfExtent));const N=new Ammo.btVector3(L.halfExtents.x,L.halfExtents.y,L.halfExtents.z),X=(()=>{switch(L.cylinderAxis){case"y":return new Ammo.btCylinderShape(N);case"x":return new Ammo.btCylinderShapeX(N);case"z":return new Ammo.btCylinderShapeZ(N)}return null})();return Ammo.destroy(N),U(X,L,G(J,L)),X};fe.createCylinderShape=l;const f=function(T,Z,J,L={}){L.type=fe.TYPE.CAPSULE,E(L),L.fit===fe.FIT.ALL&&(L.halfExtents=we(Se(T,Z),L.minHalfExtent,L.maxHalfExtent));const{x:N,y:X,z:Q}=L.halfExtents,oe=(()=>{switch(L.cylinderAxis){case"y":return new Ammo.btCapsuleShape(Math.max(N,Q),X*2);case"x":return new Ammo.btCapsuleShapeX(Math.max(X,Q),N*2);case"z":return new Ammo.btCapsuleShapeZ(Math.max(N,X),Q*2)}return null})();return U(oe,L,G(J,L)),oe};fe.createCapsuleShape=f;const A=function(T,Z,J,L={}){L.type=fe.TYPE.CONE,E(L),L.fit===fe.FIT.ALL&&(L.halfExtents=we(Se(T,Z),L.minHalfExtent,L.maxHalfExtent));const{x:N,y:X,z:Q}=L.halfExtents,oe=(()=>{switch(L.cylinderAxis){case"y":return new Ammo.btConeShape(Math.max(N,Q),X*2);case"x":return new Ammo.btConeShapeX(Math.max(X,Q),N*2);case"z":return new Ammo.btConeShapeZ(Math.max(N,X),Q*2)}return null})();return U(oe,L,G(J,L)),oe};fe.createConeShape=A;const P=function(T,Z,J,L={}){L.type=fe.TYPE.SPHERE,E(L);let N;L.fit===fe.FIT.MANUAL&&!isNaN(L.sphereRadius)?N=L.sphereRadius:N=Y(T,Z,Se(T,Z));const X=new Ammo.btSphereShape(N);return U(X,L,G(J,L)),X};fe.createSphereShape=P,fe.createHullShape=function(){const T=new We.Vector3,Z=new We.Vector3,J=new We.Matrix4;return function(L,N,X,Q={}){if(Q.type=fe.TYPE.HULL,E(Q),Q.fit===fe.FIT.MANUAL)return console.warn("cannot use fit: manual with type: hull"),null;const oe=Se(L,N),me=new Ammo.btVector3,Te=new Ammo.btConvexHullShape;Te.setMargin(Q.margin),Z.addVectors(oe.max,oe.min).multiplyScalar(.5);let Pe=0;for(let Qe=0;Qe<L.length;Qe++)Pe+=L[Qe].length/3;const Re=Q.hullMaxVertices||1e5;Pe>Re&&console.warn(`too many vertices for hull shape; sampling ~${Re} from ~${Pe} vertices`);const Ee=Math.min(1,Re/Pe);for(let Qe=0;Qe<L.length;Qe++){const lt=L[Qe];J.fromArray(N[Qe]);for(let ot=0;ot<lt.length;ot+=3){const Ne=Qe===L.length-1&&ot===lt.length-3;(Math.random()<=Ee||Ne)&&(T.set(lt[ot],lt[ot+1],lt[ot+2]).applyMatrix4(J).sub(Z),me.setValue(T.x,T.y,T.z),Te.addPoint(me,Ne))}}let Ye=Te;if(Te.getNumVertices()>=100){const Qe=new Ammo.btShapeHull(Te);Qe.buildHull(Q.margin),Ammo.destroy(Te),Ye=new Ammo.btConvexHullShape(Ammo.getPointer(Qe.getVertexPointer()),Qe.numVertices()),Ammo.destroy(Qe)}return Ammo.destroy(me),U(Ye,Q,G(X,Q)),Ye}}(),fe.createHACDShapes=function(){const T=new We.Vector3,Z=new We.Vector3,J=new We.Matrix4;return function(L,N,X,Q,oe={}){if(oe.type=fe.TYPE.HACD,E(oe),oe.fit===fe.FIT.MANUAL)return console.warn("cannot use fit: manual with type: hacd"),[];if(!Ammo.hasOwnProperty("HACD"))return console.warn("HACD unavailable in included build of Ammo.js. Visit https://github.com/mozillareality/ammo.js for the latest version."),[];const me=Se(L,N),Te=G(Q,oe);let Pe=0,Re=0;Z.addVectors(me.max,me.min).multiplyScalar(.5);for(let $e=0;$e<L.length;$e++)Pe+=L[$e].length/3,X&&X[$e]?Re+=X[$e].length/3:Re+=L[$e].length/9;const Ee=new Ammo.HACD;oe.hasOwnProperty("compacityWeight")&&Ee.SetCompacityWeight(oe.compacityWeight),oe.hasOwnProperty("volumeWeight")&&Ee.SetVolumeWeight(oe.volumeWeight),oe.hasOwnProperty("nClusters")&&Ee.SetNClusters(oe.nClusters),oe.hasOwnProperty("nVerticesPerCH")&&Ee.SetNVerticesPerCH(oe.nVerticesPerCH),oe.hasOwnProperty("concavity")&&Ee.SetConcavity(oe.concavity);const Ye=Ammo._malloc(Pe*3*8),Qe=Ammo._malloc(Re*3*4);Ee.SetPoints(Ye),Ee.SetTriangles(Qe),Ee.SetNPoints(Pe),Ee.SetNTriangles(Re);let lt=Ye/8,ot=Qe/4;for(let $e=0;$e<L.length;$e++){const ut=L[$e];J.fromArray(N[$e]);for(let pt=0;pt<ut.length;pt+=3)T.set(ut[pt+0],ut[pt+1],ut[pt+2]).applyMatrix4(J).sub(Z),Ammo.HEAPF64[lt+0]=T.x,Ammo.HEAPF64[lt+1]=T.y,Ammo.HEAPF64[lt+2]=T.z,lt+=3;if(X[$e]){const pt=X[$e];for(let Ot=0;Ot<pt.length;Ot++)Ammo.HEAP32[ot]=pt[Ot],ot++}else for(let pt=0;pt<ut.length/3;pt++)Ammo.HEAP32[ot]=pt,ot++}Ee.Compute(),Ammo._free(Ye),Ammo._free(Qe);const Ne=Ee.GetNClusters(),at=[];for(let $e=0;$e<Ne;$e++){const ut=new Ammo.btConvexHullShape;ut.setMargin(oe.margin);const pt=Ee.GetNPointsCH($e),Ot=Ee.GetNTrianglesCH($e),It=Ammo._malloc(pt*3*8),Bt=Ammo._malloc(Ot*3*4);Ee.GetCH($e,It,Bt);const Wt=It/8;for(let Tt=0;Tt<pt;Tt++){const Yt=new Ammo.btVector3,Kt=Ammo.HEAPF64[Wt+Tt*3+0],Zt=Ammo.HEAPF64[Wt+Tt*3+1],be=Ammo.HEAPF64[Wt+Tt*3+2];Yt.setValue(Kt,Zt,be),ut.addPoint(Yt,Tt===pt-1),Ammo.destroy(Yt)}at.push(ut)}return at}}(),fe.createVHACDShapes=function(){const T=new We.Vector3,Z=new We.Vector3,J=new We.Matrix4;return function(L,N,X,Q,oe={}){if(oe.type=fe.TYPE.VHACD,E(oe),oe.fit===fe.FIT.MANUAL)return console.warn("cannot use fit: manual with type: vhacd"),[];if(!Ammo.hasOwnProperty("VHACD"))return console.warn("VHACD unavailable in included build of Ammo.js. Visit https://github.com/mozillareality/ammo.js for the latest version."),[];const me=Se(L,N),Te=G(Q,oe);let Pe=0,Re=0;Z.addVectors(me.max,me.min).multiplyScalar(.5);for(let pt=0;pt<L.length;pt++)Pe+=L[pt].length/3,X&&X[pt]?Re+=X[pt].length/3:Re+=L[pt].length/9;const Ee=new Ammo.VHACD,Ye=new Ammo.Parameters;oe.hasOwnProperty("resolution")&&Ye.set_m_resolution(oe.resolution),oe.hasOwnProperty("depth")&&Ye.set_m_depth(oe.depth),oe.hasOwnProperty("concavity")&&Ye.set_m_concavity(oe.concavity),oe.hasOwnProperty("planeDownsampling")&&Ye.set_m_planeDownsampling(oe.planeDownsampling),oe.hasOwnProperty("convexhullDownsampling")&&Ye.set_m_convexhullDownsampling(oe.convexhullDownsampling),oe.hasOwnProperty("alpha")&&Ye.set_m_alpha(oe.alpha),oe.hasOwnProperty("beta")&&Ye.set_m_beta(oe.beta),oe.hasOwnProperty("gamma")&&Ye.set_m_gamma(oe.gamma),oe.hasOwnProperty("pca")&&Ye.set_m_pca(oe.pca),oe.hasOwnProperty("mode")&&Ye.set_m_mode(oe.mode),oe.hasOwnProperty("maxNumVerticesPerCH")&&Ye.set_m_maxNumVerticesPerCH(oe.maxNumVerticesPerCH),oe.hasOwnProperty("minVolumePerCH")&&Ye.set_m_minVolumePerCH(oe.minVolumePerCH),oe.hasOwnProperty("convexhullApproximation")&&Ye.set_m_convexhullApproximation(oe.convexhullApproximation),oe.hasOwnProperty("oclAcceleration")&&Ye.set_m_oclAcceleration(oe.oclAcceleration);const Qe=Ammo._malloc(Pe*3*8+3),lt=Ammo._malloc(Re*3*4);let ot=Qe/8,Ne=lt/4;for(let pt=0;pt<L.length;pt++){const Ot=L[pt];J.fromArray(N[pt]);for(let It=0;It<Ot.length;It+=3)T.set(Ot[It+0],Ot[It+1],Ot[It+2]).applyMatrix4(J).sub(Z),Ammo.HEAPF64[ot+0]=T.x,Ammo.HEAPF64[ot+1]=T.y,Ammo.HEAPF64[ot+2]=T.z,ot+=3;if(X[pt]){const It=X[pt];for(let Bt=0;Bt<It.length;Bt++)Ammo.HEAP32[Ne]=It[Bt],Ne++}else for(let It=0;It<Ot.length/3;It++)Ammo.HEAP32[Ne]=It,Ne++}Ee.Compute(Qe,3,Pe,lt,3,Re,Ye),Ammo._free(Qe),Ammo._free(lt);const at=Ee.GetNConvexHulls(),$e=[],ut=new Ammo.ConvexHull;for(let pt=0;pt<at;pt++){Ee.GetConvexHull(pt,ut);const Ot=ut.get_m_nPoints(),It=ut.get_m_points(),Bt=new Ammo.btConvexHullShape;Bt.setMargin(oe.margin);for(let Wt=0;Wt<Ot;Wt++){const Tt=new Ammo.btVector3,Yt=ut.get_m_points(Wt*3+0),Kt=ut.get_m_points(Wt*3+1),Zt=ut.get_m_points(Wt*3+2);Tt.setValue(Yt,Kt,Zt),Bt.addPoint(Tt,Wt===Ot-1),Ammo.destroy(Tt)}$e.push(Bt)}return Ammo.destroy(ut),Ammo.destroy(Ee),$e}}(),fe.createTriMeshShape=function(){const T=new We.Vector3,Z=new We.Vector3,J=new We.Vector3,L=new We.Matrix4;return function(N,X,Q,oe,me={}){if(me.type=fe.TYPE.MESH,E(me),me.fit===fe.FIT.MANUAL)return console.warn("cannot use fit: manual with type: mesh"),null;const Te=G(oe,me),Pe=new Ammo.btVector3,Re=new Ammo.btVector3,Ee=new Ammo.btVector3,Ye=new Ammo.btTriangleMesh(!0,!1);for(let ot=0;ot<N.length;ot++){const Ne=N[ot],at=Q[ot]?Q[ot]:null;if(L.fromArray(X[ot]),at)for(let $e=0;$e<at.length;$e+=3){const ut=at[$e]*3,pt=at[$e+1]*3,Ot=at[$e+2]*3;T.set(Ne[ut],Ne[ut+1],Ne[ut+2]).applyMatrix4(L),Z.set(Ne[pt],Ne[pt+1],Ne[pt+2]).applyMatrix4(L),J.set(Ne[Ot],Ne[Ot+1],Ne[Ot+2]).applyMatrix4(L),Pe.setValue(T.x,T.y,T.z),Re.setValue(Z.x,Z.y,Z.z),Ee.setValue(J.x,J.y,J.z),Ye.addTriangle(Pe,Re,Ee,!1)}else for(let $e=0;$e<Ne.length;$e+=9)T.set(Ne[$e+0],Ne[$e+1],Ne[$e+2]).applyMatrix4(L),Z.set(Ne[$e+3],Ne[$e+4],Ne[$e+5]).applyMatrix4(L),J.set(Ne[$e+6],Ne[$e+7],Ne[$e+8]).applyMatrix4(L),Pe.setValue(T.x,T.y,T.z),Re.setValue(Z.x,Z.y,Z.z),Ee.setValue(J.x,J.y,J.z),Ye.addTriangle(Pe,Re,Ee,!1)}const Qe=new Ammo.btVector3(Te.x,Te.y,Te.z);Ye.setScaling(Qe),Ammo.destroy(Qe);let lt;return me.concave?lt=new Ammo.btBvhTriangleMeshShape(Ye,!0,!0):lt=new Ammo.btConvexTriangleMeshShape(Ye,!0),lt.resources=[Ye],Ammo.destroy(Pe),Ammo.destroy(Re),Ammo.destroy(Ee),lt}}();const I=function(T={}){if(E(T),T.fit===fe.FIT.ALL)return console.warn("cannot use fit: all with type: heightfield"),null;const Z=T.heightfieldDistance||1,J=T.heightfieldData||[],L=T.heightScale||0,N=T.hasOwnProperty("upAxis")?T.upAxis:1,X=(()=>{switch(T.heightDataType){case"short":return Ammo.PHY_SHORT;case"float":return Ammo.PHY_FLOAT;default:return Ammo.PHY_FLOAT}})(),Q=T.hasOwnProperty("flipQuadEdges")?T.flipQuadEdges:!0,oe=J.length,me=oe>0?J[0].length:0,Te=Ammo._malloc(oe*me*4),Pe=Te/4;let Re=Number.POSITIVE_INFINITY,Ee=Number.NEGATIVE_INFINITY,Ye=0;for(let ot=0;ot<oe;ot++)for(let Ne=0;Ne<me;Ne++){const at=J[ot][Ne];Ammo.HEAPF32[Pe+Ye]=at,Ye++,Re=Math.min(Re,at),Ee=Math.max(Ee,at)}const Qe=new Ammo.btHeightfieldTerrainShape(me,oe,Te,L,Re,Ee,N,X,Q),lt=new Ammo.btVector3(Z,1,Z);return Qe.setLocalScaling(lt),Ammo.destroy(lt),Qe.heightfieldData=Te,Qe};fe.createHeightfieldTerrainShape=I;function E(T){T.type=T.type||fe.TYPE.HULL,T.margin=T.hasOwnProperty("margin")?T.margin:.01;return}const U=function(T,Z,J){return};fe.iterateGeometries=function(){const T=new We.Matrix4;return function(Z,J,L){+We.REVISION>=123?T.copy(Z.matrixWorld).invert():T.getInverse(Z.matrixWorld);const N=new We.Vector3;N.setFromMatrixScale(Z.matrixWorld),Z.traverse(X=>{const Q=new We.Matrix4;X.isMesh&&(J.includeInvisible||X.el&&X.el.object3D.visible||X.visible)&&(X===Z?Q.identity():(X.updateWorldMatrix(!0),Q.multiplyMatrices(T,X.matrixWorld)),L(X.geometry.isBufferGeometry?X.geometry.attributes.position.array:X.geometry.vertices,Q.elements,X.geometry.index?X.geometry.index.array:null))})}}();const G=function(){const T=new We.Matrix4;return function(Z,J={}){const L=new We.Vector3(1,1,1);return J.fit===fe.FIT.ALL&&(T.fromArray(Z),L.setFromMatrixScale(T)),L}}(),Y=function(){const T=new We.Vector3;return function(Z,J,L){let N=0,{x:X,y:Q,z:oe}=L.getCenter(T);return Me(Z,J,me=>{const Te=X-me.x,Pe=Q-me.y,Re=oe-me.z;N=Math.max(N,Te*Te+Pe*Pe+Re*Re)}),Math.sqrt(N)}}(),we=function(T,Z,J){const L=new We.Vector3;return L.subVectors(T.max,T.min).multiplyScalar(.5).clampScalar(Z,J)},Se=function(T,Z){const J=new We.Box3;let L=Infinity,N=Infinity,X=Infinity,Q=-Infinity,oe=-Infinity,me=-Infinity;return J.min.set(0,0,0),J.max.set(0,0,0),Me(T,Z,Te=>{Te.x<L&&(L=Te.x),Te.y<N&&(N=Te.y),Te.z<X&&(X=Te.z),Te.x>Q&&(Q=Te.x),Te.y>oe&&(oe=Te.y),Te.z>me&&(me=Te.z)}),J.min.set(L,N,X),J.max.set(Q,oe,me),J},Me=function(){const T=new We.Vector3,Z=new We.Matrix4;return function(J,L,N){for(let X=0;X<J.length;X++){Z.fromArray(L[X]);for(let Q=0;Q<J[X].length;Q+=3)T.set(J[X][Q],J[X][Q+1],J[X][Q+2]).applyMatrix4(Z),N(T)}}}()}),Gg=dn(function(an,fe){/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|GNU GPLv3}
 */Object.defineProperty(fe,"__esModule",{value:!0}),fe.createTorusShape=void 0;const rt=(h,l)=>{const{radius:f=1,tube:A=.4,tubularSegments:P=8}=h,I=Math.PI,E=P,U=Math.sqrt(2*A*A-2*A*A*Math.cos(2*I/E)),G=new Ammo.btVector3(A,I/E+.5*U,A),Y=new Ammo.btCylinderShape(G);Y.setMargin(.05);const we=new Ammo.btCompoundShape,Se=new Ammo.btVector3(0,0,1),Me=new Ammo.btVector3(0,f,0),T=new Ammo.btQuaternion(l.x,l.y,l.z,l.w);for(let Z=0;Z<E;Z++){const J=Z*2*I/E,L=Me.rotate(Se,J),N=new Ammo.btTransform;T.setRotation(Se,J+Math.PI/2),N.setIdentity(),N.setOrigin(L),N.setRotation(T),we.addChildShape(N,Y)}return we};fe.createTorusShape=rt}),tp=dn(function(an,fe){Object.defineProperty(fe,"__esModule",{value:!0});class rt{constructor(){this._defaultMaterial=new We.MeshLambertMaterial({color:13421772})}get(){return this._defaultMaterial}}fe.default=rt}),np=dn(function(an,fe){/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|GNU GPLv3}
 */var rt=Eo&&Eo.__rest||function(l,f){var A={};for(var P in l)Object.prototype.hasOwnProperty.call(l,P)&&f.indexOf(P)<0&&(A[P]=l[P]);if(l!=null&&typeof Object.getOwnPropertySymbols=="function")for(var I=0,P=Object.getOwnPropertySymbols(l);I<P.length;I++)f.indexOf(P[I])<0&&Object.prototype.propertyIsEnumerable.call(l,P[I])&&(A[P[I]]=l[P[I]]);return A};Object.defineProperty(fe,"__esModule",{value:!0});class h{constructor(l){this.scene=l,this.isHeadless=l==="headless",this.defaultMaterial=new tp.default}get make(){return{plane:(l={},f={})=>this.makePlane(l,f),box:(l={},f={})=>this.makeBox(l,f),sphere:(l={},f={})=>this.makeSphere(l,f),cylinder:(l={},f={})=>this.makeCylinder(l,f),cone:(l={},f={})=>this.makeCone(l,f),torus:(l={},f={})=>this.makeTorus(l,f),extrude:(l,f={})=>this.makeExtrude(l,f)}}get add(){return{mesh:l=>this.addMesh(l),existing:l=>this.addExisting(l),plane:(l={},f={})=>this.addPlane(l,f),box:(l={},f={})=>this.addBox(l,f),ground:(l,f={})=>this.addGround(l,f),sphere:(l={},f={})=>this.addSphere(l,f),cylinder:(l={},f={})=>this.addCylinder(l,f),cone:(l={},f={})=>this.addCone(l,f),torus:(l={},f={})=>this.addTorus(l,f),extrude:(l,f={})=>this.addExtrude(l,f),material:(l={})=>this.addMaterial(l)}}addExisting(...l){if(this.scene==="headless")return;this.scene.add(...l)}addMesh(l){if(Array.isArray(l))for(let f=0;f<l.length;f++)this.addExisting(l[f]);else this.addExisting(l);return this}createMesh(l,f,A){const{x:P=0,y:I=0,z:E=0}=A;let U;switch(!Array.isArray(f)&&f.type){case"LineBasicMaterial":U=new We.Line(l,f);break;case"PointsMaterial":U=new We.Points(l,f);break;default:U=new Zs.ExtendedMesh(l,f);break}return U.position.set(P,I,E),U.castShadow=U.receiveShadow=!0,U}makeExtrude(l,f){const{x:A,y:P,z:I,name:E,shape:U,autoCenter:G=!0,breakable:Y=!1,bufferGeometry:we=!0}=l,Se=rt(l,["x","y","z","name","shape","autoCenter","breakable","bufferGeometry"]),{depth:Me=1,bevelEnabled:T=!1}=Se,Z=we||Y||this.isHeadless?new We.ExtrudeBufferGeometry(U,Object.assign({depth:Me,bevelEnabled:T},Se)):new We.ExtrudeGeometry(U,Object.assign({depth:Me,bevelEnabled:T},Se)),J=this.addMaterial(f),L=this.createMesh(Z,J,{x:A,y:P,z:I});return G&&L.geometry.center(),L.name=E||`body_id_${L.id}`,L.shape="extrude",L}addExtrude(l,f={}){const A=this.makeExtrude(l,f);return this.addExisting(A),A}makePlane(l,f){const{x:A,y:P,z:I,name:E,breakable:U=!1,bufferGeometry:G=!0}=l,Y=rt(l,["x","y","z","name","breakable","bufferGeometry"]),we=G||U||this.isHeadless?new We.PlaneBufferGeometry(Y.width||1,Y.height||1,Y.widthSegments||1,Y.heightSegments||1):new We.PlaneGeometry(Y.width||1,Y.height||1,Y.widthSegments||1,Y.heightSegments||1),Se=this.addMaterial(f);Se.side=We.DoubleSide;const Me=this.createMesh(we,Se,{x:A,y:P,z:I});return Me.name=E||`body_id_${Me.id}`,Me.shape="plane",Me}addPlane(l,f){const A=this.makePlane(l,f);return this.addExisting(A),A}makeSphere(l,f){const{x:A,y:P,z:I,name:E,breakable:U=!1,bufferGeometry:G=!0}=l,Y=rt(l,["x","y","z","name","breakable","bufferGeometry"]),we=G||U||this.isHeadless?new We.SphereBufferGeometry(Y.radius||1,Y.widthSegments||16,Y.heightSegments||12,Y.phiStart||void 0,Y.phiLength||void 0,Y.thetaStart||void 0,Y.thetaLength||void 0):new We.SphereGeometry(Y.radius||1,Y.widthSegments||16,Y.heightSegments||12,Y.phiStart||void 0,Y.phiLength||void 0,Y.thetaStart||void 0,Y.thetaLength||void 0),Se=this.addMaterial(f),Me=this.createMesh(we,Se,{x:A,y:P,z:I});return Me.name=E||`body_id_${Me.id}`,Me.shape="sphere",Me}addSphere(l={},f={}){const A=this.makeSphere(l,f);return this.addExisting(A),A}makeBox(l,f){const{x:A,y:P,z:I,name:E,breakable:U=!1,bufferGeometry:G=!0}=l,Y=rt(l,["x","y","z","name","breakable","bufferGeometry"]),we=G||U||this.isHeadless?new We.BoxBufferGeometry(Y.width||1,Y.height||1,Y.depth||1,Y.widthSegments||void 0,Y.heightSegments||void 0,Y.depthSegments||void 0):new We.BoxGeometry(Y.width||1,Y.height||1,Y.depth||1,Y.widthSegments||void 0,Y.heightSegments||void 0,Y.depthSegments||void 0),Se=this.addMaterial(f),Me=this.createMesh(we,Se,{x:A,y:P,z:I});return Me.name=E||`body_id_${Me.id}`,Me.shape="box",Me}addBox(l={},f={}){const A=this.makeBox(l,f);return this.addExisting(A),A}addGround(l,f={}){const A=this.makeBox(l,f);return A.rotateX(We.MathUtils.degToRad(90)),this.addExisting(A),A}makeCylinder(l={},f={}){const{x:A,y:P,z:I,name:E,breakable:U=!1,bufferGeometry:G=!0}=l,Y=rt(l,["x","y","z","name","breakable","bufferGeometry"]),we=G||U||this.isHeadless?new We.CylinderBufferGeometry(Y.radiusTop||1,Y.radiusBottom||1,Y.height||1,Y.radiusSegments||void 0,Y.heightSegments||void 0,Y.openEnded||void 0,Y.thetaStart||void 0,Y.thetaLength||void 0):new We.CylinderGeometry(Y.radiusTop||1,Y.radiusBottom||1,Y.height||1,Y.radiusSegments||void 0,Y.heightSegments||void 0,Y.openEnded||void 0,Y.thetaStart||void 0,Y.thetaLength||void 0),Se=this.addMaterial(f),Me=this.createMesh(we,Se,{x:A,y:P,z:I});return Me.name=E||`body_id_${Me.id}`,Me.shape="cylinder",Me}addCylinder(l={},f={}){const A=this.makeCylinder(l,f);return this.addExisting(A),A}makeCone(l={},f={}){const{x:A,y:P,z:I,name:E,breakable:U=!1,bufferGeometry:G=!0}=l,Y=rt(l,["x","y","z","name","breakable","bufferGeometry"]),we=G||U||this.isHeadless?new We.ConeBufferGeometry(Y.radius||1,Y.height||1,Y.radiusSegments||8,Y.heightSegments||1,Y.openEnded||!1,Y.thetaStart||0,Y.thetaLength||2*Math.PI):new We.ConeBufferGeometry(Y.radius||1,Y.height||1,Y.radiusSegments||8,Y.heightSegments||1,Y.openEnded||!1,Y.thetaStart||0,Y.thetaLength||2*Math.PI),Se=this.addMaterial(f),Me=this.createMesh(we,Se,{x:A,y:P,z:I});return Me.name=E||`body_id_${Me.id}`,Me.shape="cone",Me}addCone(l={},f={}){const A=this.makeCone(l,f);return this.addExisting(A),A}makeTorus(l={},f={}){const{x:A,y:P,z:I,name:E,breakable:U=!1,bufferGeometry:G=!0}=l,Y=rt(l,["x","y","z","name","breakable","bufferGeometry"]),we=G||U||this.isHeadless?new We.TorusBufferGeometry(Y.radius||void 0,Y.tube||void 0,Y.radialSegments||void 0,Y.tubularSegments||void 0,Y.arc||void 0):new We.TorusGeometry(Y.radius||void 0,Y.tube||void 0,Y.radialSegments||void 0,Y.tubularSegments||void 0,Y.arc||void 0),Se=this.addMaterial(f),Me=this.createMesh(we,Se,{x:A,y:P,z:I});return Me.name=E||`body_id_${Me.id}`,Me.shape="torus",Me}addTorus(l={},f={}){const A=this.makeTorus(l,f);return this.addExisting(A),A}addMaterial(l={}){const f=Object.keys(l)[0];let A;if(this.scene==="headless")return this.defaultMaterial.get();switch(f){case"basic":A=new We.MeshBasicMaterial(l.basic);break;case"normal":A=new We.MeshNormalMaterial(l.normal);break;case"standard":A=new We.MeshStandardMaterial(l.standard);break;case"lambert":A=new We.MeshLambertMaterial(l.lambert);break;case"phong":A=new We.MeshPhongMaterial(l.phong);break;case"physical":typeof l.physical!="undefined"?A=new We.MeshPhysicalMaterial(l.physical):(mi.default("You need to pass parameters to the physical material. (Fallback to default material)"),A=this.defaultMaterial.get());break;case"toon":A=new We.MeshToonMaterial(l.toon);break;case"line":A=new We.LineBasicMaterial(l.line);break;case"points":A=new We.PointsMaterial(l.points);break;case"custom":A=l.custom||this.defaultMaterial.get();break;default:A=this.defaultMaterial.get();break}return A}}fe.default=h}),Vg=dn(function(an,fe){/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|GNU GPLv3}
 */Object.defineProperty(fe,"__esModule",{value:!0}),fe.CollisionEvents=void 0;class rt extends Aa.EventEmitter{addCollider(h,l,f){if(!h.body||!l.body)return;h.body.checkCollisions=!0,l.body.checkCollisions=!0,this.on("collision",A=>{var P,I;const{bodies:E,event:U}=A;((P=E[0])===null||P===void 0?void 0:P.name)&&((I=E[1])===null||I===void 0?void 0:I.name)&&(h==null?void 0:h.name)&&(l==null?void 0:l.name)&&((E[0].name===h.name&&E[1].name===l.name||E[1].name===h.name&&E[0].name===l.name)&&f(U))})}}fe.CollisionEvents=rt}),jg=dn(function(an,fe){Object.defineProperty(fe,"__esModule",{value:!0});/**
 * @author       Kevin Lee (https://github.com/InfiniteLee)
 * @copyright    Copyright (c) 2019 Kevin Lee; Project Url: https://github.com/InfiniteLee/ammo-debug-drawer
 * @license      {@link https://github.com/InfiniteLee/ammo-debug-drawer/blob/master/LICENSE|MPL-2.0}
 */const rt={NoDebug:0,DrawWireframe:1,DrawAabb:2,DrawFeaturesText:4,DrawContactPoints:8,NoDeactivation:16,NoHelpText:32,DrawText:64,ProfileTimings:128,EnableSatComparison:256,DisableBulletLCP:512,EnableCCD:1024,DrawConstraints:1<<11,DrawConstraintLimits:1<<12,FastWireframe:1<<13,DrawNormals:1<<14,DrawOnTop:1<<15,MAX_DEBUG_DRAW_MODE:4294967295};class h{constructor(l,f,A={}){this.scene=l,this.world=f,this.options=A,this.debugDrawMode=A.debugDrawMode||rt.DrawWireframe;const P=this.debugDrawMode&rt.DrawOnTop||!1,I=A.maxBufferSize||1e6;this.geometry=new We.BufferGeometry;const E=new Float32Array(I*3),U=new Float32Array(I*3);this.geometry.setAttribute("position",new We.BufferAttribute(E,3).setUsage(We.StaticDrawUsage)),this.geometry.setAttribute("color",new We.BufferAttribute(U,3).setUsage(We.StaticDrawUsage)),this.index=0;const G=new We.LineBasicMaterial({vertexColors:!0,depthTest:!P});this.mesh=new We.LineSegments(this.geometry,G),P&&(this.mesh.renderOrder=999),this.mesh.frustumCulled=!1,this.enabled=!1,this.debugDrawer=new Ammo.DebugDrawer,this.debugDrawer.drawLine=this.drawLine.bind(this),this.debugDrawer.drawContactPoint=this.drawContactPoint.bind(this),this.debugDrawer.reportErrorWarning=this.reportErrorWarning.bind(this),this.debugDrawer.draw3dText=this.draw3dText.bind(this),this.debugDrawer.setDebugMode=this.setDebugMode.bind(this),this.debugDrawer.getDebugMode=this.getDebugMode.bind(this),this.world.setDebugDrawer(this.debugDrawer)}enable(){this.enabled=!0,this.scene.add(this.mesh)}disable(){this.enabled=!1,this.scene.remove(this.mesh)}update(){if(!this.enabled)return;this.index!=0&&(this.geometry.attributes.position.needsUpdate=!0,this.geometry.attributes.color.needsUpdate=!0),this.index=0,this.world.debugDrawWorld(),this.geometry.setDrawRange(0,this.index)}drawLine(l,f,A){const P=Ammo.HEAPF32,I=P[(A+0)/4],E=P[(A+4)/4],U=P[(A+8)/4],G=P[(l+0)/4],Y=P[(l+4)/4],we=P[(l+8)/4];this.geometry.attributes.position.setXYZ(this.index,G,Y,we),this.geometry.attributes.color.setXYZ(this.index++,I,E,U);const Se=P[(f+0)/4],Me=P[(f+4)/4],T=P[(f+8)/4];this.geometry.attributes.position.setXYZ(this.index,Se,Me,T),this.geometry.attributes.color.setXYZ(this.index++,I,E,U)}drawContactPoint(l,f,A,P,I){const E=Ammo.HEAPF32,U=E[(I+0)/4],G=E[(I+4)/4],Y=E[(I+8)/4],we=E[(l+0)/4],Se=E[(l+4)/4],Me=E[(l+8)/4];this.geometry.attributes.position.setXYZ(this.index,we,Se,Me),this.geometry.attributes.color.setXYZ(this.index++,U,G,Y);const T=E[(f+0)/4]*A,Z=E[(f+4)/4]*A,J=E[(f+8)/4]*A;this.geometry.attributes.position.setXYZ(this.index,we+T,Se+Z,Me+J),this.geometry.attributes.color.setXYZ(this.index++,U,G,Y)}reportErrorWarning(l){Ammo.hasOwnProperty("Pointer_stringify")?console.warn(Ammo.Pointer_stringify(l)):this.warnedOnce||(this.warnedOnce=!0,console.warn("Cannot print warningString, please rebuild Ammo.js using 'debug' flag"))}draw3dText(l,f){console.warn("TODO: draw3dText")}setDebugMode(l){this.debugDrawMode=l}getDebugMode(){return this.debugDrawMode}}fe.default=h}),Wg=dn(function(an,fe){Object.defineProperty(fe,"__esModule",{value:!0}),fe.ConvexObjectBreaker=void 0;const rt=We,h=function(l,f){this.minSizeForBreak=l||1.4,this.smallDelta=f||1e-4,this.tempLine1=new We.Line3,this.tempPlane1=new We.Plane,this.tempPlane2=new We.Plane,this.tempPlane_Cut=new We.Plane,this.tempCM1=new We.Vector3,this.tempCM2=new We.Vector3,this.tempVector3=new We.Vector3,this.tempVector3_2=new We.Vector3,this.tempVector3_3=new We.Vector3,this.tempVector3_P0=new We.Vector3,this.tempVector3_P1=new We.Vector3,this.tempVector3_P2=new We.Vector3,this.tempVector3_N0=new We.Vector3,this.tempVector3_N1=new We.Vector3,this.tempVector3_AB=new We.Vector3,this.tempVector3_CB=new We.Vector3,this.tempResultObjects={object1:null,object2:null},this.segments=[];for(var A=30*30,P=0;P<A;P++)this.segments[P]=!1};fe.ConvexObjectBreaker=h,h.prototype={constructor:h,prepareBreakableObject:function(l,f,A,P,I){l.geometry.isBufferGeometry||console.error("THREE.ConvexObjectBreaker.prepareBreakableObject(): Parameter object must have a BufferGeometry."),l.userData.ammoPhysicsData={};var E=l.userData.ammoPhysicsData;E.mass=f,E.velocity=A.clone(),E.angularVelocity=P.clone(),E.breakable=I},subdivideByImpact:function(l,f,A,P,I){var E=[],U=this.tempPlane1,G=this.tempPlane2;this.tempVector3.addVectors(f,A),U.setFromCoplanarPoints(f,l.position,this.tempVector3);var Y=I+P,we=this;function Se(Me,T,Z,J){if(Math.random()<J*.05||J>Y){E.push(Me);return}var L=Math.PI;J===0?(G.normal.copy(U.normal),G.constant=U.constant):J<=P?(L=(Z-T)*(.2+.6*Math.random())+T,we.tempVector3_2.copy(l.position).sub(f).applyAxisAngle(A,L).add(f),G.setFromCoplanarPoints(f,we.tempVector3,we.tempVector3_2)):(L=(.5*(J&1)+.2*(2-Math.random()))*Math.PI,we.tempVector3_2.copy(f).sub(Me.position).applyAxisAngle(A,L).add(Me.position),we.tempVector3_3.copy(A).add(Me.position),G.setFromCoplanarPoints(Me.position,we.tempVector3_3,we.tempVector3_2)),we.cutByPlane(Me,G,we.tempResultObjects);var N=we.tempResultObjects.object1,X=we.tempResultObjects.object2;N&&Se(N,T,L,J+1),X&&Se(X,L,Z,J+1)}return Se(l,0,2*Math.PI,0),E},cutByPlane:function(l,f,A){var P=l.geometry,I=P.attributes.position.array,E=P.attributes.normal.array,U=I.length/3,G=U/3,Y=P.getIndex();Y&&(Y=Y.array,G=Y.length/3);function we(Oe,O){var C=Oe*3+O;return Y?Y[C]:C}for(var Se=[],Me=[],T=this.smallDelta,Z=U*U,J=0;J<Z;J++)this.segments[J]=!1;for(var L=this.tempVector3_P0,N=this.tempVector3_P1,X=this.tempVector3_N0,Q=this.tempVector3_N1,J=0;J<G-1;J++){var oe=we(J,0),me=we(J,1),Te=we(J,2);X.set(E[oe],E[oe]+1,E[oe]+2);for(var Pe=J+1;Pe<G;Pe++){var Re=we(Pe,0),Ee=we(Pe,1),Ye=we(Pe,2);Q.set(E[Re],E[Re]+1,E[Re]+2);var Qe=1-X.dot(Q)<T;Qe&&(oe===Re||oe===Ee||oe===Ye?me===Re||me===Ee||me===Ye?(this.segments[oe*U+me]=!0,this.segments[me*U+oe]=!0):(this.segments[Te*U+oe]=!0,this.segments[oe*U+Te]=!0):(me===Re||me===Ee||me===Ye)&&(this.segments[Te*U+me]=!0,this.segments[me*U+Te]=!0))}}var lt=this.tempPlane_Cut;l.updateMatrix(),h.transformPlaneToLocalSpace(f,l.matrix,lt);for(var J=0;J<G;J++)for(var ot=we(J,0),Ne=we(J,1),at=we(J,2),$e=0;$e<3;$e++){var ut=$e===0?ot:$e===1?Ne:at,pt=$e===0?Ne:$e===1?at:ot,Ot=this.segments[ut*U+pt];if(Ot)continue;this.segments[ut*U+pt]=!0,this.segments[pt*U+ut]=!0,L.set(I[3*ut],I[3*ut+1],I[3*ut+2]),N.set(I[3*pt],I[3*pt+1],I[3*pt+2]);var It=0,Bt=lt.distanceToPoint(L);Bt>T?(It=2,Me.push(L.clone())):Bt<-T?(It=1,Se.push(L.clone())):(It=3,Se.push(L.clone()),Me.push(L.clone()));var Wt=0,Bt=lt.distanceToPoint(N);if(Bt>T?(Wt=2,Me.push(N.clone())):Bt<-T?(Wt=1,Se.push(N.clone())):(Wt=3,Se.push(N.clone()),Me.push(N.clone())),It===1&&Wt===2||It===2&&Wt===1){this.tempLine1.start.copy(L),this.tempLine1.end.copy(N);var Tt=new We.Vector3;if(Tt=lt.intersectLine(this.tempLine1,Tt),Tt===void 0)return console.error("Internal error: segment does not intersect plane."),A.segmentedObject1=null,A.segmentedObject2=null,0;Se.push(Tt),Me.push(Tt.clone())}}var Yt=l.userData.ammoPhysicsData.mass*.5;this.tempCM1.set(0,0,0);var Kt=0,Zt=Se.length;if(Zt>0){for(var J=0;J<Zt;J++)this.tempCM1.add(Se[J]);this.tempCM1.divideScalar(Zt);for(var J=0;J<Zt;J++){var be=Se[J];be.sub(this.tempCM1),Kt=Math.max(Kt,be.x,be.y,be.z)}this.tempCM1.add(l.position)}this.tempCM2.set(0,0,0);var de=0,re=Me.length;if(re>0){for(var J=0;J<re;J++)this.tempCM2.add(Me[J]);this.tempCM2.divideScalar(re);for(var J=0;J<re;J++){var be=Me[J];be.sub(this.tempCM2),de=Math.max(de,be.x,be.y,be.z)}this.tempCM2.add(l.position)}var q=null,he=null,Ze=0;if(Zt>4)try{q=new We.Mesh(new rt.ConvexBufferGeometry(Se),l.material),q.position.copy(this.tempCM1),q.quaternion.copy(l.quaternion),q.userData=l.userData,this.prepareBreakableObject(q,Yt,l.userData.ammoPhysicsData.velocity,l.userData.ammoPhysicsData.angularVelocity,2*Kt>this.minSizeForBreak),Ze++}catch(Oe){mi.default("Error in ConvexObjectBreaker.ts"),mi.default(Oe)}if(re>4)try{he=new We.Mesh(new rt.ConvexBufferGeometry(Me),l.material),he.position.copy(this.tempCM2),he.quaternion.copy(l.quaternion),he.userData=l.userData,this.prepareBreakableObject(he,Yt,l.userData.ammoPhysicsData.velocity,l.userData.ammoPhysicsData.angularVelocity,2*de>this.minSizeForBreak),Ze++}catch(Oe){mi.default("Error in ConvexObjectBreaker.ts"),mi.default(Oe)}return A.object1=q,A.object2=he,Ze}},h.transformFreeVector=function(l,f){var A=l.x,P=l.y,I=l.z,E=f.elements;return l.x=E[0]*A+E[4]*P+E[8]*I,l.y=E[1]*A+E[5]*P+E[9]*I,l.z=E[2]*A+E[6]*P+E[10]*I,l},h.transformFreeVectorInverse=function(l,f){var A=l.x,P=l.y,I=l.z,E=f.elements;return l.x=E[0]*A+E[1]*P+E[2]*I,l.y=E[4]*A+E[5]*P+E[6]*I,l.z=E[8]*A+E[9]*P+E[10]*I,l},h.transformTiedVectorInverse=function(l,f){var A=l.x,P=l.y,I=l.z,E=f.elements;return l.x=E[0]*A+E[1]*P+E[2]*I-E[12],l.y=E[4]*A+E[5]*P+E[6]*I-E[13],l.z=E[8]*A+E[9]*P+E[10]*I-E[14],l},h.transformPlaneToLocalSpace=function(){var l=new We.Vector3;return function(A,P,I){I.normal.copy(A.normal),I.constant=A.constant;var E=h.transformTiedVectorInverse(A.coplanarPoint(l),P);h.transformFreeVectorInverse(I.normal,P),I.constant=-E.dot(I.normal)}}()}),Xg=dn(function(an,fe){Object.defineProperty(fe,"__esModule",{value:!0});const rt=(()=>{try{if(typeof WebAssembly=="object"&&typeof WebAssembly.instantiate=="function"){const f=new WebAssembly.Module(Uint8Array.of(0,97,115,109,1,0,0,0));if(f instanceof WebAssembly.Module)return new WebAssembly.Instance(f)instanceof WebAssembly.Instance}}catch(f){}return!1})(),h=(f,A)=>{var P=document.createElement("script");P.onload=()=>{A()},P.onerror=()=>{throw new Error("failed to load "+f)},P.async=!0,P.src=f,document.head.appendChild(P)},l=(f,A)=>{rt?h(`${f}/ammo.wasm.js`,()=>A()):h(`${f}/ammo.js`,()=>A())};fe.default=l}),rp=dn(function(an,fe){Object.defineProperty(fe,"__esModule",{value:!0}),fe.PhysicsLoader=void 0;const rt=(h,l)=>{typeof window!="undefined"&&(window.__loadPhysics=!0),Xg.default(h,()=>{Ammo().then(()=>{l()})})};fe.PhysicsLoader=rt}),ip=dn(function(an,fe){/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|GNU GPLv3}
 */Object.defineProperty(fe,"__esModule",{value:!0}),fe.Group=fe.Points=fe.Line=fe.Material=fe.Mesh=fe.Object3D=fe.AnimationAction=fe.AnimationClip=fe.AnimationMixer=fe.ExtendedMesh=fe.ExtendedObject3D=void 0,Object.defineProperty(fe,"ExtendedObject3D",{enumerable:!0,get:function(){return ql.ExtendedObject3D}}),Object.defineProperty(fe,"ExtendedMesh",{enumerable:!0,get:function(){return Zs.ExtendedMesh}}),Object.defineProperty(fe,"AnimationMixer",{enumerable:!0,get:function(){return We.AnimationMixer}}),Object.defineProperty(fe,"AnimationClip",{enumerable:!0,get:function(){return We.AnimationClip}}),Object.defineProperty(fe,"AnimationAction",{enumerable:!0,get:function(){return We.AnimationAction}}),Object.defineProperty(fe,"Object3D",{enumerable:!0,get:function(){return We.Object3D}}),Object.defineProperty(fe,"Mesh",{enumerable:!0,get:function(){return We.Mesh}}),Object.defineProperty(fe,"Material",{enumerable:!0,get:function(){return We.Material}}),Object.defineProperty(fe,"Line",{enumerable:!0,get:function(){return We.Line}}),Object.defineProperty(fe,"Points",{enumerable:!0,get:function(){return We.Points}}),Object.defineProperty(fe,"Group",{enumerable:!0,get:function(){return We.Group}})}),op=dn(function(an,fe){Object.defineProperty(fe,"__esModule",{value:!0});const rt=(h,l)=>{l.forEach(f=>{Object.getOwnPropertyNames(f.prototype).forEach(A=>{Object.defineProperty(h.prototype,A,Object.getOwnPropertyDescriptor(f.prototype,A))})})};fe.default=rt}),qg=dn(function(an,fe){/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|GNU GPLv3}
 */Object.defineProperty(fe,"__esModule",{value:!0});class rt{constructor(h){this.physics=h}getHitPointWorld(){const h=this._btRayCallback.get_m_hitPointWorld(),l={x:h.x(),y:h.y(),z:h.z()};return l}getHitNormalWorld(){const h=this._btRayCallback.get_m_hitNormalWorld(),l={x:h.x(),y:h.y(),z:h.z()};return l}getCollisionObject(){const h=Ammo.castObject(this._btRayCallback.get_m_collisionObject(),Ammo.btRigidBody);return h.threeObject}}fe.default=rt}),Yg=dn(function(an,fe){/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|GNU GPLv3}
 */Object.defineProperty(fe,"__esModule",{value:!0});class rt{constructor(h){this.physics=h}getHitPointsWorld(){const h=this._btRayCallback.get_m_hitPointWorld(),l=[];for(let f=h.size()-1;f>=0;f--){const A=h.at(f);l.push({x:A.x(),y:A.y(),z:A.z()})}return l}getHitPointWorld(){return console.warn("[enable3d] Use getHitPointsWorld() instead of getHitPointWorld() for the AllHitsRayCaster!"),this.getHitPointsWorld()}getHitNormalsWorld(){const h=this._btRayCallback.get_m_hitNormalWorld(),l=[];for(let f=h.size()-1;f>=0;f--){const A=h.at(f);l.push({x:A.x(),y:A.y(),z:A.z()})}return l}getCollisionObjects(){const h=[],l=this._btRayCallback.get_m_collisionObjects();for(let f=l.size()-1;f>=0;f--){const A=Ammo.castObject(l.at(f),Ammo.btRigidBody);h.push(A.threeObject)}return h}}fe.default=rt}),Js=dn(function(an,fe){/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|GNU GPLv3}
 */Object.defineProperty(fe,"__esModule",{value:!0}),fe.AllHitsRaycaster=fe.ClosestRaycaster=void 0;class rt{constructor(f){this.physics=f}setRayFromWorld(f=0,A=0,P=0){this._btRayFrom.setValue(f,A,P)}setRayToWorld(f=0,A=0,P=0){this._btRayTo.setValue(f,A,P)}hasHit(){return this._btRayCallback.hasHit()}rayTest(){typeof this._btRayCallback!="undefined"&&Ammo.destroy(this._btRayCallback),this._btRayCallback=this.type==="closest"?new Ammo.ClosestRayResultCallback(this._btRayFrom,this._btRayTo):new Ammo.AllHitsRayResultCallback(this._btRayFrom,this._btRayTo),this.physics.physicsWorld.rayTest(this._btRayFrom,this._btRayTo,this._btRayCallback)}destroy(){typeof this._btRayFrom!="undefined"&&Ammo.destroy(this._btRayFrom),typeof this._btRayTo!="undefined"&&Ammo.destroy(this._btRayTo),typeof this._btRayCallback!="undefined"&&Ammo.destroy(this._btRayCallback)}}class h{constructor(f){this.physics=f,this.type="closest",this._btRayFrom=new Ammo.btVector3(0,0,0),this._btRayTo=new Ammo.btVector3(0,0,0)}}fe.ClosestRaycaster=h;class l{constructor(f){this.physics=f,this.type="allHits",this._btRayFrom=new Ammo.btVector3(0,0,0),this._btRayTo=new Ammo.btVector3(0,0,0)}}fe.AllHitsRaycaster=l,op.default(h,[rt,qg.default]),op.default(l,[rt,Yg.default])}),Zg=dn(function(an,fe){Object.defineProperty(fe,"__esModule",{value:!0}),fe.Clock=void 0;class rt{constructor(h=!0){this.autoStart=h!==void 0?h:!0,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=(typeof performance=="undefined"?Date:performance).now(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let h=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){let l=(typeof performance=="undefined"?Date:performance).now();h=(l-this.oldTime)/1e3,this.oldTime=l,this.elapsedTime+=h}return h}}fe.Clock=rt}),Jg=dn(function(an,fe){/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|GNU GPLv3}
 */Object.defineProperty(fe,"__esModule",{value:!0}),fe.AmmoPhysics=fe.Clock=fe.Types=fe.AllHitsRaycaster=fe.ClosestRaycaster=fe.PhysicsLoader=fe.ExtendedGroup=fe.ExtendedMesh=fe.ExtendedObject3D=void 0,Object.defineProperty(fe,"ExtendedObject3D",{enumerable:!0,get:function(){return ql.ExtendedObject3D}}),Object.defineProperty(fe,"ExtendedMesh",{enumerable:!0,get:function(){return Zs.ExtendedMesh}}),Object.defineProperty(fe,"ExtendedGroup",{enumerable:!0,get:function(){return ep.ExtendedGroup}}),Object.defineProperty(fe,"PhysicsLoader",{enumerable:!0,get:function(){return rp.PhysicsLoader}}),fe.Types=ip,Object.defineProperty(fe,"ClosestRaycaster",{enumerable:!0,get:function(){return Js.ClosestRaycaster}}),Object.defineProperty(fe,"AllHitsRaycaster",{enumerable:!0,get:function(){return Js.AllHitsRaycaster}}),Object.defineProperty(fe,"Clock",{enumerable:!0,get:function(){return Zg.Clock}});class rt extends Aa.EventEmitter{constructor(h,l={}){super();this.scene=h,this.config=l,this.rigidBodies=[],this.earlierDetectedCollisions=[],this.complexShapes=["plane","hull","hacd","vhacd","convexMesh","concaveMesh"],this.gravity=l.gravity||{x:0,y:-9.81,z:0},this.isHeadless=h==="headless",this.tmpEuler=new We.Euler,this.tmpQuaternion=new We.Quaternion,this.tmpVector3=new We.Vector3,this.tmpVector3a=new We.Vector3,this.tmpMatrix4=new We.Matrix4,this.tmpMatrix4a=new We.Matrix4,this.tmpBtVector3=new Ammo.btVector3,this.tmpBtQuaternion=new Ammo.btQuaternion(0,0,0,1),this.emptyV3=new We.Vector3,this.impactPoint=new We.Vector3,this.impactNormal=new We.Vector3,h!=="headless"&&(this.defaultMaterial=new tp.default),this.start()}get tmpTrans(){return console.warn("Use worldTransform instead of tmpTrans."),this.worldTransform}set tmpTrans(h){console.warn("Use worldTransform instead of tmpTrans."),this.worldTransform=h}destroy(h){var l;const f=Object.keys(h).includes("body")?h.body:h;if(typeof(f==null?void 0:f.ammo)=="undefined")return;const A=f.ammo.name;let P=f.ammo.threeObject;if(A&&P&&((l=P==null?void 0:P.body)===null||l===void 0?void 0:l.ammo)){P.body.isSoftBody?this.physicsWorld.removeSoftBody(P.body.ammo):this.physicsWorld.removeRigidBody(P.body.ammo),P.body.destructor(),P.body=void 0,P.hasBody=!1,delete f.ammo.threeObject;for(let I=0;I<this.rigidBodies.length;I++)this.rigidBodies[I].name===A&&(this.rigidBodies.splice(I,1),I--)}this.scene==="headless"&&P&&(P=null)}setup(){if(this.worldTransform=new Ammo.btTransform,typeof this.config.setupPhysicsWorld=="function"?this.physicsWorld=this.config.setupPhysicsWorld():this.physicsWorld=this.setupPhysicsWorld(),this.scene!=="headless"){this.convexBreaker=new Wg.ConvexObjectBreaker,this.objectsToRemove=[],this.numObjectsToRemove=0;for(let h=0;h<500;h++)this.objectsToRemove[h]=null}this.collisionEvents=new Vg.CollisionEvents,this.factory=new np.default(this.scene),this.shapes=new kg.default(this.factory,(h,l)=>this.addExisting(h,l)),this.constraints=new Hg.default(this.worldTransform,this.physicsWorld),this.scene!=="headless"&&(this.debugDrawer=new jg.default(this.scene,this.physicsWorld,{}))}updateDebugger(){if(this.scene==="headless")return;this.debugDrawer&&this.debugDrawer.enabled&&this.debugDrawer.update()}setupPhysicsWorld(){const h=this.gravity,{softBodies:l=!1}=this.config;let f;if(!l){const A=new Ammo.btDefaultCollisionConfiguration,P=new Ammo.btCollisionDispatcher(A),I=new Ammo.btDbvtBroadphase,E=new Ammo.btSequentialImpulseConstraintSolver;f=new Ammo.btDiscreteDynamicsWorld(P,I,E,A)}if(l){const A=new Ammo.btSoftBodyRigidBodyCollisionConfiguration,P=new Ammo.btCollisionDispatcher(A),I=new Ammo.btDbvtBroadphase,E=new Ammo.btSequentialImpulseConstraintSolver,U=new Ammo.btDefaultSoftBodySolver;f=new Ammo.btSoftRigidDynamicsWorld(P,I,E,A,U)}return f.setGravity(new Ammo.btVector3(h.x,h.y,h.z)),f}createDebrisFromBreakableObject(h,l){if(this.scene==="headless")return;h.material=this.defaultMaterial.get(),h.shape="hull",h.fragmentDepth=l.fragmentDepth+1,this.scene.add(h),this.addExisting(h),h.body.breakable=!1,setTimeout(()=>{h.body.breakable=!0},2500)}removeDebris(h){if(this.scene==="headless")return;this.scene.remove(h),this.destroy(h)}update(h){this.updatePhysics(h),this.detectCollisions()}updatePhysics(h){const l=h/1e3;this.physicsWorld.stepSimulation(l,this.config.maxSubSteps||4,this.config.fixedTimeStep||1/60);for(let f=0;f<this.rigidBodies.length;f++){const A=this.rigidBodies[f],P=A.body.ammo,I=P.getMotionState();if(I){if(I.getWorldTransform(this.worldTransform),A.body.didUpdate&&(A.body._emitUpdateEvents&&A.body.eventEmitter.emit("update"),A.body.didUpdate=!1),A.body.ammo.isKinematicObject()&&A.body.needUpdate)A.getWorldQuaternion(this.tmpQuaternion),A.getWorldPosition(this.tmpVector3),this.tmpBtVector3.setValue(this.tmpVector3.x,this.tmpVector3.y,this.tmpVector3.z),this.tmpBtQuaternion.setValue(this.tmpQuaternion.x,this.tmpQuaternion.y,this.tmpQuaternion.z,this.tmpQuaternion.w),this.worldTransform.setOrigin(this.tmpBtVector3),this.worldTransform.setRotation(this.tmpBtQuaternion),I.setWorldTransform(this.worldTransform),A.body.needUpdate=!1;else if(!A.body.skipUpdate){if(!A.body.ammo.isStaticObject()){let E=this.worldTransform.getOrigin(),U=this.worldTransform.getRotation(),G=A.body.offset;if(A.body.ignoreScale)this.tmpVector3a.set(A.scale.x,A.scale.y,A.scale.z);else{const Y=A.body.ammo.getCollisionShape().getLocalScaling();this.tmpVector3a.set(Y.x(),Y.y(),Y.z())}this.tmpVector3.set(E.x()+G.x,E.y()+G.y,E.z()+G.z),this.tmpQuaternion.set(U.x(),U.y(),U.z(),U.w()),this.tmpMatrix4.compose(this.tmpVector3,this.tmpQuaternion,this.tmpVector3a),A.parent?+We.REVISION>=123?this.tmpMatrix4a.copy(A.parent.matrixWorld).invert():this.tmpMatrix4a.getInverse(A.parent.matrixWorld):this.tmpMatrix4a.identity(),this.tmpMatrix4a.multiply(this.tmpMatrix4),this.tmpMatrix4a.decompose(A.position,A.quaternion,A.scale)}}}}}detectCollisions(){var h,l;const f=[];this.impactPoint.set(0,0,0),this.impactNormal.set(0,0,0);const A=this.physicsWorld.getDispatcher(),P=A.getNumManifolds();for(let I=0;I<P;I++){let E=A.getManifoldByIndexInternal(I),U=E.getNumContacts();const G=Ammo.castObject(E.getBody0(),Ammo.btRigidBody),Y=Ammo.castObject(E.getBody1(),Ammo.btRigidBody);let we=G.threeObject,Se=Y.threeObject;if(!we||!Se)continue;if(G.name===""&&Y.name==="")continue;const Me=(h=we.body)===null||h===void 0?void 0:h.checkCollisions,T=(l=Se.body)===null||l===void 0?void 0:l.checkCollisions,Z=we.body.breakable,J=Se.body.breakable,L=Me||T,N=Z||J;if(!L&&!N)continue;let X=!1,Q=0,oe="start";for(let Pe=0;Pe<U;Pe++){const Re=E.getContactPoint(Pe),Ee=Re.getDistance();if(Ee<=0){X=!0;const Ye=Re.getAppliedImpulse(),Qe=Re.get_m_positionWorldOnB(),lt=Re.get_m_normalWorldOnB();if(Me||T){const ot=[we.name,Se.name].sort(),Ne=`${ot[0]}__${ot[1]}`;this.earlierDetectedCollisions.find(at=>at.combinedName===Ne)&&(oe="collision"),f.find(at=>at.combinedName===Ne)||(f.push({combinedName:Ne,collision:!0}),this.collisionEvents.emit("collision",{bodies:[we,Se],event:oe}))}Ye>=Q&&(Q=Ye,(Z||J)&&(this.impactPoint.set(Qe.x(),Qe.y(),Qe.z()),this.impactNormal.set(lt.x(),lt.y(),lt.z())));break}}if(!X)continue;if(!N)continue;const me=5,Te=2;if(this.emptyV3.set(0,0,0),we.userData.ammoPhysicsData={mass:1,velocity:this.emptyV3,angularVelocity:this.emptyV3,breakable:Z,physicsBody:G},Se.userData.ammoPhysicsData={mass:1,velocity:this.emptyV3,angularVelocity:this.emptyV3,breakable:J,physicsBody:Y},typeof we.fragmentDepth=="undefined"&&(we.fragmentDepth=0),typeof Se.fragmentDepth=="undefined"&&(Se.fragmentDepth=0),Z&&Q>me&&we.fragmentDepth<Te){const Pe=this.convexBreaker.subdivideByImpact(we,this.impactPoint,this.impactNormal,1,2),Re=Pe.length;for(let Ee=0;Ee<Re;Ee++){const Ye=G.getLinearVelocity(),Qe=G.getAngularVelocity(),lt=Pe[Ee];lt.userData.ammoPhysicsData.velocity.set(Ye.x(),Ye.y(),Ye.z()),lt.userData.ammoPhysicsData.angularVelocity.set(Qe.x(),Qe.y(),Qe.z()),this.createDebrisFromBreakableObject(lt,we)}this.objectsToRemove[this.numObjectsToRemove++]=we}if(J&&Q>me&&Se.fragmentDepth<Te){const Pe=this.convexBreaker.subdivideByImpact(Se,this.impactPoint,this.impactNormal,1,2),Re=Pe.length;for(let Ee=0;Ee<Re;Ee++){const Ye=Y.getLinearVelocity(),Qe=Y.getAngularVelocity(),lt=Pe[Ee];lt.userData.ammoPhysicsData.velocity.set(Ye.x(),Ye.y(),Ye.z()),lt.userData.ammoPhysicsData.angularVelocity.set(Qe.x(),Qe.y(),Qe.z()),this.createDebrisFromBreakableObject(lt,Se)}this.objectsToRemove[this.numObjectsToRemove++]=Se}}for(let I=0;I<this.numObjectsToRemove;I++)this.removeDebris(this.objectsToRemove[I]);this.numObjectsToRemove=0,this.earlierDetectedCollisions.forEach(I=>{const{combinedName:E}=I;if(!f.find(U=>U.combinedName===E)){const U=E.split("__"),G=this.rigidBodies.find(Se=>Se.name===U[0]),Y=this.rigidBodies.find(Se=>Se.name===U[1]),we="end";G&&Y&&this.collisionEvents.emit("collision",{bodies:[G,Y],event:we})}}),this.earlierDetectedCollisions=[...f]}setGravity(h=0,l=-9.8,f=0){this.tmpBtVector3.setValue(h,l,f),this.physicsWorld.setGravity(this.tmpBtVector3)}get debug(){return this.isHeadless?null:{enable:()=>{this.debugDrawer.enable()},mode:(h=1)=>{this.debugDrawer.setDebugMode(h)},disable:()=>{this.debugDrawer.disable()}}}start(){if(typeof Ammo=="undefined"){mi.default("Are you sure you included ammo.js?");return}typeof Ammo=="function"?Ammo().then(()=>{this.setup()}):this.setup()}get add(){return{collider:(h,l,f)=>this.collisionEvents.addCollider(h,l,f),constraints:this.constraints.addConstraints,existing:(h,l)=>this.addExisting(h,l),plane:(h={},l={})=>this.shapes.addPlane(h,l),sphere:(h={},l={})=>this.shapes.addSphere(h,l),ground:(h={},l={})=>this.shapes.addGround(h,l),box:(h={},l={})=>this.shapes.addBox(h,l),cylinder:(h={},l={})=>this.shapes.addCylinder(h,l),cone:(h={},l={})=>this.shapes.addCone(h,l),torus:(h={},l={})=>this.shapes.addTorus(h,l),extrude:(h,l={})=>this.shapes.addExtrude(h,l),raycaster:(h="closest")=>h==="closest"?new Js.ClosestRaycaster(this):new Js.AllHitsRaycaster(this)}}prepareThreeObjectForCollisionShape(h,l={}){var f,A;const{autoCenter:P=!1}=l,I={width:1,height:1,depth:1,radius:1,radiusTop:1,radiusBottom:1,tube:.4,tubularSegments:6};let E="unknown";const U=((f=h.geometry)===null||f===void 0?void 0:f.type)||"unknown";/box/i.test(U)?E="box":/cone/i.test(U)?E="cone":/cylinder/i.test(U)?E="cylinder":/extrude/i.test(U)?E="extrude":/plane/i.test(U)?E="plane":/sphere/i.test(U)?E="sphere":/torus/i.test(U)&&(E="torus");let G=Object.assign(Object.assign({},I),(A=h==null?void 0:h.geometry)===null||A===void 0?void 0:A.parameters);return l.shape?(G=Object.assign(Object.assign({},I),l),E=l.shape):h.shape&&(E=h.shape),Object.keys(G).forEach(Y=>{typeof G[Y]=="undefined"&&I[Y]&&(G[Y]=I[Y])}),P&&h.geometry.center(),E==="cylinder"&&(G.radius=l.radius||G.radiusTop),E==="extrude"&&(E="hacd"),(E==="mesh"||E==="convex")&&(E="convexMesh"),E==="concave"&&(E="concaveMesh"),E==="unknown"&&(mi.default(`Shape for ${h==null?void 0:h.name} not recognized! Will fallback to box.`),E="box"),{shape:E,params:G,object:h}}createCollisionShape(h,l,f){const A=(f==null?void 0:f.quaternion)?f==null?void 0:f.quaternion:new We.Quaternion(0,0,0,1),{axis:P="y"}=l,I=new Ammo.btVector3,E=f==null?void 0:f.geometry;f&&(E==null?void 0:E.isGeometry)&&(f.geometry=new We.BufferGeometry().fromGeometry(E));const U=T=>{const Z=new We.Matrix4().elements,J=[],L=[],N=[];return Vi.iterateGeometries(T,{},(X,Q,oe)=>{J.push(X),L.push(Q),N.push(oe)}),{vertices:J,matrices:L,indexes:N,matrixWorld:Z}};let G={};this.complexShapes.indexOf(h)>0&&(G=U(f));let Y;switch(h){case"box":I.setValue(l.width/2,l.height/2,l.depth/2),Y=new Ammo.btBoxShape(I);break;case"sphere":Y=new Ammo.btSphereShape(l.radius);break;case"cylinder":switch(P){case"y":I.setValue(l.radius,l.height/2,l.radius),Y=new Ammo.btCylinderShape(I);break;case"x":I.setValue(l.height/2,l.radius,l.radius),Y=new Ammo.btCylinderShapeX(I);break;case"z":I.setValue(l.radius,l.radius,l.height/2),Y=new Ammo.btCylinderShapeZ(I);break}break;case"cone":switch(P){case"y":Y=new Ammo.btConeShape(l.radius,l.height);break;case"x":Y=new Ammo.btConeShapeX(l.radius,l.height);break;case"z":Y=new Ammo.btConeShapeZ(l.radius,l.height);break}break;case"capsule":switch(P){case"y":Y=new Ammo.btCapsuleShape(l.radius,l.height);break;case"x":Y=new Ammo.btCapsuleShapeX(l.radius,l.height);break;case"z":Y=new Ammo.btCapsuleShapeZ(l.radius,l.height);break}break;case"torus":Y=Gg.createTorusShape(l,A);break;case"plane":Y=Vi.createTriMeshShape(G.vertices,G.matrices,G.indexes,G.matrixWorld,Object.assign(Object.assign({},l),{concave:!1}));break;case"hull":Y=Vi.createHullShape(G.vertices,G.matrices,G.matrixWorld,l);break;case"hacd":Y=Vi.createHACDShapes(G.vertices,G.matrices,G.indexes,G.matrixWorld,l);break;case"vhacd":Y=Vi.createVHACDShapes(G.vertices,G.matrices,G.indexes,G.matrixWorld,l);break;case"convexMesh":Y=Vi.createTriMeshShape(G.vertices,G.matrices,G.indexes,G.matrixWorld,Object.assign(Object.assign({},l),{concave:!1}));break;case"concaveMesh":Y=Vi.createTriMeshShape(G.vertices,G.matrices,G.indexes,G.matrixWorld,Object.assign(Object.assign({},l),{concave:!0}));break}Ammo.destroy(I);const{x:we,y:Se,z:Me}=l;return(we||Se||Me)&&(Y.offset={x:we||0,y:Se||0,z:Me||0}),Array.isArray(Y)&&(Y=this.mergeCollisionShapesToCompoundShape(Y)),Y}mergeCollisionShapesToCompoundShape(h){const l=new Ammo.btCompoundShape;return h.forEach(f=>{const{offset:A}=f,P=new Ammo.btTransform;P.setIdentity(),A&&P.getOrigin().setValue(A.x||0,A.y||0,A.z||0),l.addChildShape(P,f)}),l}addExisting(h,l={}){const{hasBody:f}=h;if(f){console.warn(`[Enable3d]: Object "${h.name}" already has a physical body!`);return}const A=new We.Vector3,P=new We.Quaternion,I=new We.Vector3;h.getWorldPosition(A),h.getWorldQuaternion(P),h.getWorldScale(I);const E=(l.collisionFlags||0).toString(2).slice(-1)==="1",U=(l.collisionFlags||0).toString(2).slice(-2,-1)==="1",{shape:G="unknown",compound:Y=[],mass:we=E||U?0:1,collisionFlags:Se=0,collisionGroup:Me=1,collisionMask:T=-1,offset:Z=void 0,breakable:J=!1,addChildren:L=!0,margin:N=.01,ignoreScale:X=!1}=l;if(X&&I.set(1,1,1),Y.length>=1){const Pe=Y.map(Qe=>this.createCollisionShape(Qe.shape,Qe)),Re=this.mergeCollisionShapesToCompoundShape(Pe),Ee=this.finishCollisionShape(Re,A,P,I,N),Ye=this.collisionShapeToRigidBody(Re,Ee,we,U);this.addRigidBodyToWorld(h,Ye,Se,Me,T,J,Z),h.body.ignoreScale=X;return}const Q=[];if(G!=="unknown"||h.isMesh){const Pe=this.prepareThreeObjectForCollisionShape(h,l),Re=this.createCollisionShape(Pe.shape,Pe.params,Pe.object);Q.push(Re)}if(G==="unknown"&&L&&h.children.length>=1&&h.children.forEach(Pe=>{if(Pe.isMesh){const Re=this.prepareThreeObjectForCollisionShape(Pe),Ee=this.createCollisionShape(Re.shape,Re.params,Re.object);Ee.offset=Pe.position.clone(),Q.push(Ee)}}),Q.length===0){const Pe=this.prepareThreeObjectForCollisionShape(h,l),Re=this.createCollisionShape(Pe.shape,Pe.params,Pe.object);Q.push(Re)}const oe=Q.length===1?Q[0]:this.mergeCollisionShapesToCompoundShape(Q),me=this.finishCollisionShape(oe,A,P,I,N),Te=this.collisionShapeToRigidBody(oe,me,we,U);this.addRigidBodyToWorld(h,Te,Se,Me,T,J,Z),h.body.ignoreScale=X}addRigidBodyToWorld(h,l,f,A,P,I,E){this.rigidBodies.push(h),this.physicsWorld.addRigidBody(l,A,P);const U=Object.values(l)[0];l.name=h.name,h.body=new zg.default(this,l),h.hasBody=!0,h.ptr=U,l.threeObject=h,I&&(h.body.breakable=!0),E&&(h.body.offset=Object.assign({x:0,y:0,z:0},E)),h.body.setCollisionFlags(f)}finishCollisionShape(h,l,f,A,P){h.setMargin(P);const I=new Ammo.btQuaternion(0,0,0,1);I.setValue(f.x,f.y,f.z,f.w);const E=new Ammo.btTransform;E.setIdentity(),E.getOrigin().setValue(l.x,l.y,l.z),E.setRotation(I),Ammo.destroy(I);const U=new Ammo.btVector3(A.x,A.y,A.z);return h.setLocalScaling(U),Ammo.destroy(U),E}collisionShapeToRigidBody(h,l,f,A){const P=new Ammo.btDefaultMotionState(l),I=new Ammo.btVector3(0,0,0);f>0&&h.calculateLocalInertia(f,I);const E=new Ammo.btRigidBodyConstructionInfo(f,P,h,I),U=new Ammo.btRigidBody(E);return(f>0||A)&&U.setActivationState(4),U}}fe.AmmoPhysics=rt}),Kg=dn(function(an,fe){var rt=Eo&&Eo.__createBinding||(Object.create?function(l,f,A,P){P===void 0&&(P=A),Object.defineProperty(l,P,{enumerable:!0,get:function(){return f[A]}})}:function(l,f,A,P){P===void 0&&(P=A),l[P]=f[A]}),h=Eo&&Eo.__exportStar||function(l,f){for(var A in l)A!=="default"&&!Object.prototype.hasOwnProperty.call(f,A)&&rt(f,l,A)};Object.defineProperty(fe,"__esModule",{value:!0}),h(Jg,fe)});export{ql as a,We as b,Aa as c,Kg as d,Zs as e,np as f,ep as g,mi as l,rp as p,ip as t};
